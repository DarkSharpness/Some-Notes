# Linux命令行以及Shell脚本

记录Linux下一些常见的命令用法，以及Shell脚本的编写

包含了[Awk编程](#31-awk编程)，[Tcl编程](#33-tcl编程)


## 参考书籍

Linux命令行与Shell脚本编程大全 3rd Edition. Richard Blum, Christine Bresnahan, 2016


## 目录

+ [**1**](#1-常用基本命令以及命令行参数) 常用基本命令以及命令行参数
    + [**1.1**](#11-文件管理) 文件管理
        + [**1.1.1**](#111-ls或dir) ls或dir
        + [**1.1.2**](#112-pwd) pwd
        + [**1.1.3**](#113-cd) cd
        + [**1.1.4**](#114-touch) touch
        + [**1.1.5**](#115-cp) cp
        + [**1.1.6**](#116-mv) mv
        + [**1.1.7**](#117-rm和rmdir) rm和rmdir
        + [**1.1.8**](#118-mkdir) mkdir
        + [**1.1.9**](#119-ln) ln
        + [**1.1.10**](#1110-file) file
        + [**1.1.11**](#1111-catsplit和cut) cat，split和cut
        + [**1.1.12**](#1112-less和more) less和more
        + [**1.1.13**](#1113-tail和head) tail和head
        + [**1.1.14**](#1114-文件归档压缩和解压缩) 文件归档、压缩和解压缩
        + [**1.1.15**](#1115-sort) sort
        + [**1.1.16**](#1116-grep) grep
        + [**1.1.17**](#1117-which和type) which和type
        + [**1.1.18**](#1118-chmod和umask) chmod和umask
        + [**1.1.19**](#1119-chown和chgrp) chown和chgrp
        + [**1.1.20**](#1120-date) date
        + [**1.1.21**](#1121-fallocate) fallocate
        + [**1.1.22**](#1122-losetup) losetup
        + [**1.1.23**](#1123-echo和printf技巧) echo和printf技巧
    + [**1.2**](#12-系统管理) 系统管理
        + [**1.2.1**](#121-ps) ps
        + [**1.2.2**](#122-top) top
        + [**1.2.3**](#123-kill和killall) kill和killall
        + [**1.2.4**](#124-mount和umount) mount和umount
        + [**1.2.5**](#125-du和df) du和df
        + [**1.2.6**](#126-用户管理) 用户管理
    + [**1.3**](#13-shell的基本概念以及用法) shell的基本概念以及用法
        + [**1.3.1**](#131-命令的运行以及shell的父子关系) 命令的运行以及shell的父子关系
        + [**1.3.2**](#132-连续执行进程列表) 连续执行，进程列表
        + [**1.3.3**](#133-后台运行) 后台运行
        + [**1.3.4**](#134-协程) 协程
        + [**1.3.5**](#135-内建命令和外部命令) 内建命令和外部命令
        + [**1.3.6**](#136-history查看命令记录) history查看命令记录
        + [**1.3.7**](#137-alias命令别名) alias命令别名
    + [**1.4**](#14-网络工具) 网络工具
        + [**1.4.1**](#141-nmap) nmap
        + [**1.4.2**](#142-curl) curl
        + [**1.4.3**](#143-tracepath) tracepath
        + [**1.4.4**](#144-dnsutils) dnsutils
+ [**2**](#2-shell脚本基础) shell脚本基础
    + [**2.1**](#21-变量) 变量
        + [**2.1.1**](#211-局部变量) 局部变量
        + [**2.1.2**](#212-全局变量) 全局变量
        + [**2.1.3**](#213-结构变量) 结构变量
        + [**2.1.4**](#214-shell脚本中的引号) shell脚本中的引号
    + [**2.2**](#22-shell脚本基本构成) Shell脚本基本构成
    + [**2.3**](#23-使用一个命令的输出结果) 使用一个命令的输出结果
    + [**2.4**](#24-重定向) 重定向
        + [**2.4.1**](#241-输出重定向) 输出重定向
        + [**2.4.2**](#242-输入重定向) 输入重定向
    + [**2.5**](#25-管道) 管道
    + [**2.6**](#26-整数浮点以及字符串运算) 整数、浮点以及字符串运算
        + [**2.6.1**](#261-传统的bourne-shell格式) 传统的Bourne shell格式
        + [**2.6.2**](#262-bash支持的替代写法) bash支持的替代写法
        + [**2.6.3**](#263-双括号) 双括号
        + [**2.6.4**](#264-浮点计算) 浮点计算
    + [**2.7**](#27-退出状态) 退出状态
    + [**2.8**](#28-判断) 判断
        + [**2.8.1**](#281-整型数值) 整型数值
        + [**2.8.2**](#282-字符串比较) 字符串比较
        + [**2.8.3**](#283-文件处理) 文件处理
        + [**2.8.4**](#284-双括号) 双括号
    + [**2.9**](#29-迭代遍历) 迭代/遍历
    + [**2.10**](#210-循环) 循环
        + [**2.10.1**](#2101-c风格for) C风格for
        + [**2.10.2**](#2102-while) while
        + [**2.10.3**](#2103-until) until
        + [**2.10.4**](#2104-break) break
        + [**2.10.5**](#2105-continue) continue
        + [**2.10.6**](#2106-处理输出) 处理输出
    + [**2.11**](#211-用户输入) 用户输入
        + [**2.11.1**](#2111-命令行参数) 命令行参数
        + [**2.11.2**](#2112-遍历所有参数) 遍历所有参数
        + [**2.11.3**](#2113-选项与参数处理getopt) 选项与参数处理：getopt
        + [**2.11.4**](#2114-选项与参数处理getopts) 选项与参数处理：getopts
        + [**2.11.5**](#2115-获取用户交互输入read) 获取用户交互输入：read
    + [**2.12**](#212-输入输出以及重定向) 输入输出以及重定向
        + [**2.12.1**](#2121-stderr重定向) STDERR重定向
        + [**2.12.2**](#2122-永久重定向文件描述符到文件) 永久重定向：文件描述符到文件
        + [**2.12.3**](#2123-永久重定向文件描述符到文件描述符) 永久重定向：文件描述符到文件描述符
        + [**2.12.4**](#2124-lsof列出打开的文件描述符) lsof列出打开的文件描述符
        + [**2.12.5**](#2125-使用devnull丢弃命令的标准输出) 使用/dev/null丢弃命令的标准输出
    + [**2.13**](#213-临时文件以及目录) 临时文件以及目录
    + [**2.14**](#214-使用tee分流输出到文件以及显示器) 使用tee分流输出到文件以及显示器
    + [**2.15**](#215-函数) 函数
        + [**2.15.1**](#2151-函数基本格式) 函数基本格式
        + [**2.15.2**](#2152-函数全局变量和局部变量) 函数：全局变量和局部变量
        + [**2.15.3**](#2153-函数执行返回值) 函数执行返回值
        + [**2.15.4**](#2154-函数结果返回值) 函数结果返回值
        + [**2.15.5**](#2155-函数参数) 函数参数
        + [**2.15.6**](#2156-数组参数以及结果) 数组参数以及结果
        + [**2.15.7**](#2157-使用库) 使用库
    + [**2.16**](#216-脚本作业控制) 脚本作业控制
        + [**2.16.1**](#2161-使用以及捕获信号) 使用以及捕获信号
        + [**2.16.2**](#2162-后台运行) 后台运行
        + [**2.16.3**](#2163-优先级以及谦让度) 优先级以及谦让度
        + [**2.16.4**](#2164-设置预约运行) 设置预约运行
        + [**2.16.5**](#2165-设置定时任务) 设置定时任务
        + [**2.16.6**](#2166-ftp和samba命令行客户端) FTP和Samba命令行客户端
+ [**3**](#3-shell脚本进阶) shell脚本进阶
    + [**3.1**](#31-awk编程) Awk编程
        + [**3.1.1**](#311-打印) 打印
        + [**3.1.2**](#312-变量) 变量
        + [**3.1.3**](#313-算术逻辑) 算术逻辑
        + [**3.1.4**](#314-正则表达式) 正则表达式
        + [**3.1.5**](#315-程序流控制) 程序流控制
        + [**3.1.6**](#316-函数) 函数
        + [**3.1.7**](#317-内置函数) 内置函数
    + [**3.2**](#32-sed用法) sed用法
    + [**3.3**](#33-tcl编程) Tcl编程
        + [**3.3.1**](#331-hello-world) Hello World
        + [**3.3.2**](#332-变量基础) 变量基础
        + [**3.3.3**](#333-表达式运算) 表达式运算
        + [**3.3.4**](#334-程序流控制) 程序流控制
        + [**3.3.5**](#335-自定义函数) 自定义函数
        + [**3.3.6**](#336-列表) 列表
        + [**3.3.7**](#337-字符串处理) 字符串处理
        + [**3.3.8**](#338-数组) 数组
        + [**3.3.9**](#339-字典) 字典
        + [**3.3.10**](#3310-文件) 文件
        + [**3.3.11**](#3311-调用其他可执行文件) 调用其他可执行文件
        + [**3.3.12**](#3312-info) info
        + [**3.3.13**](#3313-source) source
        + [**3.3.14**](#3314-运行时创建命令eval) 运行时创建命令：eval
        + [**3.3.15**](#3315-模块化与命名空间) 模块化与命名空间
        + [**3.3.16**](#3316-错误处理) 错误处理
        + [**3.3.17**](#3317-命令行参数) 命令行参数
        + [**3.3.18**](#3318-tcl网络开发) Tcl网络开发
        + [**3.3.19**](#3319-文件进阶fblocked和fconfigure) 文件进阶：fblocked和fconfigure
        + [**3.3.20**](#3320-时间) 时间
    + [**3.4**](#34-expect编程) expect编程
        + [**3.4.1**](#341-简介) 简介
        + [**3.4.2**](#342-示例) 示例
        + [**3.4.3**](#343-命令详解) 命令详解

## 1 常用基本命令以及命令行参数

## 1.1 文件管理

包含常用的目录浏览以及文件处理命令

### 1.1.1 ls或dir

列出文件

```shell
ls

# 命令行参数
# -R 递归显示目录下内容
# -a 列出所有，包括.开头的隐藏文件
# -l 详细信息，格式：mode owner group size time name
#     mode：l代表链接，d代表目录，b代表块设备，c代表字符设备，p代表FIFO。rwx分别代表读写运行权限
# -F 用于区分目录，在目录后加/
# -h 显示文件大小时自动换算为K，M，G
# --time=atime 显示访问时间而非修改时间
# -i inode编号，系统中每一个文件和目录都有，且唯一
```

文件匹配

```shell
ls *.txt            # 显示以.txt结尾
ls date?.txt        # 显示date1.txt，datea.txt等
ls date[12].txt     # 显示date1.txt，date2.txt
ls date[1-3].txt    # 显示date1.txt，date2.txt，date3.txt
ls date[!1].txt     # 不显示date1.txt
```

### 1.1.2 pwd

打印当前目录

### 1.1.3 cd

到一个目录下

`../`代表父目录，`./`代表当前目录

### 1.1.4 touch

新建/访问一下文件，不会修改已有文件

```shell
touch test.txt
```

### 1.1.5 cp

拷贝文件

```shell
cp source.txt destination.txt
cp source.txt destination/

# 命令行参数
# -r 递归，用于复制一个目录
# -i 遇到同名文件询问是否覆盖
# -v 显示当前动作
# -p 保留文件时间戳，mode，用户等信息
# --preserve=mode,ownership,timestamps
# --preserve=all
# -f 强制拷贝
```

### 1.1.6 mv

移动/重命名文件

```shell
mv source.txt destination.txt
```

### 1.1.7 rm和rmdir

删除/删除目录

```shell
rm 

# 命令行参数
# -i 询问是否删除
# -r 递归删除一个目录
# -f 强制删除
```

### 1.1.8 mkdir

创建目录

```shell
mkdir 

# 命令行参数
# -p 如果创建多级目录，则递归生成
```

### 1.1.9 ln

链接

```shell
ln file link

# 命令行参数
# 无参 硬链接，信息和源文件相同，是同一个文件（使用同一个inode），等同于引用源文件，只能用于同一个文件系统
# -s 符号链接，创建的是一个符号文件，不是同一个文件，可以用于不同文件系统之间的引用
```

### 1.1.10 file

查看文件类型

### 1.1.11 cat，split和cut

`cat`用于输出/连接文件，并输出到标准输出

```shell
cat file1.txt
cat file1.txt file2.txt

# 命令行参数
# -n -b 显示行号
```

`split`用于分割文件（例如用于FAT32文件系统），会自动生成文件名

```shell
split -n 4 large.zip # 按照大致相同大小分割为4个文件，xaa，xab，xac，xad
split -d -n 4 large.zip # 同上，但文件名为x00，x01，x02，x03
split -C 4G large.zip # 分割为4G大小文件
split -l 100 dump.log # 分割为100行文本文件
split -n l/4 dump.log # 分割为4个文件，但保持行完整性

# 命令行参数
# -n 大致分割为n等分
# -d 使用数字命名文件
# -x 使用16进制命名文件
# -a 指定文件命名后缀长度，默认2
# -C 指定分割时每个文件最多大小
# -e 不要生成空文件
# -l 用于字符文件，每个文件行数
# -t 指定文本行分隔符
```

`cut`用于从文本文件的每一行提取特定位置的字符

```shell
cat /etc/group | cut -f 1 -d : # 冒号为分隔符，取第一个域
cat /etc/group | cut -c 1-10 # 显示1-10个字符
cat /etc/group | cut -b 2-3,5 # 显示第2到3，第5字节

# 命令行参数
# -b 指定每行取字节范围
# -c 指定每行取字符范围
# -f 指定每行域，-d指定分隔符
```

### 1.1.12 less和more

分页文本浏览器

### 1.1.13 tail和head

查看一个文件的开头n行或结尾n行

```shell
head -n 5 log.txt
tail -n 5 log.txt
tail -5 log.txt
```

### 1.1.14 文件归档、压缩和解压缩

归档常用工具：`tar`

压缩常用工具：`gzip`，`bzip2`，`zip`，`xz`，`zstd`

解压缩：`gzip`，`bzip2`，`unzip`，`xz`，`zstd`

**tar**

```shell
tar option file

# 命令行参数
# 一般操作
# -x 解压
# -u 更新，仅更改新近修改的文件
# -c -f file1 file2 创建归档
# -t 列出内容
# -f 指出文件
# -p 保留权限
# -v 显示过程

# 解压选项
# -a 根据文件后缀自动决定解压方式
# -z 使用gzip
# --zstd 使用zstd
# -j 使用bzip2
# -J 使用xz
```

**gzip**

```shell
gzip option file

# 命令行参数
# -d 解压
# -t 测试压缩包
# -v 显示过程
# -q 无输出
# -c 输出到标准输出，常用于管道操作
# -1 最快，最小压缩率
# -9 最慢，最大压缩率
```

**bzip2**

```shell
bzip2 option file

# 命令行参数
# -d 解压
# -z 压缩
# -k 保留输入文件
# -t 测试压缩包
# -v 显示过程
# -q 无输出
# -c 输出到标准输出，常用于管道操作
# -1 最快，最小压缩率
# -9 最慢，最大压缩率
```

**xz**

```shell
xz option file

# 命令行参数
# -d 解压
# -z 压缩
# -k 保留输入文件
# -t 测试压缩包
# -v 显示过程
# -q 无输出
# -c 输出到标准输出，常用于管道操作
# -0 最快，最小压缩率
# -9 最慢，最大压缩率
# --threads=N 使用N个线程压缩，0默认使用最多线程
```

**zstd**

```shell
zstd option file -o file

# 命令行参数
# -d 解压
# -k 保留输入文件（默认）
# --test 测试压缩包
# -v 显示过程
# -q 无输出
# -c 输出到标准输出，常用于管道操作
# -1 最快，最小压缩率
# -19 最慢，最大压缩率
```

**zip/unzip**

```shell
zip option file

# 命令行参数
# -u 仅更新以及添加的文件
# -q 不显示过程
# -v 显示过程
# -T 测试压缩包
# -1 最快压缩，最小压缩率
# -9 最慢压缩，最大压缩率
```

```shell
unzip option file

# 命令行参数
# -p 解压到管道
# -l 列出包含的文件
# -t 测试压缩包
# -p 更新文件
# -q 不显示过程
# -v 显示过程
# -o 直接覆盖文件
```

### 1.1.15 sort

对文件内容排序

```shell
sort file1.txt

# 命令行参数
# -n 按数字识别并排序
# -g 按浮点/科学计数法排序
# -M 按月份简写排序
# -b 忽略起始空白
# -f 忽略大小写
# -o file 写入到指定文件
# -r 升序改降序
# -t ':'指定分隔符
# -k 指定排序字段
```

### 1.1.16 grep

在一串字符中查找匹配的行

```shell
grep options pattern file.txt
cat file.txt | grep option pattern
egrep regexp file.txt

# pattern可以为正则表达式

# 命令行参数
# -v 反选输出，例如删除文件时排除一个文件时有用
# -n 显示行号
# -c 匹配行数
# -e pattern 指定多个模式
```

### 1.1.17 which和type

`which`和`type`可以用于在bash可执行文件路径变量下查找指定的文件，另外`type`还可以用于指示一个命令是否是内建命令

```shell
which lsblk
type cd
```

### 1.1.18 chmod和umask

`chmod`可以更改文件的权限，而`umask`可以更改当前创建文件时使用的默认权限。`chmod`的三个权限分别使用`u`，`g`，`o`表示

在linux中，`-`代表**普通文件**，`l`代表**链接**，`d`代表**目录**，`b`代表**块设备**，`c`代表**字符设备**

一般的权限可以使用三位八进制表示，比如`rwxr-xr--`可以表示为`754`

linux的权限除`rwx`以外，`x`位常见的权限还有`t`和`s`。`s`代表运行时重新设置UID和GID，常用于`sudo`等，而`t`代表保留文件或目录

```shell
chmod u+x ./test1.sh
chmod 777 ./test2.sh
```

使用`umask`时，遮挡指定权限位，比如`022`，设置权限`755`。`0022`的第一位八进制为粘着位，分别代表使能SUID，SGID以及粘着位。

**SUID指的就是文件被用户使用时会以文件属主身份运行，SGID同理，但是也会使得一个目录下创建的文件全部使用目录的属组，而粘着指的就是进程结束以后文件还驻留在内存**

```shell
umask 0022
umask 022
```

### 1.1.19 chown和chgrp

```shell
chown k file.txt
chgrp sample file.txt
```

### 1.1.20 date

用于显示时间

```shell
date +%M%S
date --date="@2147483647" #计算一个具体的UNIX时间对应的日期与时间

# 常用格式
# %a %A 星期简写以及全称
# %b %B 月份简写以及全称
# %Y %y 年份
# %m 月份，补0
# %d 日期，补0
# %u 星期，1..7
# %H 小时，24，补0
# %I 小时，12，补0
# %P %p AM或PM
# %M 分钟，补0
# %S 秒种，补0
# %N 纳秒
# %s 从UNIX零点开始的秒数
# %j 一年中的第几天
```

### 1.1.21 fallocate

用于创建一个指定大小的文件，常用于创建磁盘映像文件

```shell
fallocate -l 1G disk.img # 创建1G大小的文件
```

### 1.1.22 losetup

常用于将磁盘/光盘映像文件创建为块设备

```shell
losetup -f --show raw.img # 寻找第一个未使用的loop名（例如loop1），创建/dev/loop1后输出该loop设备路径
losetup -d /dev/loop2 # 将loop2和对应文件解耦（loop2节点不会删除）
losetup -D # 解耦所有loop
losetup -a # 显示当前所有loop设备
losetup -l /dev/loop0 # 显示loop0信息
losetup -fr --show raw2.img # 将raw2.img创建为只读loop
losetup -j raw.img # 显示和文件raw.img相关的loop
```

### 1.1.23 echo和printf技巧

`echo`默认原样输出给出的字符串

```
$ echo "Hello\n"
Hello\n
$
```

添加`-n`参数不输出换行符

```
$ echo -n "Hello"
Hello$
```

添加`-e`参数使能转义

```
$ echo -e "Count\t3"
Count   3
```

> `printf`功能基本相当于`echo -en`

可以通过转义指定输出字体颜色

```
$ RED="\033[0;31m"
$ NOCOLOR="\033[0m"
$ echo -e "This is ${RED}red${NOCOLOR}!"
```

可用色码

| 颜色 | 码 |
| :- | :- |
| 黑 | `\033[0;30m` |
| 红 | `\033[0;31m` |
| 绿 | `\033[0;32m` |
| 橙/棕 | `\033[0;33m` |
| 蓝 | `\033[0;34m` |
| 紫 | `\033[0;35m` |
| 青 | `\033[0;36m` |
| 浅灰 | `\033[0;37m` |
| 深灰 | `\033[1;30m` |
| 浅红 | `\033[1;31m` |
| 浅绿 | `\033[1;32m` |
| 黄 | `\033[1;33m` |
| 浅蓝 | `\033[1;34m` |
| 浅紫 | `\033[1;35m` |
| 浅青 | `\033[1;36m` |
| 白 | `\033[1;37m` |
| 无 | `\033[0m` |

## 1.2 系统管理

### 1.2.1 ps

显示当前进程

```shell
ps

# 命令行参数

# UNIX
# 过滤
# -A -e 显示所有进程
# -a 列出除控制进程以及无终端进程以外所有进程
# -d 列出除控制进程以外的进程
# -C cmdlist 列出所有在cmd列表中的进程（命令名，如xinit）
# -G -g grplist 列出所有在group列表中的进程（组名或组ID）
# -U userlist 列出属主uid在userlist中的进程（用户名或用户ID）
# -u userlist 显示有效用户uid在userlist中的进程
# -p pidlist 显示PID在pidlist中的进程
# -s sessionlist 显示会话ID在sessionlist中的进程
# -t ttylist 显示终端ID在ttylist中的进程
# 显示格式
# 无参 显示默认参数（PID,TTY,TIME,CMD）
# -o format 仅显示format规定输出列
# -O format 显示默认输出列以及format规定输出列
# -F 显示完整格式（default+UID,PPID,C,SZ,RSS,PSR,STIME）
# -M 显示安全信息（default+LABEL）
# -c 显示额外调度器信息（default+CLS,PRI）
# -j 显示任务信息（default+PGID,SID）
# -l 显示长列表（default+F,S,UID,PPID,C,PRI,NI,ADDR,SZ,WCHAN）
# -z 显示安全标签（SELinux）
# -H 层级显示
# -n namelist WCHAN显示的值
# -L 显示进程的线程

# BSD
# 过滤
# T 显示于当前终端有关
# a 显示和任意终端有关
# g 显示所有，包括控制进程
# x 显示所有，包括无终端
# r 仅显示运行中
# U 属主用户UID
# p 进程PID
# t 终端tty号
# 显示格式
# O 格式
# z 安全信息SELinux
# j 任务信息
# l 长模式
# o format 仅format
# ----新增格式----
# s 信号格式
# u 基于用户
# v 基于虚拟内存
# N namelist WCHAN显示的值
# O order 显示顺序
# S 将子进程数据加到父进程上
# c 显示真实命令名称
# e 显示命令的环境变量
# f 分层显示
# h 不显示头信息（表头）
# k sort 按某列排序
# n 用户ID和组ID
# H 将线程按进程显示
# m 在进程后显示线程
# L 列出所有格式指定符
```

显示的各参数含义

| 名称 | 定义 |
| :-: | :-: |
| **UID**    |  进程属主 |
| **PID**    |  进程ID  |
| **PPID**   |  父进程ID    |
| **C**      |  CPU利用率   |
| **STIME**  |  启动时时间  |
| **TTY**    |  终端号  |
| **TIME**   |  累计CPU时间 |
| **CMD**    |  程序名  |
| **F**      |  进程系统标记    |
| **S**      |  进程状态（`D`不可中断休眠，`S`可中断休眠，`I`空闲的内核进程，`R`运行或可运行，`Z`僵尸进程，`T`停止或跟踪，`X`已终结）|
| **PRI**    |  优先级，越小的数字代表越高的优先级 |
| **NI**     |  谦让度  |
| **ADDR**   |  内存地址    |
| **SZ**     |  swap所需大致空间    |
| **WCHAN**  |  进程休眠的内核函数地址  |
| **PSR**    |  运行在哪颗CPU上 |

BSD格式

| 名称 | 定义 |
| :-: | :-: |
| **VSZ:**      | 进程占内存大小 |
| **RSS:**      | 未swap时占用的物理内存 |
| **STAT:**     | 双字符状态码（UNIX格式加第二个字符，`<`高优先级，`N`低优先级，`L`有页面锁定在内存，`s`控制进程，`l`多线程，`+`运行在前台） |

**常用用法：**

UNIX格式：
```shell
# 显示STIME，PSR
ps -l 
# 显示S，UID，PPID，PRI，NI，ADDR，SZ
ps -F
# 显示所有
ps -e
# 显示一个用户的进程
ps -U userid
# 显示一个终端的进程
ps -t tty1
# 显示除控制进程以外的进程
ps -d
```

BSD格式：
```shell
# 显示USER，PID，CPU，MEM，VSZ，RSS，TTY，STAT，START，TIME，CMD
ps u
# 显示F，UID，PID，PPID，PRI，NI，VSZ，RSS，WCHAN，STAT，TTY，TIME，CMD
ps l
# 显示线程
ps m
# 累计进程占用资源
ps S
# 按指定列排序显示
ps k sort
# 所有进程，包括控制
ps g
# 所有进程，包括无终端
ps x
# 所有终端
ps a
# 运行中
ps r
```

### 1.2.2 top

和ps类似，区别是top是实时监测显示

部分显示参数

| 名称 | 定义 |
| :-: | :-: |
| **VIRT**   |   占用虚拟内存总量 |
| **RES**    |   占用物理内存总量 |
| **SHR**    |   共享内存总量 |
| **S**      |   进程状态（`D`休眠可中断，`R`运行，`S`休眠，`T`跟踪或停止，`Z`僵尸进程） |
| **TIME+**  |   累计CPU时间 |

### 1.2.3 kill和killall

向进程发送信号，具体的解释见[之后的章节](#216-脚本作业控制)

`kill`使用PID指定进程，`killall`使用进程名指定进程

```shell
kill -s SIGNAL 2350
killall -s SIGNAL http*

# 可用信号
# HUP 挂起
# INT 中断
# QUIT 结束运行
# KILL 无条件终止
# SEGV Segment错误
# TERM 尽可能终止
# STOP 无条件停止运行但不终止
# TSTP 停止暂停并在后台运行
# CONT STOP或TSTP后继续运行
```

### 1.2.4 mount和umount

挂载文件系统

```shell
mount /dev/sdxx /mnt

# 命令行参数
# -a -aF 挂载所有在/etc/fstab里的文件系统
# -f 模拟挂载
# -v 显示挂载过程
# -l 自动添加标签
# -n 挂载但不注册到/etc/mtab
# -p num 加密挂载
# -o 指定挂载选项（ro只读,rw读写,user,check=none,loop）
# -L label
# -U uuid
# -t 指定文件系统类型
```

### 1.2.5 du和df

```shell
du /directory # 查看一个目录占用的空间

# 命令行参数
# -h 自动换算为k,M,G
# -s 统计

df /directory # 查看一个目录所在文件系统剩余空间

# 命令行参数
# -h 自动换算为k,M,G
```

### 1.2.6 用户管理

`useradd`添加用户

```shell
useradd k

# 常用命令行参数
# -m 添加同时穿创建home目录
# -e 设置账户过期时间，使用YYYY-MM-DD指定
# -g group 设置登录组
# -G group1 group2 设置除登录组以外的附属组
# -n 创建一个和用户同名的新组（默认行为）
# -u 指定uid
```

`userdel`删除用户

```shell
userdel k

# 常用命令行参数
# -r 同时删除home
```

`usermod`修改用户字段

```shell
usermod k
usermod -G group1 k
usermod -a -G group2 k

# 常用命令行参数
# -a 将用户添加到组
# -c 添加备注
# -e 修改过期日期
# -g 修改默认登录组
# -G 修改附属组
# -l 修改登录名
# -L 锁定账户
# -p 修改密码
# -U 解除锁定
```

`passwd`或`chpasswd`修改密码

```shell
passwd k
chpasswd k:123456
```

`chsh`和`chfn`

`chsh`可以修改默认登录shell，而`chfn`用于修改`/etc/passwd`

```shell
chsh -s /bin/zsh k
```

`groupadd`创建组

```shell
groupadd group1
```

`groupmod`修改组

```shell
groupmod group1

# 常用命令行参数
# -g 修改GID
# -n 修改组名
```

## 1.3 shell的基本概念以及用法

### 1.3.1 命令的运行以及shell的父子关系

命令进程由bash创建，bash为一个命令进程的父进程。这点可以从`ps`的PPID参数看出。在命令提示符之后输入bash（或其他shell，如zsh等），可以启动一个子shell，通过`exit`命令退出并返回父shell。

查看目前是最底层shell之上第几层子shell，使用变量`$BASH_SUBSHELL`查看即可

### 1.3.2 连续执行，进程列表

类似C语言中的语句，shell可以使用`;`分隔一行中的多个命令，比如

```shell
cd ../ ; pwd ; ls ; cd ~
```

而加上圆括号，则会启动一个子shell执行这些命令，这就是进程列表

```shell
( cd ../ ; pwd ; ls ; cd ~ )
```

而花括号不同，其只相当于分隔符的作用，命令在当前shell执行，并且注意每一个命令后面都要加上分号，这也表明其包含的只是一个顺序执行命令的序列

```shell
{ cd ../ ; pwd ; ls ; cd ~ ;}
```

### 1.3.3 后台运行

可以将一个或一行命令置入后台运行，在命令最后加上`&`，可以在当前shell启动一个进程并将其转到后台，此时用户可以进行其他作业，但后台进程依然会在当前终端输出

```shell
ls & 
```

### 1.3.4 协程

不同于后台运行，协程会在后台新建一个子shell并运行程序，执行结果不会在当前终端显示

```shell
coproc ls
```

也可以对协程命名

```shell
coproc MyTask { sleep 10 ; ls }
```

生成shell的成本并不低，所以尽量减少子shell的级数

### 1.3.5 内建命令和外部命令

Bash的外部命令一般可以在`/bin`找到，而内建命令由bash本身实现。典型的内建命令有`cd`，`exit`，`history`等。

可以使用type查看一个命令是否为内建或外部命令，有的命令同时有内建和外部实现，可以在`type`后加上`-a`参数

```shell
type -a pwd
type -a echo
```

### 1.3.6 history查看命令记录

使用`history`查看命令记录，或删除命令记录，记录条数由`$HISTSIZE`决定

```shell
history 

# 命令行参数
# -c 清除记录
```

重复执行上一条命令，只要使用`!!`命令

```shell
!!
```

### 1.3.7 alias命令别名

查看以及设置当前的命令别名，**注意赋值表达式不能有空格**

```shell
alias command='command alias'

# 常用
alias ls='ls --color=auto'
```

## 1.4 网络工具

### 1.4.1 nmap

`nmap`用于扫描一个网络内的主机以及开放的端口

```
nmap -v -sn 192.168.1.1/24 # Ping扫描
nmap -v -sU hostname # UDP扫描
nmap -v -sS -p10-8192 hostname # TCP握手扫描，10到8192端口
nmap -v -sT hostname # TCP连接建立
sudo nmap -v -sS -p10-8192 -O hostname # 开启OS侦测
```

### 1.4.2 curl

`curl`是一个非常强大的资源传输工具，通过指定的URL请求资源，支持协议如下

```
DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET or TFTP
```

**HTTP/HTTPS示例**

和日常使用浏览器访问不同，**所有的URL都必须使用完整格式，指定使用的协议，域名也要保持完整**

```shell
# 通过https请求一个网页，输出到标准输出
curl https://www.nic.funet.fi

# 请求一个网页并保存到指定文件
curl -o mainpage.html https://www.nic.funet.fi
# 如果URL已知文件名，可以直接使用-O
curl -O http://www.test.me/index.html
```

另外`curl`支持一次获取多个资源，可以使用括号`{}`以及`[]`，示例如下

```shell
# 可以一次指定多个URL
curl https://test.me/msg.txt http://another.me/msg.html

# 连续数字，获取msg1.txt到msg30.txt共30个文件
curl https://test.me/msg[1-30].txt

# 字母，msgc.txt到msgf.txt，同时指定通过8080端口
curl https://test.me:8080/msg[c-f].txt

# 字符串列表，获取msgJan.txt，msgFeb.txt，msgMar.txt
curl https://test.me/msg{Jan,Feb,Mar}.txt

# 括号可以连用但不能嵌套
curl https://test.me/msg[0-5]{Jan,Feb,Mar}.txt
```

**DICT示例**

dict，也即dictionary，字典协议，是一种比较有趣的协议。网站可以通过该协议提供类似在线字典的服务，示例如下

```shell
# 粗略查询符合条件单词，返回单词列表
curl dict://dict.org/m:nitrogen

# 精确查询一个确切单词的含义，常用
curl dict://dict.org/d:nitrogen
```

### 1.4.3 tracepath

`tracepath`用于追踪路由路径

```shell
tracepath 23.17.233.12
```

### 1.4.4 dnsutils

用于域名的查询以及反解析查询

```shell
host 13.114.5.27    # 显示一个ip对应的域名
host pixiv.net      # 反向解析，显示一个域名对应的ip
```

或使用`dig`

```shell
dig github.com
```

## 2 shell脚本基础

## 2.1 变量

在shell中，除数组外所有变量都使用**字符串**形式存储，包括数字。一个变量是否是数字实际需要程序自身判断其有效性。使用`var="2"`和`var=2`效果相同

### 2.1.1 局部变量

shell下的变量一般使用`$`引用，有时还会习惯加上括号`${}`。代码习惯上局部变量使用小写字母，**只对当前shell可见，对子shell也不可见**，可以使用`set`查看当前的所有局部、用户定义和全局变量

```shell
set
```

设置局部变量，**注意赋值表达式不能有空格**

```shell
my_var=sample
my_var="sample with space"
```

删除局部变量，使用`unset`

```shell
unset my_var
```

**字符Permutation**

shell可以支持如下格式的字符排列组合，**有重要应用**

```shell
echo {1..10}            # 打印 1 2 3 4 5 6 7 8 9 10
echo {a,d,0}            # 打印 a d 0
echo {1..4}{a,b,c}      # 打印 1a 1b 1c 2a 2b 2c 3a 3b 3c 4a 4b 4c
```

在`./configure`中的应用

```shell
# 相当于./configure --enable-optimization --enable-trace --enable-rewind
./configure --enable-{optimization,trace,rewind}
```

**变量展开**

我们在很多脚本中会看到形如`${parameter:-word}` `${parameter:+word}`的变量使用形式。这是shell的变量展开功能，主要用于设置默认值等

| 格式 | 作用 |
| :- | :- |
| `${parameter:-word}` | 如果`parameter`为空或`unset`，返回`word`字面值，`parameter`**值不变**；反之返回`parameter`的值。`word`如果为`${}`格式会展开。例如`${VAR1:-$VAR2}`和`${VAR1:-1000}`，如果`VAR1`为空或`unset`，那么分别返回`VAR2`的值和`1000` |
| `${parameter:=word}` | 如果`parameter`为空或`unset`，返回`word`字面值，**同时将变量**`parameter`**赋值为该值**；反之返回`parameter`的值 |
| `${parameter:+word}` | 如果`parameter`为空或`unset`，返回空；反之返回`word`字面值 |
| `${parameter:?word}` | 如果`parameter`为空或`unset`，将`word`字面值输出到标准错误，并会导致脚本退出。反之返回`parameter`的值 |
| `${parameter:offset}` `${parameter:offset:length}` | 取子字符串，不带`length`表示到结尾，下标从`0`开始。例如`${string:3:4}`表示从字符串`3`字符开始，取长度为`4`字符串并返回。在shell脚本中这在特殊变量`$@` `$*`中也有应用 |
| `${!prefix*}` `${!prefix@}` | 返回所有名称以`prefix`开头的变量，可以使用`for in`依次输出 |
| `${!name[@]}` `${!name[*]}` | 返回数组`name[]`的所有已赋值下标 |
| `${#parameter}` | 返回`parameter`字符串的长度 |
| `${parameter#pattern}` `${parameter##pattern}` | 将`pattern`和变量`parameter`匹配。如果`pattern`匹配上了`parameter`**前段**，那么返回删除该前段后的`parameter`。`#`为最短匹配，`##`为最长匹配。`pattern`不是正则表达式，和文件通配类似 |
| `${parameter%pattern}` `${parameter%%pattern}` | 将`pattern`和变量`parameter`匹配。如果`pattern`匹配上了`parameter`**后段**，那么返回删除该后段后的`parameter`。`%`为最短匹配，`%%`为最长匹配 |
| `${parameter/pattern/string}` `${parameter//pattern/string}` `${parameter/#pattern/string}` `${parameter/%pattern/string}` | 返回`parameter`，将`pattern`的最长匹配部分替换为`string`。第一种表示仅替换第一处，第二种表示替换所有，第三种表示仅从头匹配，第四种表示仅末尾匹配 |
| `${parameter^pattern}` `${parameter^^pattern}` `${parameter,pattern}` `${parameter,,pattern}` | 返回`parameter`，将`pattern`匹配的字符转大或小写。`^`将第一个字符转大写，`^^`全部大写；`,`将第一个字符转小写，`,,`全部小写 |
| `${parameter@U}` | 返回`parameter`，所有字符转大写 |
| `${parameter@u}` | 返回`parameter`，第一个字符转大写 |
| `${parameter@L}` | 返回`parameter`，所有字符转小写 |
| `${parameter@Q}` | 返回`parameter`，将字符串使用`''`括起来 |

### 2.1.2 全局变量

全局变量对一个shell的所有子进程可见，但是对其他进程（包括父进程）不可见

设置全局变量，必须在当前shell将一个局部变量使用`export`设定为全局变量（才能被子进程使用），**注意赋值表达式不能有空格**

```shell
MY_VAR="sample global"
export MY_VAR
export MY_VAR2="sample global"
```

全局变量只能使用`unset`在父进程删除

**环境变量**

环境变量属于全局变量。可以使用`env`查看当前环境变量，`printenv`也可以用于查看个别变量，也可以通过`echo`返回使用`$`引用的变量

`/etc/profile`以及`/etc/profile.d`中设定的是login shell的变量；在带有PAM的系统中，可以在`/etc/environment`中使用键值对或`/etc/security/pam_env.conf`中（ArchLinux中`~/.pam_environment`已经废弃）设定环境变量；bash启动时设定的变量可以在`/etc/bash.bashrc`以及`~/.bashrc`更改（建议只更改当前用户的，尽量不要更改`/etc`下的文件）。login shell会执行`profile`，新建的bash会执行`bashrc`

```shell
env
env EDITOR=vim xterm # 启动xterm时将EDITOR临时设定为vim，不会影响上层的EDITOR变量
printenv HOME
echo $HOME
```

如果只是想要更改当前用户的环境变量，建议更改`~/.bashrc`达到效果，如下示例

```shell
# ~/.bashrc

export PATH="${PATH}:/home/my_user/bin"
```

> `~/.bashrc`改完可以`source`一下生效

如果只是想要更改当前用户在启动图形界面时的环境变量，可以更改`~/xprofile`（大部分DM），`~/.xinitrc`（startx），`~/.xsession`（XDM）达到目的，如下示例

```shell
# ~/.xinitrc

export PATH="${PATH}:/home/my_user/bin"
```

常用环境变量：

| 名称 | 定义 |
| :-: | :-: |
| `SHELL` | 默认shell |
| `HOME` | 当前用户主目录 |
| `PATH` | shell用于查找命令的路径，追加方法：`PATH=$PATH:my_path`。有些发行版为`/etc/profile.d`中的脚本提供了`append_path`shell函数，示例`append_path '/opt/xxx/bin'` |
| `USER` | 当前用户 |
| `PS1` | 命令提示符格式 |
| `MANPATH` `INFOPATH` | Manual和Info路径 |

个人常用`PS1`显示配置

```shell
PS1='[\[\e[32;1m\]\u\[\e[0m\]@\[\e[32;1m\]\h \[\e[33;1m\]\A\[\e[0m\] \W]\[\e[31;1m\]\$\[\e[0m\] '
```

**bash相关变量（只可通过$引用）**

| 名称 | 定义 |
| :-: | :-: |
| `UID` | 当前用户ID |
| `BASH_SUBSHELL` | shell嵌套级别 |
| `BASHPID` | 当前bash的PID |
| `COLUMNS` | 当前终端可用宽度 |
| `HOSTNAME` | 当前主机名 |
| `HOSTTYPE` | 当前使用主机的CPU指令集 |
| `LINENO` | 当前执行的行号 |
| `OLDPWD` | 之前的目录 |
| `PPID` | 父进程PID |
| `PWD` | 当前目录 |
| `RANDOM` | 返回一个0~32767的随机数 |
| `SECONDS` | 启动shell到现在的秒数 |
| `MACHTYPE` | 平台类型，包括CPU指令集，操作系统内核等，例如`x86_64-pc-linux-gnu` |

### 2.1.3 结构变量

数组：本质是哈希表，定义时使用圆括号将多个值括起来。可以使用下标访问，修改或使用`unset`置空。下标可以为任意值，例如数字或单词等。但是注意不是所有shell都对数组支持良好

```
myarray=(one two three four)
echo ${myarray[0]}
echo ${myarray[*]}
myarray[final]="five"
```

### 2.1.4 shell脚本中的引号

**重点**

shell脚本中不同的引号`' '`以及`" "`具有不同的作用。**单引号不会对内含**`$var`**格式的变量进行展开，保留字面义**。而**双引号内含**`$var`**格式的变量会被展开转换为当前值**

示例

```shell
var='Hello world'
echo "$var" # 输出Hello world
echo '$var' # 输出$var
```

引号在一个变量含有空格时非常有用，尤其是在实际的文件处理中，很多文件路径都会带有空格，这时就不得不使用引号

## 2.2 Shell脚本基本构成

脚本使用`#!`指定shell程序，使用`#`将一行注释

```shell
#!/bin/bash
# This is a comment
```

假设要显示指定字符，使用echo命令即可，如果不想换行可以添加`-n`

```shell
echo This is a test
echo -n This is a test
echo "This is a 'test'"
```

## 2.3 使用一个命令的输出结果

可以使用`$()`将想要的命令括起来，并取其输出。可以将命令的输出赋值到一个变量

```shell
output=$(ls -a)
output=`ls -a`
```

一个实用的例子，就是自动命名文件

```shell
name=log-$(date +%m%d%H%M%S).txt
touch $name
```

## 2.4 重定向

### 2.4.1 输出重定向

将命令的输出重定向到一个文件

```shell
ls -a > ls.txt #新建或覆写
ls -a >> ls.txt #追加到文件尾
```

### 2.4.2 输入重定向

将文件重定向到一个命令的标准输入，比如用于统计字数的wc命令

```shell
wc < test.txt
```

内联重定向，可以指定输入的终止符，到达终止符后命令即停止并输出结果

```shell
wc << END
> string1
> string2
> END
```

其中，次提示符由`$PS2`指定，这里是`>`

## 2.5 管道

管道可以看作内存中的一个FIFO，将一个程序的标准输出连接到另一个程序的标准输入。

```shell
ls /bin | less #使用查看/bin下的文件
```

```shell
xz -dkc package.tar.xz | tar -xv #解压缩，和tar -Jxvf作用等价
```

## 2.6 整数、浮点以及字符串运算

### 2.6.1 传统的Bourne shell格式

使用`expr`，结果通过标准输出返回

```shell
expr arg operator arg

# 可用运算符
# 算数运算（返回运算结果）： + - * / %
# 逻辑运算（返回一个arg值）： & |
# 比较运算（返回整数0或1，分别代表否或是）： > >= < <= == !=
```

注意，所有在shell中有特殊含义的运算符，比如`*`，`/`，`&`，`|`，`>`，`<`都要加上转义符`\`才可正常工作

```shell
# 字符串运算

# 匹配正则表达式，返回匹配到的符合的字符串的字符数总和
expr STRING : REGEXP
expr match STRING REGEXP

# 子字符串，返回从START开始的LENGTH个字符，索引从1计数
expr substr STRING START LENGTH
# 例如 expr substr hello 1 4 返回hell

# 计算字符串长度
expr length STRING

# 查找一个CHARS第一次出现的位置
expr index STRING CHARS
# 例如 expr index hello l 返回3
```

### 2.6.2 bash支持的替代写法

使用`$[]`，**特殊符号不需要转义**

```shell
var=$[num operator num]

# 例如sample=$[($var1 + $var2) * $var3]
```

### 2.6.3 双括号

常用，`(())`用于算术以及逻辑运算， `[[]]`用于字符串比较，只有返回值，见if-then判断部分

### 2.6.4 浮点计算

以上方法仅适用于整数运算，浮点运算需要使用专用的工具，在类UNIX系统下常见的有`bc`

使用`bc`时必须对内建变量scale赋值，以指定小数点位数

使用命令替换，`echo`配合管道符

```shell
var=$(echo "scale = 2; var1 = 3; var2 = 7; var1 + var2 + 5.33" | bc)
```

使用内联输入重定向

```shell
var=$(bc << EOF
    scale = 2
    var1 = 3
    var2 = 7
    var1 + var2 + 5.33
    EOF
)
```

## 2.7 退出状态

可以使用变量`$?`查看上一个命令的退出状态

```shell
echo $?

# 常见状态码
# 成功 0
# 一般未知错误 1
# 不适合的shell命令 2
# 命令无法执行 126
# 命令未找到 127
# 已通过^C终止 130
# 正常退出码之外的状态码 255
```

也可以使用`exit`指定退出码

```shell
exit 5
```

## 2.8 判断

if-then结构，如果`if`之后的命令成功运行（注意是返回0，且只能是命令），则执行`then`之后的语句

```shell
if CMD
then 
    CMDs
elif CMD
then 
    CMDs
else
    CMDs
fi
```

或习惯写法

```shell
if CMD; then
    CMDs
elif CMD; then
    CMDs
else
    CMDs
fi
```

`if`之后的命令可以使用`test`以实现条件满足性的检测，比如一个变量是否为空

```shell
if test $var
then 
    CMDs
fi
```

以上用法不常用，一般还是使用方括号的格式替代`test`命令

```shell
if [ condition ]
then
    CMDs
fi
```

并且可以使用`&&`或`||`进行与或运算

```shell
if [ condition1 ] && [ condition2 ]
then 
    CMDs
fi
```

`test`语句可以`!`取反

```shell
if [ ! condition ]
then
    CMDs
fi
```

常用的除if-then以外，判断结构同样支持类似其他语言的`case`

```shell
case $var in 
    pattern1 | pattern2)
        CMDs;;
    pattern3)
        CMDs;;
    *)
        CMDs;;
esac
```

case只可以使用变量作为其判断依据，并且可以使用或运算`|`

### 2.8.1 整型数值

整型数值比较，shell不使用大于小于号

```shell
n1 -eq n2 # 相等
n1 -gt n2 # 大于
n1 -ge n2 # 大于等于
n1 -lt n2 # 小于
n1 -le n2 # 小于等于
n1 -ne n2 # 不等于
```

示例

```shell
if [ $var -eq 1 ]
then 
    var=$[$var + 1]
fi
```

### 2.8.2 字符串比较

注意大于小于号必须要在前面添加转义符。另外，字符串的比较是根据ASCII的顺序，大写字母被认为小于小写字母

```shell
str1 = str2     # 相等
str1 != str2    # 不相等
str1 \< str2    # 小于
str1 \> str2    # 大于
-n str1         # 长度非0
-z str1         # 长度0
```

示例

```shell
if [ $str1 \> $str2 ]
then 
    echo $str1
fi
```

### 2.8.3 文件处理

```shell
-e file             # 存在
-d file             # 存在并且是一个目录
-f file             # 存在并且是一个文件
-s file             # 存在并非空
-r file             # 存在并可读
-w file             # 存在并可写
-x file             # 存在并可执行
-O file             # 存在并属于当前用户
-G file             # 存在且属于当前用户默认组
file1 -nt file2     # file1比file2新
file1 -ot file2     # file1比file2旧
```

示例

```shell
if [ -f file.txt ]
then 
    rm -f file.txt
fi
```

### 2.8.4 双括号

格式：使用`(())`和`[[]]`

**双圆括号**`(())`语句一般用于特殊算术逻辑运算以及比较赋值，支持位运算。可以在`if`之后以及作为一般语句使用。可以替代`test`以及其等价`[]`，但它不是`test`

```shell
if (( $var1 == $var2 ** 2 ))
then 
    (( var1 = $var2 + 1 ))
fi
```

如上，双括号在一般语句中用于赋值，而在`if`之后用于比较，因为其所有的执行仅返回执行码。可以使用的算术符号如下，不需要转义

| 符号 | 类型 |
| :-: | :-: |
| `+ - * / % **` | 一般算术符（`**`求幂） |
| `! && \|\|` | 逻辑运算 |
| `~ & \| << >>` | 位运算 |
| `< > == != >= <=` | 比较 |
| `=` | 赋值 |
| `val++ val-- ++val --val` | 加一或减一 |

**双方括号**`[[]]`用于字符串比较，返回执行结果码（不是所有shell都良好支持）

```shell
if [[ $str == e* ]]
then 
    echo "yes"
fi
```

其中`e*`是一个pattern

> 说到这里，shell中这么多类型括号的使用非常令人迷惑。整理一下：
>
> `${}`将一个变量括起来，起展开变量的作用，常用于数组变量
>
> `$()`用于提取一个命令的执行结果输出，常用于赋值，可以使用` `` `替代
>
> `$[]`可以看成`expr`的等价，用于计算整数以及比较，通过标准输出返回结果
>
> `{}`用于一个命令区块，执行一串命令
>
> `()`用于命令列表，使用`;`分隔，也用于定义一个数组变量
>
> `[]`可以看成`test`的等价，用于处理整数、字符串以及文件相关，返回执行结果码
>
> `(())`用于整数运算、特殊运算、赋值以及比较，返回执行结果码，但是并不是`test`的等价
>
> `[[]]`用于字符串比较，返回执行结果码

## 2.9 迭代/遍历

一般使用`for`进行迭代。**由于需要对迭代变量进行赋值，这里的变量不添加引用符**`$`，这和`case`不同，不要将两者混淆。另外`for`的迭代变量在迭代后会一直保持有效

```shell
for var in list
do
    CMDs
done
```

示例

```shell
for i in GNU\'s NOT Unix 
do
    echo $i
done
```

```shell
string="GNU's NOT Unix"
for i in $string
do 
    echo $i
done
```

结果

```
GNU's
NOT
Unix
```

`for`还可以使用shell展开的通配符，用于遍历文件，这是`for in`的又一大常用应用

```shell
for i in /dir/*
do 
    file $i
done
```

> 注：在默认情况下，bash将空格，制表符，以及换行符作为字段分隔的依据，这样导致`for`遇到含空格的变量后就会出现问题。可以有两种问题解决，一个是使用`" "`，另一个是修改`$IFS`变量

示例

```shell
for i in GNU\'s "N O T" Unix
do 
    echo $i
done
```

或在bash下

```shell
IFS=$'\n' # 将换行符'\n'作为唯一字段分隔符
IFS=$'\n':; # 将'\n'以及冒号、分号作为字段标识符。使用冒号可以在读取例如/etc/passwd时发挥妙用
```

## 2.10 循环

### 2.10.1 C风格for

C风格的`for`的使用方法是特制的，并不符合传统shell中变量使用的常识，使用应当小心。虽然使用双括号，但是并不能使用双括号的原理去理解。

```shell
for (( i=1, j=15; i < 11; i++, j-- ))
do
    echo $i,$j
done
```

如上，C风格`for`支持**多于一个迭代变量**

### 2.10.2 while

`while`使用和if-then相同的`test`命令，根据执行返回的状态码判断是否继续循环

```shell
while CMD
do
    CMDs
done
```

如下，`while`之后可以跟多个测试命令

```shell
while echo $i
    [ $i -ge 1 ]
do
    echo "message"
    i=$i-1
done
```

### 2.10.3 until

`until`和`while`格式相同，区别在于`until`**只在当测试命令返回异常（非0）时才继续迭代，当测试命令返回0时才终止**（因为返回码无法取反）

```shell
until [ $i -gt 15 ]
do
    i=$i+1
done
```

### 2.10.4 break

`break`是一个语句，用法和C语言中的`break`同理，区别是可以通过`break n`指定要跳出的循环层级数

示例

```shell
while [ $i -ge 0 ]
do
    j=4

    while [ $j -ge 0 ]
    do
        if [ $i -eq 3 ]
        then 
            break 2
        else
            j=$j-1
        fi
    done

    i=$i-1
done
```

### 2.10.5 continue

`continue`同样和C语言中的`continue`同理，如果满足一定条件就会跳过之后的命令

示例

```shell
while [ $i -ge 0 ]
do
    if [ $i -eq 5 ]
    then
        i=$i-1 
        continue
    else
        i=$i-1
    fi
done
```

### 2.10.6 处理输出

可以将一个循环的输出统一处理，通过重定向或管道

示例

```shell
while [ $i -ge 0 ]
do
    echo "This is $i"
    i=$i-1
done > test.txt
```

管道同理

## 2.11 用户输入

### 2.11.1 命令行参数

shell使用`$#`获取输入的命令行参数数量，使用`$0`引用执行当前命令时的输入（比如`./test.sh`），使用`$1`引用第1个命令行参数，使用`$2`引用第2个命令行参数，以此类推。命令行参数默认使用空格作分隔，如果要传入带空格的参数就要使用引号

脚本的名称可以使用命令`basename $0`提取，通常用于创建两个名称不同而内容相同的脚本，用于功能区分

此外，**最后一个命令行参数可以使用**`${!#}`**提取**（花括号以内不可以使用`$`，只能使用`!`代替）

> 使用不符合要求的命令行参数会导致脚本出错。为提高程序健壮性，要养成对参数做有效性检查的习惯，比如使用`[ -n $1 ]`检查参数是否为空

### 2.11.2 遍历所有参数

遍历参数除了直接使用`$#`和`$1`等之外，还可以使用`$*`以及`$@`。两者都记录了所有参数，但是`$@`更加常用。`$@`将所有输入参数作为一个字符串中的单独单词，可以使用迭代`for`对其进行遍历访问。而`$*`则相反，将所有参数作为一个整体，需要使用特殊方式访问

示例

```shell
for i in "$@"
do 
    echo $i
done
```

使用`shift`指令遍历

`shift`可以将从`$1`开始的所有参数向左移动一格，这也是一种遍历的方法

可以加上一个数字，使用`shift n`指定移动次数

示例

```shell
while [ -n $1 ]
do 
    echo $1
    shift
done
```

### 2.11.3 选项与参数处理：getopt

用法

```shell
getopt <optstring> <option | parameter>
```

一般命令行参数可以使用`case`语句处理，可以将除所有选项以外的输入（参数）列入`*)`处理（比如返回提示"Invalid command"）

> 在Linux下，选项和参数之间一般使用`--`分隔

可以使用`getopt`，或它的高级版本`getopts`，对命令行输入进行标准格式化。由于一般的命令行参数可以连用选项，比如`-a -f`可以连写成为`-af`，这样使用传统的方法就很难判别了。`getopt`就是用于对输入参数进行规范化

在规定字符串中，如果一个选项`-b`之后需要带参数，可以其之后添加`:`，形式如`b:`

示例

```shell
getopt -q ab:cd -a -b param1 -cd param2 param3
set -- $(getopt -q ab:cd "$@")

# 选项
# -q 不输出
```

输出结果，其中选项`-b`参数为`param1`，后面`param2 param3`都是附加参数

```shell
-a -b 'param1' -c -d -- 'param2' 'param3'
```

`getopt`局限就在于不能恰当的处理带引号和空格的参数。

### 2.11.4 选项与参数处理：getopts

`getopts`可以对命令行参数输入依次进行处理，会使用到两个临时环境变量`$OPTARG`和`$OPTIND`，分别代表当前选项对应的参数值以及当前正在处理的参数位置（不包含命令，从2开始，每次递增1）

`getopts`在每次解析成功一个选项之后会有返回值，有选项返回0。在optstring之前添加`:`以禁止报错输出

> 经过测试，一个选项之后的参数是否为空只能使用`[ -z $OPTARG ]`判定，而不能使用`[ -n $OPTARG ]`判定。并且所有选项之前添加的`-`都会被去除

示例

```shell
while getopts :ab:c opt 
do 
    if [ -z opt ]
    then 
        echo "Option $OPTIND : No argument"
    else
        echo "Option $OPTIND : $OPTARG"
    fi
done
```

补充：Linux程序设计中约定俗成的参数定义

```shell
-a # 所有
-d # 后接指定目录
-f # 后接指定文件
-h # 显示帮助信息
-l # 长格式
-o # 指定输出文件
-q # 安静模式
-r # 递归处理目录
-v # 输出详细信息：verbose
-x # 排除一个对象
-y # 交互模式中，所有选项都回答yes
```

### 2.11.5 获取用户交互输入：read

使用方法

```shell
read opt1 opt2
read -p "Enter your option : " opt1 opt2
```

`read`通过标准输入读取输入字符串并将其赋值到指定变量，输入以空格为界。**如果变量数不够那么所有剩余变量都会被赋值给最后一个变量**。通过`-p`参数指定提示符

如果在`read`之后不指定变量，那么输入就会自动赋值给`$REPLY`

可以使用`-t`参数添加一个超时，超时后返回一个非零值

```shell
if read -t 5 opt
then
    echo $opt
else
    echo "No input"
fi
```

可以使用`-n1`指定输入一个参数以后就继续，无需回车

```shell
read -n1 opt
```

**从文件读取**

```shell
cat test.txt | while read line
do
    echo $line
done
```

## 2.12 输入输出以及重定向

在一个shell进程中，文件描述符为0~8的非负整数，是一个指针，指向实体文件或设备。其中0、1、2前3个描述符为保留，分别为`STDIN STDOUT STDERR`

**默认情况下STDERR和STDOUT使用的文件描述符不同，但通常这些文件描述符都指向同一个位置**

### 2.12.1 STDERR重定向

可以使用`n>`指定一个文件描述符对应的重定向文件，这样可以使用`2>`重定向标准错误到一个错误日志文件

```shell
ls badfile 2> error.log
```

想要重定向`STDOUT`和`STDERR`到两个文件，很简单，只要连用就可以了

```shell
ls -R /home 2> error.log 1> out.log
```

如果想重定向所有文件描述符到同一个文件，可以使用`&>`

**注意在bash中，标准错误的信息优先，会被重定向到标准输出行的上方**

```shell
ls -R /home &> all.log
```

而如果想要**将一个标准输出重定向到标准错误（注意不是输出到一个日志文件）**，也是可以实现的，使用`>&2`即可

```shell
echo "Redirect to STDERR" >&2
```

这样在`./test.sh 2> error.log`时该行命令输出也会被重定向到错误文件

### 2.12.2 永久重定向：文件描述符到文件

可以使用`exec n>`指定整个脚本运行中一个文件描述符对应的重定向文件

```shell
exec 1>output.log
exec 2>error.log
```

如果使用`exec n>>`，那么就会将重定向内容追加到文件末尾

```shell
exec 1>>output.log
```

同样，输入重定向也是使用类似方法。**这样在read试图从标准输入读取时可以从重定向文件读取，这在使用文件输入时很实用**

```shell
exec 0< input.txt
```

也可以将输入输出重定向指向同一个文件。

**这时要注意，shell会在内部维护一个指针，本次操作会在上一次操作结束位置之后开始操作，无论读写**

```shell
exec 3<> io.txt
```

### 2.12.3 永久重定向：文件描述符到文件描述符

文件描述符之间的重定向格式，将3重定向到1指向的对象（显示器），将4重定向到0指向的对象（键盘输入）

> 技巧：`>&`和`<&`的使用看起来可能比较难以理解。可以这样看：`3`和`1`都可以看作指针，当前`1`指向标准输出（即显示器），而`3>&1`相当于使`3`指向显示器。之后假设`1`被重定向到一个文件，`3`依然指向显示器不变。这在临时重定向保存指针时很有用

```shell
exec 3>&1
exec 4<&0
```

可以使用`-`代指空指针，用于置空一个文件描述符，关闭一个文件描述符

```shell
exec 3>&-
```

在关闭文件描述符以后，shell维护的文件指针会被销毁。如果再次打开同一个文件，操作会从头开始

### 2.12.4 lsof列出打开的文件描述符

使用`lsof`，显示指定用户或进程当前使用的文件描述符对应的文件名（可以是终端，普通文件等）

```shell
lsof -a -p PID -d n,n,n

# 命令行选项
# -a  求-p和-d过滤的交集
# -p  指定PID，使用$$引用当前shell的PID
# -d  指定文件描述符

# 显示信息
# COMMAND 命令名
# PID     当前进程PID
# FD      对应文件描述符以及读写模式。如1u代表文件描述符1使用读写模式，2w代表文件描述符2使用写模式
# TYPE    指向文件类型，CHR字符设备，BLK块设备，DIR目录，REG一般文件
# NAME    指向文件名
```

### 2.12.5 使用/dev/null丢弃命令的标准输出

Linux以及其他类Unix中有一个特殊的文件`/dev/null`，可以将输出重定向到这里销毁，也可以用于日志文件清除

```shell
echo "No output" > /dev/null
cat /dev/null > log.txt
```

## 2.13 临时文件以及目录

类Unix系统一般都可以在开机时清空`/tmp`，可以使用`mktemp`在`/tmp`创建临时文件或目录而不用担心日后的清理问题

```shell
mktemp

# 命令行选项
# -t  强制在/tmp下创建
# -d  创建目录而非文件
```

默认情况下，单独使用`mktemp`而不使用任何参数会在`/tmp`下创建一个类似`tmp.7RaVm6YsN3`的文件。也可以指定文件位置，甚至可以使用模板格式让`mktemp`自动命名文件。可以将`mktemp`返回的文件名赋值给一个变量，之后使用该文件

```shell
mktemp log.XXXXXX # 在当前目录创建文件，自动命名
```

## 2.14 使用tee分流输出到文件以及显示器

如果想要同时输出到一个文件以及标准输出（显示器），可以使用`tee`分流，相当于T型接头。`tee`将其获取的标准输入同时输出到显示器以及一个指定文件

```shell
echo "This is a log test" | tee log.txt
```

## 2.15 函数

同其他编程语言，shell也可以使用函数编程，也可以封装成库使用。当然shell不能面向对象

### 2.15.1 函数基本格式

定义一个函数格式如下，`()`是摆设。**注意，函数定义必须在函数调用之前，否则会出错**

shell脚本是一种面向过程的语言，**一个函数可以重复被定义，每次定义之后调用的都是最近定义的版本**

**shell的函数支持递归**

```shell
function funcname {
    CMDs
}

function funcname() {
    CMDs
}
```

### 2.15.2 函数：全局变量和局部变量

**shell的变量使用和C以及其他传统编程语言有较大差别，本节划重点**

**全局变量**

在shell中，使用默认方式创建的变量**都是全局变量**，无论这个变量是在函数内还是在函数外，都可以在脚本内任何地方访问

```shell
function func {
    var="You can use it anywhere"
}

echo $var
```

**局部变量**

函数内局部变量的申明需要加上`local`关键字

```shell
function func {
    local var="You can't use it outside the function"
}
```

### 2.15.3 函数执行返回值

shell将每一个函数当作一个小型脚本看待，默认情况下，函数的执行返回值为最后一个命令的返回值，使用`$?`引用

和C语言一样，shell也可以使用`return`语句指定最终执行返回值`0~255`

另外注意，如果想要取一个函数的返回值，就不能在函数结束之后执行任何语句，否则会刷掉之前的`$?`

```shell
function func {
    if [ -f test.txt ]
    then
        return 0
    else
        return 1
    fi
}
```

### 2.15.4 函数结果返回值

在函数最后使用`echo`通过标准输出返回函数结果。如果要输出到标准输出，比如`read`可以使用`read -p "Input" var`以输出提示信息到标准输出，因为bash只认使用`echo`返回的值。这同时也要注意不能滥用`echo`，否则会导致返回结果的异常

```shell
function func {
    echo "This is the result"
}

var=$(func)
```

### 2.15.5 函数参数

正是由于shell将函数当作子脚本看待，所以函数也可以使用命令行的参数传递方法，也可以在函数内使用`$#`引用参数数量，使用`$1`引用参数等。这里引用的变量不是传给脚本的变量

示例

```shell
function func {
    if [ $# -eq 1 ]
    then 
        echo $1
    else
        echo -1
    fi
}

func 9 # 调用函数，返回值
var=$(func 12)
```

### 2.15.6 数组参数以及结果

在函数中使用数组不是很容易。

**数组作为输入参数的使用**

如果在函数中直接通过`$@`和`$1`使用数组变量，只能引用到第一个变量，以下为反例

```shell
function func {
    for var in $@ # 试图通过$@引用数组所有变量，失败，只引用到第一个变量
    do 
        echo $var
    done

    out=$1 # 试图通过$1引用数组并赋值给一个变量，失败，只引用到第一个变量

    echo "${out[*]}"
}
```

正确的方法是使用一定方法将数组拆分，再`echo`所有数值，添加括号赋值给一个数组变量

示例

```shell
function func {
    local newarray
    newarray=($(echo $@)) # 参数不能有空格，最外层括号相当于给echo的返回结果加上一层括号，为数组赋值方式
    echo ${newarray[*]}
}

array=(1 2 3 4 5)
func ${array[*]} # 注意一定要使用数组的通配遍历方法将数组传递给函数
```

**数组作为输出结果的使用**

想要返回一个数组也是同理

示例

```shell
function func {
    local array=(1 2 3 4 5)
    echo ${array[*]}
}

output=($(func))
echo ${output[*]}
```

技巧：在shell中使用数组变量，主要就是**使用通配遍历拆分数组**以及**赋值时括号的添加**

### 2.15.7 使用库

使用常规方法直接在脚本之下运行库文件是没有用的，因为**运行时函数被定义在了子shell之下，无法在当前shell使用**

想要使用库需要使用`source`使其在当前脚本所在shell运行

```shell
source ./lib.sh
```

或`source`的缩写`.`

```shell
. ./lib.sh
```

## 2.16 脚本作业控制

包含了脚本中信号的使用，后台运行，以及优先级调整

**预备知识：Linux中进程的几种状态以及操控信号**

之前在系统管理章节讲到`ps`命令时已经了解过了Linux下的几种状态，这里再使用表格形式展示一遍

| 状态 | 名称 | 描述 |
| :-: | :-: | :-: |
| R | Running           | 进程正在运行或可执行（Ready），教科书一般将这两种状态分开，Linux下算作一种状态 |
| D | Uninterruptible   | 不可中断睡眠，不会处理任何信号，不能使用kill -9终结，常见于不可中断的重要进程，比如传输 |
| S | Interruptible     | 可中断睡眠，一般由于进程等待某事件发生，收到信号后即恢复运行 |
| T | Stopped/Traced    | 停止态或跟踪态，停止态进程依旧停留在内存并且可以从断点处继续执行，跟踪态常见于使用gdb等调试断点时 |
| X | Exit-Dead         | 退出态，进程即将销毁，一般捕捉不到 |
| Z | Exit-Zombie       | 退出态，僵尸进程，一般是进程退出后PCB还驻留在内存，可能是等待父进程来读取信息 |

这里再引用一张图表示Linux下进程的调度过程

![进程状态转换图](images/201219a001.png)

Linux下操控进程常用的信号（使用`kill`或`killall`加对应序号）

| 值 | 名称 | 描述 |
| :-: | :-: | :-: |
| 1     | SIGHUP    | 挂起，用于通知进程其控制终端已关闭，行为可由软件开发者定义，默认行为终止 |
| 2     | SIGINT    | 普通中断信号，行为可由开发者定义，默认行为终止 |
| 3     | SIGQUIT   | 退出，默认行为终止并生成core dump |
| 9     | SIGKILL   | 无条件终止，行为不可由开发者定义，无处理过程 |
| 15    | SIGTERM   | 尽可能终止，行为可以由开发者定义，有处理过程 |
| 17    | SIGSTOP   | 无条件停止，行为不可由开发者定义，无处理过程 |
| 18    | SIGTSTP   | 尽可能停止，行为可以由开发者定义，有处理过程 |
| 19    | SIGCONT   | 停止后继续运行 |

可以通过`jobs`查看当前已暂停或正在运行的脚本，带`+`的是当前默认控制的进程，带`-`的是下一个

```shell
jobs

# 命令行选项
# -l  显示PID和作业号
# -p  仅显示PID
# -r  仅运行中
# -s  仅已停止
# -n  仅改变过状态
```

### 2.16.1 使用以及捕获信号

除`SIGKILL`以及`SIGSTOP`强制退出或停止进程以外，向进程发送信号后的反应**要看程序对各种信号的具体处理行为方式**。一般日常开发的可执行程序**其实都已经定义了应对各种标准信号的默认行为**，可以在自己设计的程序中定义行为

可以在一个命令或脚本运行时通过`kill`或快捷键向进程发送信号

```shell
kill -9 2401 # 无条件终止PID=2401的进程
```

**Ctrl+C:** 发送`SIGINT`

**Ctrl+Z:** 发送`SIGTSTP`

可以在脚本中使用`trap`命令重定义接收到信号的行为，基本格式如下：

```shell
trap CMDs signals
```

示例

```shell
trap "echo 'Interrupted'" SIGINT
trap "echo 'Another interrupt'" SIGINT # 可以重定义行为
trap -- SIGINT # 移除行为
```

在一个shell脚本执行结束时shell进程会给自身发送一个特殊的`EXIT`信号，也可以捕获并在退出时执行语句

```shell
trap "echo 'Exit...'" EXIT
```

### 2.16.2 后台运行

之前已经讲过了后台运行的方法，后台运行的`STDOUT`和`STDERR`依然会在当前终端输出

```shell
./script.sh &
./script.sh > out.txt & # 重定向输出
```

这里补充可以使脚本在终端退出以后依然可以运行的方法

可以使用`nohup`使脚本不受关闭终端的影响，其实相当于是阻断了所有发送到该进程的`SIGHUP`信号，注意此时进程的输出会被重定向到`nohup.out`文件

```shell
nohup ./script.sh &
```

另外，可以使用`bg`继续已停止的后台作业

```shell
bg 3 # 作业号由jobs获得
```

反之，在前台重启，使用`fg`

```shell
fg 3
```

### 2.16.3 优先级以及谦让度

在Linux中，优先级使用`-20`到`19`表示，**数字越大优先级越低（相当于nice级别）**，Linux中默认启动优先级为0

可以使用`nice`或`renice`调节优先级

```shell
nice -n 10 ./script.sh # 启动时指定优先级，普通用户只能指定更低的优先级（不小于0）
```

`renice`用于调节一个正在运行进程的优先级

```shell
renice -n 10 -p 5537 # 调节PID=5537优先级到10，普通用户只能指定更低的优先级
```

### 2.16.4 设置预约运行

`at`用于指定作业运行时间，为POSIX命令，在类Unix系统一般都可以使用

`at`对应后台daemon`atd`会在每分钟检查`/var/spool/at`以确定是否有已提交的作业要运行。**作业被提交到作业队列中，一共26个队列（a-z），a优先级最低**

```shell
at -f ./script.sh -q a TIME

# TIME格式
# 23:59   时分表示
# 3:15 PM 使用AM/PM指示符
# now     立即执行
```

`at`通过email应用发送脚本输出，需要在脚本中重定向，可以使用`-M`屏蔽输出

可以使用`atq`显示当前正在等待的命令


### 2.16.5 设置定时任务

使用`cron`定时运行任务

**Linux**

在Archlinux常用的cron有`cronie`和`fcron`。只能使用两者其一，以`cronie`为例

```shell
# cronie依赖于opensmtpd的sendmail命令发送email。cronie包含了anacron
sudo pacman -Ss cronie opensmtpd
```

> 安装完成后，`ls /etc`可以发现多出了`cron.d cron.deny cron.hourly cron.daily cron.weekly cron.monthly anacrontab`等配置相关目录以及文件。其中`cron.hourly`下有一个定时任务`0anacron`，`anacron`支持异步执行定时任务（解决任务由于关机而未得到执行的问题）
>
> SMTP配置文件位于`/etc/smtpd/smtpd.conf`无需更改。默认使用maildir而非mbox。通过以下命令可以测试SMTP是否可用

```shell
sudo systemctl start smtpd
echo "Mail test" | sendmail username # username为当前主机中的用户名
sudo systemctl enable smtpd # 可以使能smtpd开机自启
```

> 执行完以上命令就可以在`/home/username/Maildir`中找到发送的邮件
>
> crontab的文件格式一般为6列，依次为`minute hour day_of_month month day_of_week command`。其中除`command`以外所有参数都为数字表示，使用`*`作为通配符表示所有数字，使用`,`分隔多组数字，使用`-`表示一个数字范围，使用`/`表示执行的频率
>
> 示例`*/5 0-1,12-13 * 4-6 1-5 myscript.sh`，表示在每年的4至6月的工作日的00:00至01:55，12:00至13:55每隔5分钟执行一次脚本。`command`之前的参数也可以部分省略，例如`minute hour command`的形式
>
> 此外还可以使用`@reboot @yearly @monthly @weekly @daily @hourly`等关键词进行定时任务

crontab不能使用编辑器手动编辑，应当使用`crontab`编辑（使用`crontab -l`列出当前用户的crontab，`crontab -r`删除当前用户的crontab）

```shell
export EDITOR=vim # 可以指定编辑器
crontab -u username -e # 使用-u可以指定用户
```

anacron在每个小时都会被cronie调用（`/etc/cron.hourly/0anacron`）来检查并执行cronie未在指定时间执行的任务，只能使用编辑器编辑`/etc/anacrontab`，执行频次控制到天，其默认内容一般如下（该默认配置下，需要将用户的定时脚本放置在`/etc/cron.daily`等文件夹下）

```
# environment variables
SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=username
RANDOM_DELAY=30
# Anacron jobs will start between 6am and 8am.
START_HOURS_RANGE=6-8
# delay will be 5 minutes + RANDOM_DELAY for cron.daily
1		5	cron.daily		nice run-parts /etc/cron.daily
7		0	cron.weekly		nice run-parts /etc/cron.weekly
@monthly	0	cron.monthly		nice run-parts /etc/cron.monthly
```

> `RANDOM_DELAY`用于指定任务执行前的随机延时，可以设置为`0`（立即执行）到`30`（随机时间最大30）。`START_HOURS_RANGE`用于指定可执行的时间区间（0-23小时制），超出区间任务就不会执行（即便任务已经错过）
>
> 之后每一行都是任务的描述信息。第1列表示任务执行的频次（指任务距上次执行过了多少天，如果超过那么就会执行该任务）。第2列为任务执行前的固定延时，anacron如果已经确定该任务需要执行，那么执行之前需要加上**固定延时+随机延时**。第3列为任务名，将会用于日志中。最后一列为命令，如上例`nice run-parts /etc/cron.daily`
>
> 使用`anacron -f`可以强制触发一次所有已有描述记录的任务，`anacron -n`可以忽略延时直接执行需要执行的任务

**FreeBSD**

FreeBSD中同样使用`crontab`命令进行用户定时任务的编辑，格式同上。此外还有一个系统crontab位于`/etc/crontab`（建议不要编辑）。该crontab有7列，其中新增的第6列为执行定时任务时使用的用户身份


### 2.16.6 FTP和Samba命令行客户端

以`samba`客户端`smbclient`为例，命令基本类似

```shell
# smbclient命令行连接方法
smbclient //NetBIOSName/ShareName -U UserName%Passwd

# localhost
smbclient //localhost/ShareName -U UserName%Passwd
```

> 小技巧：NetBIOS
>
> NetBIOS和Samba一样同属MS的产物，其作用非常类似于DNS，通常用于局域网。一台主机在配置NetBIOS名称以后，在Windows下使用`ping` `ssh`等命令时就不必知晓该主机的局域网IP，直接使用其NetBIOS主机名就可以访问，非常好用，尤其在主机IP会变化的情况下
>
> 可以在`samba`的配置文件`/etc/samba/smb.conf`中配置NetBIOS名称，在`[global]`添加一行`netbios name = hostname`
>
> ArchLinux下使用`systemctl start nmb`即可启动NetBIOS服务

> ArchLinux下可以安装`gvfs-smb`来为文件管理器提供Samba访问支持

连接到服务器后会有提示符，通常会使用到的有如下命令

| 基本命令 | 解释 |
| :-: | :-: |
| `?` `help` | 显示可用指令 |
| `q` `quit` `exit` | 断开连接退出客户端 |
| `ls` `dir` | 列出服务器当前目录下的所有文件，或仅显示指定目录与文件 |
| `cd` | 进入到指定服务器目录 |
| `lcd` | 进入到指定`smbclient`本地工作目录。文件传输默认在该本地目录进行 |
| `rename` | 重命名文件 |
| `md` `mkdir` | 创建目录 |
| `rd` `rmdir` | 删除指定目录 |
| `rm` `del` | 删除指定文件 |
| `deltree` | 删除指定文件和目录 |
| `du` | 显示已用空间 |

| 文件传输命令 | 解释 |
| :-: | :-: |
| `put localfile remotefile` | 将本地文件传输到服务器端 |
| `get remotefile localfile` | 将服务器端文件下载到本地 |
| `mask` | 如果`recurse ON`那么用于过滤`mput`和`mget`操作的目录 |
| `mput` | 存放多个文件。如果`recurse ON`那么会遍历所有目录并复制目录和文件到服务器 |
| `mget` | 获取多个文件。如果`recurse ON`那么会遍历所有目录并复制目录和文件到本地 |
| `recurse ON` `recurse OFF` | 是否遍历。如果`ON`那么所有操作（包括`ls`等）将会遍历当前目录下的所有目录，如果`OFF`那么操作将会局限于当前目录，不会遍历当前目录下除文件以外的目录 |
| `prompt ON` `prompt OFF` | `prompt OFF`关闭所有询问，如`mput mget`操作时默认每个文件的操作都会询问，建议`OFF` |
| `lowercase ON` `lowercase OFF` | `lowercase ON`下载文件时将所有文件转为小写 |
| `more` | 和Linux下的`more`作用相同，调用本地分页查看器查看文件 |

用法示例

```
# 在目录photo/下载day20/到day29/中的.jpg文件到本地/home/username/Desktop
lcd /home/username/Desktop
cd photo
recurse ON
prompt OFF
mask day2*
mget *.jpg
```


## 3 shell脚本进阶

## 3.1 Awk编程

`awk`是一种专门用于处理文本、提取信息的语言，适用于较为规律的文本，如日志等。这里所有的笔记目录都是使用`awk`脚本生成

`awk`的工作流程非常简单，只需要熟练掌握正则表达式即可，本章只涵盖标准`awk`用法，不涉及`gawk`的扩展内容。命令行使用方法`awk -f awkscript.awk test.txt`。可以使用`-P`或`--posix`强制POSIX兼容，禁用`gawk`的GNU扩展

一个典型的awk脚本结构如下

```awk
#!/bin/awk -f

# 每次起始会执行的命令
BEGIN {
    commands
}

# 针对文件中每一行都会执行的正则匹配。只要匹配成功，命令就会执行
/pattern1/ {
    commands
}

# 可以使用逻辑运算符
/pattern2/ || /pattern3/ {
    commands
}

# 可以将正则表达式省略，对于文件中的每一行，命令都会执行一遍
{
    commands
}

# 也可以将命令省略，匹配成功默认就会print当前行
/pattern3/

# 匹配条件也可以是判断语句
$1 == "string" {
    commands
}

# 遇到文件结束符EOF后执行的命令
END {
    commands
}
```

> 上述代码中，每一个`pattern command`组合都称为一个**规则**`rule`。`rule`不可嵌套，而`rule`中`command`的子语句可以使用`{}`嵌套


### 3.1.1 打印

`awk`使用`print`或`printf`进行字符的打印

```awk
/pattern/ {
    # print会自动换行，后面可以接多个参数，可以是字符串，常量，变量等
    print "Hello", 4
    # print命令不接任何参数，直接打印当前行
    print
    # printf不会自动换行，需要添加'\n'
    printf "Current line: %s\n", $0
}
```

> `print "Hello" 4`和`print "Hello", 4`是不同的。前者隐含了一个字符串连接操作，`Hello`和数字`4`会直接连接在一起，中间没有空格变成一个字符串。而后者实际是向`print`传入了两个参数`Hello`和`4`，`print`会依次打印出这两个参数，中间使用空格间隔
>
> 另外，将字符串连接起来时建议使用`()`括号，`print ("Hello" 4)`


### 3.1.2 变量

**字段**

`awk`使用`$n`的形式引用每一行的各个字段。其中`$0`表示当前字符行，`$1`表示第1个字段（例如字符串`Apple Peach Grape`，那么`$0`就是`Apple Peach Grape`，`$1`就是`Apple`），依次类推

```awk
/pattern/ {
    # 打印当前行
    print $0
    # 打印当前行的第1个字段
    print $1
    # 可以使用变量
    i = 3
    print $i
}
```

**特殊变量**

| 变量名 | 作用 |
| :-: | :-: |
| `FS` | 该特殊变量定义了输入字段的分隔符，默认情况下为` `空格。有需要可以改为`:`等其他字符，例如日期`2022/05/21`，如果设定`FS="/"`，那么`$1`就是`2022` |
| `RS` | 输入行之间的分隔符，默认是换行符 |
| `OFS` | 输出行字段的分隔符，默认是` `空格 |
| `ORS` | 输出行之间的分隔符，默认是换行符 |
| `NF` | 当前行的字段数量 |
| `NR` | 当前累计行号（多文件会累加），处理到第几行 |
| `FNR` | 当前文件中行号，处理到当前文件的第几行 |
| `ARGC ARGV` | 分别表示命令行传入的参数数量以及。一般`ARGC[0]`为`awk`，`ARGV`为传入的额外参数数量（包含`awk`在内） |
| `CONVFMT` | 数字的转换格式，默认`%.6g` |
| `OFMT` | 输出格式，默认`%.6g` |
| `ENVIRON` | 获取shell环境变量，例如`ENVIRON["PATH"]` |
| `FILENAME` | 当前处理的文件名，在`BEGIN`中不可用 |
| `SUBSEP` | 多维数组下标分隔符，默认`\034` |
| `RLENGTH RSTART` | `match()`函数专用变量，前者表示`match()`函数匹配到的字符串的长度，后者表示匹配到字符串在总字符串中的起始位置 |

**自定义变量**

可以在`command`中定义并使用变量

```awk
BEGIN {
    var_num = 12
    var_str = "Hellion"
}
```

将变量设为`untyped`

```awk
var_null = ""
```

**数组**

`awk`中的数组类似于哈希表，实际上使用键值对方式存储，可以使用数字以外的常量作为下标，如字符串。数组中的变量也可以是不同类型的

```awk
array["Fruit"] = "Apple"
array[2] = 133
```

> 在一个数组中引用未定义的下标会得到一个空变量`""`。可以使用`delete`删除一个数组元素

```awk
delete array[12]
```


### 3.1.3 算术逻辑

**算术运算**

| 符号 | 作用 |
| :-: | :-: |
| `+ - * / += -= *= /=` | 四则运算，相反数 |
| `% %=` | 求余 |
| `++ --` | 递增、减 |
| `^ ^= ** **=` | 指数 |

示例

```awk
{
    a = 13
    a -= 11
    print a**2
}
```

| 符号 | 作用 |
| :-: | :-: |
| `== >= <= > < !=` | 比较大小 |

示例

```awk
{
    if (a > b)
        print "a is greater than b"
    if (var_str == "Hello")
        print "Hello"
}
```

**逻辑运算**

| 符号 | 作用 |
| :-: | :-: |
| `&& \|\| !` | 与或非 |
| `?:` | 三元运算符 |

> `awk`中的`true`和`false`和C语言是一样的

**正则匹配**

| 符号 | 作用 |
| :-: | :-: |
| `~ !~` | 正则匹配后返回true或false |

```awk
{
    if ($0 ~ /pattern/)
        print "Hello"
    # 也可以使用以下格式，和上述代码作用等效
    if (/pattern/)
        print "Hello"
}
```

**字符串连接**

| 符号 | 作用 |
| :-: | :-: |
| ` ` | 连接两个字符串变量（你没看错，就是一个空格。**也是因此函数名和参数列表的左括号之间不能留有空格**） |

**数组下标检测**

```awk
{
    if (2 in array) {
        print array[2]
    }
}
```

### 3.1.4 正则表达式

`awk`中的正则表达式需要使用`/ /`括起来

**运算符**

| 符号 | 含义 | 示例 |
| :-: | :-: | :-: |
| `^` | 字符串必须以`^`后的字符开头 | `/^The/`匹配`These The There`等 |
| `$` | 字符串必须以`$`前的字符结尾 | `/act$/`匹配`act fact`等 |
| `.` | 1个任意字符 | `/t.ck/`匹配`tack tick tock attack`等 |
| `*` | 匹配`*`之前的字符0次或多次 | `/te*/`匹配`t te tee teeth act`等 |
| `+` | 匹配`+`之前的字符至少1次 | `/te+/`匹配`te tee teeth ate`等 |
| `?` | 匹配`?`之前的字符0次或1次 | `/thr?ough/`匹配`though through`等 |
| `{n} {n,} {n,m}` | 分别表示重复`{n}`前的字符`n`次，重复`{n,}`前的字符至少`n`次，重复`{n,m}`前的字符`n`到`m`次 | `/[a-z]{2,7}/`匹配任意长度为2到7的小写字母段 |
| `[SET]` | 匹配到集合中的任意一个字符 | 见下 |
| `[^SET]` | 字符不在集合中 | 见下 |
| `\|` | 或，优先级最低的运算符 | `/[A-Z]{2,3}\|[a-z]{2,3}/`匹配长度为`2`或`3`的大写或小写字母串 |
| `()` | 略。一般用于改变优先级 | `^S(layer\|axon)`匹配`Slayer`以及`Saxon`等 |

> `[SET]`和`[^SET]`中可以放置以下格式的字符集合

| 格式/示例 | 解释 |
| :-: | :-: |
| `[abdegACETG037]` | 其中任意一个字符 |
| `[a-z]` | ASCII中`a`到`z`之间所有字符 |
| `[A-F]` | ASCII中`A`到`F`之间所有字符 |
| `[0-7]` | ASCII中`0`到`7`之间所有字符 |
| `[A-Za-z]` | ASCII中所有字母 |
| `[A-Za-z0-9]` | ASCII中所有字母和数字 |
| `[[.ch.]]` | 组合字符`ch` |
| `[[:alpha:]]` | 所有字母 |
| `[[:lower:]]` | 所有小写字母 |
| `[[:upper:]]` | 所有大写字母 |
| `[[:digit:]]` | 所有数字 |
| `[[:alnum:]]` | 所有字母和数字 |
| `[[:punct:]]` | 所有标点符号 |
| `[[:graph:]]` | 所有可见字符（数字，字母，标点符号） |
| `[[:blank:]]` | 空格和制表符 |
| `[[:space:]]` | 空格，横、纵制表符，换行符，回车符和分页符 |
| `[[:cntrl:]]` | 控制字符 |
| `[[:print:]]` | 除控制字符以外的字符 |
| `[[:xdigit:]]` | 十六进制字符，相当于`[a-fA-F0-9]` |
| `[\x00-\x7F]` | 所有ASCII字符 |


**特殊字符转义**

除以上正则表达式符号以外，以下字符也需要使用`\`进行转义

| 原字符 | 转义后写法 |
| :-: | :-: |
| `\` | `\\` |
| `/` | `\/` |
| `"` | `\"` |
| `ASCII 0x08, BS, Backspace` | `\b` |
| `ASCII 0x07, BEL, Alert` | `\a` |
| `ASCII 0x0A, LF, Linefeed(Newline)` | `\n` |
| `ASCII 0x0D, CR, Carriage return` | `\r` |
| `ASCII 0x0C, FF, Formfeed` | `\f` |
| `ASCII 0x09, HT, Horizonal TAB` | `\t` |
| `ASCII 0x0B, VT, Vertical TAB` | `\v` |
| 8进制，16进制表示法 | 示例`\033`，`\x1B` |


### 3.1.5 程序流控制

`if-else`

```awk
{
    if (condition) {
        commands
    }

    else if (condition) {
        commands
    }

    else {
        commands
    }
}
```

`while`

`while do-while for`语句中都可以使用`break`和`continue`

```awk
{
    while (condition) {
        commands
    }
}
```

`do-while`

```awk
{
    do {
        commands
    } while (condition)
}
```

`for`

```awk
{
    for (initialization; condition; increment) {
        commands
    }

    # 注意，以下的i是下标而非迭代变量，需要使用array[i]引用实际的变量
    for (i in array) {
        commands
    }
}
```

`for`示例

```awk
{
    for (i = 1; i < 4; i++) {
        print $i
    }

    for (j in array) {
        print array[j]
    }
}
```

`switch`

和C语言用法基本一致，不同的是这里`case`不限于单字符或变量，可以为字符串、正则表达式

```awk
{
    switch (var) {
        case "case1":
            commands
            break
        case "case2":
            commands
            break
        case /pattern/:
            commands
            break
        default:
            commands
    }
}
```

`next`

```awk
{
    # 直接跳转到下一行字符
    if (condition)
        next
}
```

`nextfile`

```awk
{
    # 跳转到命令行指定的下一个文件
    if (condition) {
        nextfile
    }
}
```

`exit`

```awk
{
    # 返回码
    exit 0
}
```


### 3.1.6 函数

> `awk`的函数使用方法比较违反常识。使用函数需要格外小心，有些情况下也应该尽量减少函数的使用

用户可以在`awk`脚本中的任意位置使用`function`关键字定义自己的函数，格式如下

```awk
# 没有参数和返回值
function funca() {
    commands
}

# 传入参数，形参可以是数组
function funcb(arg1) {
    commands
}

# 有返回值
function funcc(arg1, arg2, arg3) {
    commands
    return var
}
```

历史原因，`awk`中变量的作用域与常规的编程语言不同，概念当然也不同

> `awk`的代码规范要求**函数形参不能和调用函数时已有的变量同名，函数形参和实参当然也不能同名**（只有形参形式声明的局部变量可以和函数外已有变量同名）
>
> 函数中操作的变量，如果**没有在函数定义中形参列表中出现**，那么它就是**全局变量**。执行该函数前如果该变量已经存在，那么在函数中无论读取该变量还是赋值该变量，操作的都是这个已定义的全局变量本身；反过来如果该变量之前不存在，该函数执行过后这个全局变量实体不会销毁依然可用，可以在rule中或父函数或其他函数中访问

```awk
function funca() {
    var_a = 11
    print var_a
    func_b()
    print var_a
}

function funcb() {
    print var_a
    var_a = 21
}
```

> 以上代码中，调用`funca`会发现`funcb`输出的也是`11`，调用`funcb`结束返回到`funca`会输出`21`

`awk`函数中只有形参作用域是局部，只能通过函数形参列表来变相声明局部变量（这是一种非常糟糕但又巧妙的方式，相当于局部变量所属形参未传入值），如下

```awk
function funca(param_a, param_b,     var_local) {
    var_local = 11
    print var_local
    param_a = 14
    print param_a, param_b 
}

BEGIN {
    var_local = 21
    var_a = 81
    var_b = 91
    funca(var_a, var_b)
    print var_local
}
```

> `awk`的代码规范建议`funca`中在形参`var_local`之前添加几个空格表示这个形参作为局部变量使用，不加空格上述代码含义不变（但是不建议这样做）。在调用`funca`函数时，实际只会用到`param_a param_b`两个形参，剩余未使用的形参`var_local`用作局部变量
>
> 运行以上代码，`funca`中输出`var_local`的值为`11`，`param_a`为`81`，`param_b`为`91`；而在`BEGIN`块中最终将会输出`var_local`为`21`
>
> 以上有两个值得关注的点，这也是`awk`函数使用的关键注意点。其一是`funca`中形参`param_a`的值**无法在函数内改变**（因为是传值方式）；其二是`BEGIN`中的`var_local`和`funca`中的`var_local`不是同一个，两者互不影响，作为局部变量使用的形参在这里起到作用，两者不冲突

> 此外，`awk`函数还支持数组作为参数，可以向数组形参传入数组实参。**和普通的形参不同，数组传参依靠引用而不是传值**。所以在函数体内任何对于数组的更改在函数退出后都会反映到实际的数组上

**小结**

> 最终，`awk`函数中的变量可以分为4种：
>
> **全局变量**，没有在函数形参列表中出现的变量
>
> **用作局部变量的形参**，可以和函数外已有变量重名，只在函数内有效，函数体内可读可写
>
> **普通形参**，不能和已有变量重名，只在函数内有效，函数体内只可读，写无效
>
> **数组形参**，不能和已有变量重名，传入实参数组的引用，函数体内可读可写（就是对传入实参数组的读写）


### 3.1.7 内置函数

**数学函数**

功能较为单一

| 名称 | 解释 |
| :-: | :-: |
| `atan2(y, x)` | 求`y/x`的反正切，单位`rad`，下同。使用`atan2(0, -1)`计算`pi` |
| `sin(x)` | 求`x`的正弦 |
| `cos(x)` | 求`x`的余弦 |
| `sqrt(x)` | 求根号`x` |
| `exp(x)` | 求`e^x` |
| `int(x)` | `x`取整数 |
| `log(x)` | 求`ln(x)` |
| `rand()` | `0`到`1`之间的随机数 |
| `srand() srand(x)` | 随机整数，可选的`x`作为随机数种子 |

**位操作函数**

| 名称 | 解释 |
| :-: | :-: |
| `and(x1, x2, x3)` | 位与 |
| `compl(x)` | 求补 |
| `lshift(x, cnt)` | 左移`cnt`位 |
| `rshift(x, cnt)` | 右移`cnt`位 |
| `or(x1, x2, x3)` | 位或 |
| `xor(x1, x2, x3)` | 位异或 |

**数据类型**

| 名称 | 解释 |
| :-: | :-: |
| `isarray(x)` | 是否为数组 |
| `typeof(x)` | `x`的类型，返回类型名字符串，可能是`array regexp number string strnum unassigned untyped` |

**字符串处理函数**

| 名称 | 解释 |
| :-: | :-: |
| `asort(arr)` `asort(arrsrc, arrdest)` | 字符串**列表排序**，`arr`中每一个元素都是一个字符串。默认按字母顺序排序，`arr`被排序以后内容改变，且原有下标不可用，需要使用`arr[1]`数字下标访问。如不想改变原有`arr`那么可以使用第二种格式，其中`arrsrc`会被复制到`arrdest`中再排序 |
| `asorti(arr)` `asorti(arrsrc, arrdest)` | 字符串**列表下标排序**，排序的是`arr`数组的下标名而不是数组本身。使用`arr[1]`数字下标访问排序后的下标名 |
| `gensub(regexp, replace, "g", str)` `gensub(regexp, replace, 1, str)` | 字符串**替换**，将字符串`str`中符合`regexp`的片段替换为`replace`。`"g"`表示所有出现的地方都替换，`1`表示仅替换首次出现的地方。返回值就是替换好的字符串。此外还可以改变匹配字符串的顺序，在正则表达式使用`()`，在替换字符串使用`\\1`，例如`gensub(/(pattern1) gap (pattern2)/, "\\2 \\1", "g", str)`，如果`str = "pattern1 gap pattern2"`那么返回结果为`pattern2 gap pattern1` |
| `gsub(regexp, replace, str)` | 字符串**替换**，简配版`gensub()`，将`str`中所有符合`regexp`的替换为`replace` |
| `index(str, find)` | 字符串**查找**，在`str`中查找字符串`find`，未找到返回`0`，找到返回`find`首次出现的起始位置（大于等于`1`的自然数） |
| `match(str, regexp)` | 字符串**正则表达式查找**，查找`str`中符合`regexp`的片段，未找到返回`0`，找到则返回匹配字符串的起始位置。运行后全局变量`RSTART`被设为起始位置，`RLENGTH`被设为匹配字符串的长度（未找到`-1`） |
| `length(str)` | 字符串**长度** |
| `patsplit(str, arr, fieldpattern, seps)` `patsplit(str, arr, fieldpattern)` | 将`str`中每一个符合`fieldpattern`的子串按序放入`arr`（从`1`开始索引），而这些子串之间的字符串（可能为空）放入`seps`（从`0`开始索引） |
| `split(str, arr, fieldseparator, seps)` `split(str, arr, fieldseparator)` | 和`patsplit()`互补，`fieldseparator`指定分隔符的格式而非子串的格式 |
| `sprintf(format, var1, var2)` | `printf()`的赋值版，示例`x = sprintf("Hello")` |
| `strtonum(str)` | 字符变量转数字变量。`"0x"`开头自动识别为16进制，`"0"`开头自动识别为8进制 |
| `sub(regexp, replace, str)` | 单次替换，如果没有替换返回`0`，替换返回`1` |
| `substr(str, start, length)` | 返回`str`在指定位置、指定长度的子字符串，索引从`1`开始 |
| `tolower(str)` | 转小写 |
| `toupper(str)` | 转大写 |

**输入输出**

| 名称 | 解释 |
| :-: | :-: |
| `system(cmd)` | 执行shell指令 |
| `fflush()` | 将文件写入缓存写入 |
| `close(file)` | 关闭文件 |

**时间函数**

| 名称 | 解释 |
| :-: | :-: |
| `systime()` | 返回当前的UNIX时间（`1970-01-01 00:00:00`到现在的秒数） |
| `mktime(time)` | 将时间字符串转为UNIX时间。字符串格式必须遵守示例`1960 4 16 15 -1 0`（1960年4月16日下午3点之前的1分钟，可以为负数） |
| `strftime(format, uxtime)` `strftime(format, uxtime, utc_flag)` | 将UNIX时间`uxtime`转`format`表示的时间格式，`format`示例`"%Y-%m-%d %H:%M:%S"`（此外`%u` `%w`分别为星期数`1-7` `0-6`，`%U`为第几周，`%a`为星期几简写，`%b`为月份简写，`%I`为12小时制，`%p`表示上午下午，`%Z`为时区简写，`%z`为时区时间偏移）。如果`utc_flag`不为空或`0`那么转UTC时间 |


## 3.2 sed用法

命令行用法

参数

```
-n              # silent模式
-f filename     # 指定sed指令所在文件
-i              # 直接修改文件
```

`sed`有以下指令

| 指令 | 作用 |
| :-: | :-: |
| `a` | 新增下一行 |
| `c` | 替换一行 |
| `d` | 删除一行 |
| `i` | 新增上一行 |
| `p` | 输出 |
| `s` | 替换 |

示例

```shell
# 删除1到4行
sed '1,4d' test.txt

# 删除符合/pattern/的行
sed '/pattern/d' test.txt

# 添加行
sed '/pattern/a another line' test.txt

# 替换行
sed '/pattern/c line changed' test.txt

# 每一行第一个old替换为new
sed 's/old/new/' test.txt

# 1到12行所有old替换为new
sed '1,12s/old/new/g' test.txt

# 打印符合pattern的行
sed '/pattern/p' test.txt
```

## 3.3 Tcl编程

安装`tclsh`

```shell
sudo pacman -S tclsh
tclsh
```

### 3.3.1 Hello World

交互模式

```shell
tclsh
```

```
% puts {Hello World}
Hello World
% puts "Hello World"
Hello World
% puts HelloWorld
HelloWorld
```

编写`hello.tcl`

```tcl
#!/bin/tclsh

puts {Hello World};
puts "Hello World";
puts HelloWorld;
```

`tcl`中万物皆命令（Command），`puts`就是`tcl`的一个命令。`tcl`中每一条命令都以`;`或换行结尾，使用空格` `分隔命令参数。带空格的字符串必须使用`" "`括起来，否则会被当作多个参数。注释使用`#`

### 3.3.2 变量基础

变量赋值使用`set`命令

```tcl
# string1赋值为字符串hello，返回hello
set string1 hello;
# 返回hello
set string1;
# string2赋值为字符串hello world，返回hello world（无引号）
set string2 "hello world";
# var1赋值为225
set var1 225;
# arr为数组
set arr(1) apple;
```

和shell一样，变量引用使用`$`

```tcl
# 打印hello
puts $string1;
```

字符串使用`" "`和`{}`的区别是，`" "`中的变量引用会被正常替换

```
% puts "$string2 jim"
hello world jim
% puts {$string2 jim}
$string2 jim
```

`tcl`使用`[]`提取一个命令的返回结果，类似于shell的`$()`或` `` `，可以嵌套

```tcl
set var1 [cmd arg1 arg2];
```

> 同理，`{}`内的`[]`会变成普通字符，而`" "`内的`[]`会被`tcl`替换为其中的命令返回结果

**转义字符**

| 字符 | 值 | 解释 |
| :- | :- | :- |
| `\a` | `0x07` | Bell |
| `\b` | `0x08` | 退格 |
| `\f` | `0x0c` | 清屏 |
| `\n` | `0x0a` | 换行 |
| `\r` | `0x0d` | 回车 |
| `\t` | `0x09` | 横向Tab |
| `\v` | `0x0b` | 纵向Tab |
| `\0dd` |  | 八进制 |
| `\uHHHH` |  | 16位Unicode |

> 在命令行末加反斜杠`\`可以支持多行命令，字符`$`使用`\$`转义，`[]` `{}`等特殊符号转义同理

**变量作用域**

`tcl`中变量的作用域和常见编程语言类似，函数内出现的变量默认只能在函数中使用。`tcl`提供了`upvar`命令，其作用有点类似于C++里面的引用；使用`upvar`可以将当前上下文中的变量绑定到上一级作用域中的变量。实际代码中尽量少用`upvar`

```tcl
upvar #0 fvar lvar
upvar 1 fvar lvar
```

> 创建本地变量`lvar`绑定到其他作用域变量`fvar`。`#0`表示绝对层级`0`级，也即全局作用域内的变量；`1`表示向上一级（父级）

```tcl
proc sum {arg1} {
    upvar 1 arg2 var;
    set var [expr {$arg1+3}];
}
set arg2 2;
sum 1;
puts $arg2;
```

> 上述代码`arg2`被赋值成为`1+3`，输出`4`。以下为等价语句

```tcl
upvar arg2 var
upvar #0 arg2 var
```

`tcl`中还有`global`命令，上述代码可以更改如下，它在本作用域创建一个同名的全局变量（作用相当于声明了变量为全局变量）

```tcl
proc sum {arg1} {
    global arg2;
    set arg2 [expr {$arg1+3}];
}
set arg2 2;
sum 1;
puts $arg2;
```

### 3.3.3 表达式运算

`tcl`使用`expr`命令进行数学运算，许多程序流控制语句如`for` `if`  `while`也使用了`expr`。`expr`可以支持的运算包括常用的基本数学运算，逻辑运算，位运算，以及`rand()` `sqrt()`等高级数学运算。`expr`命令的参数为表达式（习惯上使用`{}`括起来，只由`expr`解析其中的表达式，可以防止`tcl`解析里面的表达式），计算后会返回一个整数或浮点数；`expr`会尽量在内部将数字当作整数处理

以下格式为浮点数

```
4.
3.2
9E7
3.33e+11
.112
```

可用运算符

| 运算符 | 类型 | 说明 |
| :- | :- | :- |
| `+` `-` `*` `/` `%` | 双目 |  |
| `**` | 双目 | 幂 |
| `-` `+` | 单目 | 负数、正数 |
| `！` | 单目 | 位取反，只用于整数 |
| `<<` `>>` `^` `&` `\|` | 双目 | 位运算，只用于整数 |
| `~` | 单目 | 逻辑非 |
| `&&` `\|\|` | 双目 | 逻辑运算 |
| ` ? : ` | 三目 |  |
| `==` `<` `>` `>=` `<=` | 双目 | 数值比较，为真返回整数`1`，为假返回`0`。可用于字符串比较 |
| `eq` `ne` | 双目 | 比较字符串是否相等 |
| `in` `ni` | 双目 | 字符串是否在一个列表（`list`）中 |

此外`expr`支持以下函数，`expr`函数调用需要使用括号

```
abs         acos        asin        atan
atan2       bool        ceil        cos
cosh        double      entier      exp
floor       fmod        hypot       int
isqrt       log         log10       max
min         pow         rand        round
sin         sinh        sqrt        srand
tan         tanh        wide
```

> `double`将数字转换为浮点数，`int`转换为整数，`wide`转换为长整数，`entier`转换为合适长度的整数（高精度）
>
> 现在新版的`tcl`已经支持高精度计算，基本无需担心整数溢出问题

示例

```tcl
set a [expr {0x44 & (0x67 ^ 0x76)}];
set b [expr {($var > 0) ? 2 : 3}];
set c [expr {abs(-1)}];
set d [expr {hypot($var1,$var2)}];
```

### 3.3.4 程序流控制

`if` `switch` `while` `for`本质上也是命令

`if`可以支持`1 0 true false yes no`作为表达式的返回值进行分支判断，`if`和`elseif`后面的条件表达式功能和`expr`的一样

基本格式，`if elseif else`和上一语句块的`}`、下一语句块的`{`**必须位于同一行**

```tcl
if {$var == 2} {
    puts "successful";
} elseif {$var == 3} {
    puts "error";
} else {
    puts "none";
}
```

> `if elseif`的条件判断表达式本质上是交给`expr`处理的，可以使用变量，`expr`会解析。而执行的命令虽然在`{}`中，它们本质上是交给`tcl`解析的，所以也能使用变量

`switch`语句本质上是匹配字符串（匹配的是一个pattern），而`default`表示匹配任何字符串

```tcl
switch $var {
    "one" {
        puts "successful";
    }
    two {
        puts "error";
    }
    default {
        puts "none";
    }
}
```

> 以上写法中pattern无法使用`$`变量，想要在pattern中使用变量需要依照以下写法，和`if`一样通过大括号首尾相连

```tcl
switch $var "$pattern" {
    puts "successful";
} "one" {
    puts "error";
} default {
    puts "none";
}
```

另外一种无括号写法，不常用

```tcl
switch $var \
"one"       "puts successful"   \
"two"       "puts error"        \
"default"   "puts none";
```

`while`循环采用同样的条件判断表达式。`while`可以支持`break`和`continue`语句

```tcl
while {$var < 5} {
    puts "\$var is $var";
    set var [expr {$var + 1}];
}
```

`for`循环使用3个`{}`依次给出初始化操作，判断表达式以及递增语句，循环代码块开头的`{`必须和`for`同一行。`for`循环可以使用`break`和`continue`。`tcl`有一个`incr`可以用于递增/递减变量

```tcl
for {set i 0} {$i < 10} {incr i} {
    puts "\$i is $i";
}
```

> `incr`不指定数字默认递增`1`，指定数字可以是负数

```tcl
for {set i 0} {$i < 10} {incr i 2} {
    puts "\$i is $i";
}
```

### 3.3.5 自定义函数

自定义函数（命令）使用`proc`，函数定义可以被覆盖

```tcl
proc sum {arg1 arg2} {
    set x [expr {$arg1 + $arg2}];
    return $x;
}
```

> 在调用该函数时会创建`arg1` `arg2`两个变量，并将实参传入变量。如果没有`return`返回命令，函数默认返回最后一条命令的返回值

**参数默认值**

可以使用`{arg val}`的格式在参数列表中设置参数的默认值，在调用函数时可以不传入形参

```tcl
proc sum {arg1 {arg2 2}} {
    set x [expr {$arg1 + $arg2}];
    return $x;
}
```

> 上述示例将`arg2`设置为`2`，调用时可以不传入`arg2`，例如`sum 12`，就是相当于`sum 12 2`
>
> 除了以上方法可以允许可变参数数量以外，`proc`还有一个特殊参数`args`，可以允许任意数量的参数

**可变参数列表**

```tcl
proc example1 {in1 {in2 2} args} {
    if {$args eq ""} {
        puts "Only $in1 and $in2";
        return 1;
    } else {
        puts "Args not empty";
    }
}

proc example2 {in1 in2 args} {
    if {$args eq ""} {
        puts "Only $in1 and $in2";
        return 1;
    } else {
        puts "Args not empty";
    }
}
```

> 上述函数`example1`可以允许任意的不小于`1`的参数数量，开头的两个参数`in1` `in2`以后多余参数全部传给了`$args`；而`example2`可以允许不小于`2`的参数数量

### 3.3.6 列表

`tcl`中每一条命令都是一个列表。列表可以使用以下格式定义

```tcl
set list1 {{item1} {item2} {item3}};
set list2 [split "item1.item2.item3" "."];
set list3 [list "item1" "item2" "item3"];
```

> 函数`split`和`list`的返回结果都是列表类型，所以可以用于生成列表。其中`split`将一个字符串依照分割符（默认空格` `，这里设定为`.`）分割成为若干个字符串，而`list`接受若干个元素并生成列表

列表元素可以使用`lindex`通过下标访问，下标从`0`开始

```tcl
set head [lindex $list1 0];
```

列表元素个数可以通过命令`llength`获取

```tcl
set length [llength $list1];
```

**列表遍历**

列表可以通过`foreach`命令遍历，依次将列表中元素的值赋值到一个临时变量中，并执行后面的命令

```tcl
foreach tmp $list1 {
    puts $tmp;
}
```

`foreach`还可以一次取多个元素

```tcl
foreach {a b} $list1 {
    puts "$a $b";
}
```

`foreach`也可以支持同时从多个列表取元素

```tcl
foreach a $list1 b $list2 {
    puts "$a $b";
}
```

**列表增删改查**

`concat`用于连接列表，返回连接后的列表，不会更改原列表

```tcl
set list1 [concat var0 $list1 var7 var8 var9 var10 var11];
foreach a $list1 {
    puts $a;
}
```

`lappend`用于追加元素，注意`lappend`使用的是列表名，不带`$`，以下同理，**会更改原列表**

```tcl
lappend list1 var4 var5;
```

`linsert`用于在指定下标（从`0`开始）前插入元素，返回列表长度和原来的相同，多余的元素会被挤出，不会更改原列表

```tcl
set list1 {{var7} {var8} {var9} {var10}};
set list1 [linsert list1 0 var0 var1];
set list1 [linsert list1 end var5 var6];
```

> 第二行命令以后`list1`成为`var0 var1 var7 var8`，第三行命令以后`list1`成为`var0 var1 var5 var6`

`lreplace`用于替换指定下标范围的元素，不会更改原列表

```tcl
set list1 {{var7} {var8} {var9} {var10}};
set list1 [lreplace list1 0 2 var1 var2];
```

> `list1`最终变成`var1 var2 var10`

`lset`用于直接给列表元素赋值，**会更改原列表**

```tcl
set list1 {{var7} {var8} {var9} {var10}};
lset list1 1 var1;
```

> `list1`最终变成`var7 var1 var9 var10`

`lsearch`用于查找，返回第一个符合指定pattern的列表元素下标，未找到返回`-1`。列表参数需要加`$`

```tcl
set list1 {{var7} {var8} {var9} {var10}};
puts [lsearch $list1 var10];
```

> 结果返回`3`

`lrange`取一个列表中的一段并返回

```tcl
set list2 [lrange 0 14 $list1];
```

> 返回`list1`中元素`0`到`14`

**列表排序**

`lsort`将元素按照字母序排序并返回

```tcl
set list1 [lsort $list1];
```

### 3.3.7 字符串处理

使用`string`命令的`match`功能进行字符串匹配，匹配成功返回`1`。非正则表达式模式，pattern和shell的文件通配符同理（`globbing`），`*`表示任意字符重复任意次，`?`表示任意字符出现一次

```tcl
string match f* foo;
string match b?b bob;
```

`string length`返回字符串长度

```tcl
set length [string length $string1];
```

`string index`返回字符串指定位置的字符

```tcl
set a [string index $string1 2];
```

> 返回下标`2`处的字符

`string range`返回指定范围的子字符串

```tcl
set string2 [string range $string1 0 4];
```

`string compare`按字符序比较两个字符串，返回`-1`（小于）`0`（等于）或`1`（大于）

```tcl
set string1 "apple";
set string2 "banana";
if {[string compare $string1 $string2]} {
    puts "not equal";
}
```

`string first`查找一个字符串在另一个字符串第一次匹配上的起始位置，没有匹配到返回`-1`。`string last`为最后一次匹配

```tcl
set string1 fox;
set string2 quickfox;
set start [string first $string1 $string2];
```

> `start`为`5`

`string wordstart`和`string wordend`分别返回指定字符所在单词的起始下标和结尾后一字符下标（空格算在内）

```tcl
set string1 "quick brown fox";
set a [string wordstart $string1 0];
set b [string wordstart $string1 4]
set c [string wordstart $string1 5];
set d [string wordstart $string1 10];
set e [string wordend $string1 0];
```

> `a`为`0`，`b`为`0`，`c`为`5`，`d`为`6`，`e`为`5`

`string tolower`和`string toupper`分别将字符串所有字符改为小写、大写

```tcl
set string1 [string toupper $string1];
```

`string trim` `string trimleft` `string trimright`从字符串中删除指定字符集，默认也会删除包含空格、制表符、换行等不可见字符

```tcl
set string1 "quick brown fox";
set string2 [string trim $string1 qufox];
set string3 [string trimleft $string1 quix];
```

> `string2`为`ick brown`，`string3`为`ck brown fox`。`string trim`是同时从两边消除的，`string trimleft`和`string trimright`是从一边消除的

`string format`可以实现类似C语言中的`fprintf`样式的格式化输出，`%`后的`-`表示左对齐，`+`表示右对齐

```tcl
set string1 [format "%d words found" $var1];
```

**正则表达式**

`tcl`支持正则表达式

`regexp`使用一个正则表达式对字符串进行匹配，正则匹配状态机最终处于结束状态表示成功，返回`1`，否则返回`0`

```tcl
set sample "Where there is a will, There is a way.";
set result [regexp {([A-Za-z]+ )([a-z]+ )([a-z]+ )([a-z]+ )} $sample match sub1 sub2 sub3 sub4];
```

> 运行结束后`match`中存放的是匹配子串（状态机从入口到出口经过的字符串），正则表达式里面有几个括号就可以在`match`后面添加几个变量，这里运行结束后`sub1 sub2 sub3 sub4`中存放的分别为第n个括号内表达式对应的子字符串

`-all`参数应用示例：返回有几个匹配结果

```tcl
puts "Number of words: [regexp -all {[^ ]+} $sample]";
```

`regsub`替换匹配上的字符串，并将结果输出到一个变量。如果发生了替换操作，返回`1`

```tcl
regsub {[A-Z][a-z]+} $sample "Default" string;
```

> 运行后`string`为`Default there is a will, There is a way.`

### 3.3.8 数组

和shell类似，`tcl`的数组实质上为哈希表，采用键值对

实际应用中，经常使用`global`将一个数组设为全局变量使用

```tcl
set arr(head) "zero";
set arr(1) "one";
puts $arr(head);
```

`array exists`检查是否为数组，是返回`1`

```tcl
set isarray [array exists arr];
```

`array names`返回所有下标（键）

```tcl
set keys [array names arr];
set keys [array names arr {he*}];
```

> 第二条命令得到`he`开头的键

`array size`返回数组长度

```tcl
set len [array size arr];
```

`array set`和`array get`分别用于列表转数组以及反向转换

```tcl
set lst [array get arr];
array set arr2 $lst;
```

> 列表中，规定下标偶数为键，下标奇数为值

`array unset`用于删除一个数组或特定的数组变量

```tcl
array unset arr(head);
array unset arr;
```

**数组作为函数参数**

不可直接传，必须使用`upvar`绑定，示例

```tcl
proc printhead {array} {
   upvar $array a
   puts "$a(head)";
}

printhead arr;
```

**遍历数组**

`foreach`需要使用到一些小技巧，如下示例

```tcl
foreach key [array names arr] {
    puts "$arr($key)";
}

foreach key [lsort [array names arr]] {
    puts "$arr($key)";
}

foreach {key val} [array get arr] {
    puts "$key is $val";
}
```

### 3.3.9 字典

字典`dict`是`tcl8.5`引入的特性

先看示例

```
% dict set yahaha 1 Name John
1 {Name John}
% dict set yahaha 1 Gender Male
1 {Name John Gender Male}
% dict set yahaha 2 Name Lydia
1 {Name John Gender Male} 2 {Name Lydia}
% dict set yahaha 2 Gender Female
1 {Name John Gender Male} 2 {Name Lydia Gender Female}
% dict set yahaha 1 Goods Quantity 4
1 {Name John Gender Male Goods {Quantity 4}} 2 {Name Lydia Gender Female}
% dict set yahaha 1 Goods Price 14
1 {Name John Gender Male Goods {Quantity 4 Price 14}} 2 {Name Lydia Gender Female}
% dict set gemini 1 Name Jason
1 {Name Jason}
% puts $gemini
1 {Name Jason}
% dict set yahaha 2 Goods Price 17 
1 {Name John Gender Male Goods {Quantity 4 Price 14}} 2 {Name Lydia Gender Female Goods {Price 17}}
```

`dict`是一种多层哈希表，它可以取代`tcl`中传统数组的作用，并且字典本身可以作为函数的参数，无需像数组一样使用`upvar`绑定才能使用

> 观察上述示例，发现`dict`总是将最后两个参数放在同一层，并且会检测我们新添加的数据是否经过已有路径。因此`dict`的层次结构中，**每一层都有偶数数量的元素**。`dict set`后面第一个参数为字典名，它是定义在当前上下文的一个变量，可以通过`$var`的形式使用。其余每个参数都代表一个层
>
> `dict`本质上相当于每一层都有偶数个元素的嵌套列表。我们使用`foreach`就可以印证这一点

```
% dict set exynos 1 Name Aurora
1 {Name Aurora}
% dict set exynos 2 Name Justice 
1 {Name Aurora} 2 {Name Justice}
% dict set exynos 3 Name Tenacity
1 {Name Aurora} 2 {Name Justice} 3 {Name Tenacity}
% dict set exynos 1 Property Sun
1 {Name Aurora Property Sun} 2 {Name Justice} 3 {Name Tenacity}
% dict set exynos 2 Property Mercury
1 {Name Aurora Property Sun} 2 {Name Justice Property Mercury} 3 {Name Tenacity}
% dict set exynos 3 Property Saturn
1 {Name Aurora Property Sun} 2 {Name Justice Property Mercury} 3 {Name Tenacity Property Saturn}
% foreach {id info} $exynos {puts "$id: $info"}
1: Name Aurora Property Sun
2: Name Justice Property Mercury
3: Name Tenacity Property Saturn
```

> 每使用一层`foreach`，里面就是一个新的上下文，可以通过`$var`使用`foreach`新创建的变量。由于前文所说的缘故，字典每一层相当于偶数个元素的列表，每一层`foreach`只可应用于当前层，因此`foreach`后面必须为`{id info}`有且必须有`2`个迭代变量，否则代码就是无意义的

**遍历字典**

字典遍历通常不使用`foreach`，有专用的`dict for`命令进行遍历，配合`dict with`命令使用

继续上述示例

```
% dict for {id info} $exynos {
puts "ID: $id";
dict with info {
puts "Name: $Name Property: $Property";
}
}
ID: 1
Name: Aurora Property: Sun
ID: 2
Name: Justice Property: Mercury
ID: 3
Name: Tenacity Property: Saturn
```

> `dict for`的使用格式和`foreach`相同。`dict with`可以在当前上下文中基于已有的变量再创建新一层的上下文。上面示例中，这个上下文基于变量`info`创建，`info`代表的是子列表这个整体（例如`{Name Aurora Property Sun}`），正如`$exynos`代表的是整个字典，在这个上下文中可以使用偶数位置的`$Name`和`$Property`（key）引用它们的值
>
> 再看一个示例可以理解`dict with`的含义，它本质上是创建了一些变量，实现了将传入列表依次按key-value形式访问的功能

```
% dict with exynos {
puts $1;
}
Name Aurora Property Sun
```

字典也可以通过`dict get`访问，但是不常用

```
% dict get $exynos 2 Property
Mercury
```

在`dict`命令中进行的更改会被保存

```
% dict with exynos {
set 1 {Name Aurora Property Neptune};
}
Name Aurora Property Neptune
% dict for {id info} $exynos {
puts "ID: $id";
dict with info {
puts "Name: $Name Property: $Property";
}
}
ID: 1
Name: Aurora Property: Neptune
ID: 2
Name: Justice Property: Mercury
ID: 3
Name: Tenacity Property: Saturn
```

修改字典值依旧使用`dict set`

```
% dict set exynos 2 Property Pluto 
1 {Name Aurora Property Neptune} 2 {Name Justice Property Pluto} 3 {Name Tenacity Property Saturn}
```

### 3.3.10 文件

仅文本文件，不适用于二进制文件

**打开和关闭**

打开一个文件，返回一个句柄

```
% set fp [open file.txt r]
file3
```

> 最后的`r`为打开模式，表示写。共有以下模式可用

| 模式 | 定义 |
| :- | :- |
| `r` | 只读模式，文件必须已存在 |
| `r+` | 读写模式，文件必须已存在，常用 |
| `w` | 写入模式，文件不存在时创建，存在时将文件长度置`0` |
| `w+` | 读写模式，文件不存在时创建，存在时将文件长度置`0` |
| `a` | 追加写入模式，文件必须已存在，将写指针放到文件末尾（不可修改原来内容） |
| `a+` | 追加写入模式，文件不存在时创建，将写指针放到文件末尾（不可修改原来内容） |

> 打开模式以后还可以加上文件权限，默认`0666`。不常用

写入缓冲并关闭文件，但是给句柄变量赋的值还在，句柄变量本身不会被删除

```
% close $fp
```

> `tcl`只能同时打开有限数量的文件，不用的文件需及时关闭

**读取和写入**

使用`gets`读取文件，每次执行`get`读取一行，**指针移到下一行**，并去除换行符

```
% gets $fp
Welcome to the facinating journey through our cosmic neighborhood, the Solar System!
% gets $fp line
119
% puts $line
Prepare to be captivated as we delve into the wonders that revolve around our nearest star, the Sun – the Solar System.
```

> 如果最后不加变量，`gets`直接返回读取的字符串。如果加了变量，`gets`返回读取的字符数量，并将字符串赋值给变量
>
> 遇到`EOF`时，前者返回一个空串，后者返回`-1`。但是空串不一定代表`EOF`，遇到空行也会返回空串

使用`puts`默认是输出到标准输出，它也可以写文件，给出文件句柄即可（需要使用写模式打开）。写入后文件指针会发生对应的偏移

```
% set fp [open file.txt a]
file3
% puts $fp "New string"
```

> 上述命令在文件末尾加上新行`New string`。可以使用`puts -nonewline`参数，插入新行同时不添加换行符（默认会在新行末尾添加换行）

`read`是更常用的文件读取命令，同样依赖句柄以及指针

从当前位置开始读取整个文件所有字符，可以加`-nonewline`表示忽略结尾的换行符

```
% set string1 [read $fp]
```

从当前开始读取n个字符

```
% set string3 [read $fp 10]
```

`seek`用于移动指针，在`a a+`模式下不能将指针放到文件`EOF`之前进行写入

```
% seek $fp 10 start
% seek $fp 10 current
% seek $fp 10 end
```

> `start current end`分别表示相对文件开头（默认），当前指针位置，以及文件结尾。offset为负数表示向前移动

`tell`返回指针当前的位置

```
% tell $fp
```

`flush`强制缓冲写入，有时在多进程环境下有用，或在异常退出时保证文件完整性

```
% flush $fp
```

`eof`表示当前是否已经触及过了`EOF`，是返回`1`

```
% eof $fp
```

**文件基本操作**

包含复制，删除，新建目录，重命名

```
% file copy -force "log.txt" "new.txt"
% file delete -force "/tmp/cache/download/"
% file mkdir "build"
% file rename -force "log.txt" "old.txt"
```

**文件系统访问**

`glob`命令用于列出当前路径或指定绝对路径下的文件和/或目录，返回一个列表，可以使用通配符

```
% glob -nocomplain -types f -- *
% glob -nocomplain -types d -- ~/*
% glob -nocomplain -types r -- /srv/*
```

> `f`表示仅列出文件，`d`表示仅目录，`r`表示文件和目录。除相对路径外，其余输出都为完整路径

`file`命令主要用于路径名处理，以及查看文件属性等

```
% file join ".." "build" "release"
% file split "/var/lib/server"
% file dirname "/srv/www"
% file extension "file.txt"
% file tail "/var/lib/server/log.txt"
% file atime "file.txt"
% file mtime "file.txt"
% file executable "curl.sh"
% file exists "file.txt"
% file isdirectory "bin"
% file isfile "file.txt"
% file owned "file.txt"
% file readable "file.txt"
% file writable "file.txt"
% file readlink "link.txt"
% file size "log.txt"
% file type "bin.elf"
% file lstat "file.txt" linfo
% file stat "file.txt" linfo
```

以下为各命令解释

| 命令 | 解释 | 示例结果 |
| :- | :- | :- |
| `join` | 将各个字符串使用路径分隔符连起来，主要为了处理Windows和Linux下路径分隔符不同的问题 | 返回`../build/release` |
| `split` | `join`的逆转换 | 返回列表`/ var lib server` |
| `dirname` | 提取路径中除文件名外的部分 | 返回`/srv` |
| `extension` | 提取文件后缀 | 返回`.txt` |
| `tail` | 返回文件名，去除目录 | 返回`log.txt` |
| `atime` | 最后访问时间，需要文件系统开启此功能 | 返回Unix时间 |
| `mtime` | 最后修改时间 | 返回Unix时间 |
| `executable` | 是否可执行 | 是返回`1`，否返回`0` |
| `exists` | 文件或目录是否存在 | 同上 |
| `isdirectory` | 存在并是一个目录 | 同上 |
| `isfile` | 存在并是一个文件 | 同上 |
| `owned` | 是否为当前用户拥有 | 同上 |
| `readable` | 当前用户是否可读 | 同上 |
| `writable` | 当前用户是否可写 | 同上 |
| `readlink` | 提取符号链接实际指向的文件 | 返回路径字符串 |
| `size` | 文件大小 | 返回字节数 |
| `type` | 文件类型 | 可返回`file` `directory` `link`等字符串 |
| `lstat` | 获取文件信息并以数组形式存放到数组变量中 | 使用`$linfo(atime)`的形式，可用的键值有`atime ctime mtime dev gid uid mode ino nlink size type` |
| `stat` | 同`lstat`，只是使用的系统调用不同 |  |

`tcl`也有`cd`和`pwd`命令，可以切换当前工作目录，以及显示当前目录

```tcl
cd ..
pwd
```

### 3.3.11 调用其他可执行文件

可以使用`open`或`exec`命令

示例，编写一个最简单的shell交互脚本`test.sh`

```shell
#!/bin/bash

read -p "input1: " var1 
echo "input1 is: $var1"
read -p "input2: " var2
echo "input2 is: $var2"
```

使用`open`调用该脚本并交互，较为繁琐，需要使用到一个句柄，`|`为管道符，`puts`和`gets`等命令都使用该句柄，对被调可执行文件的标准输入输出进行操作

```
% set hp [open "|./test.sh" r+]
file5
% puts $hp 133
% flush $hp
% gets $hp
input1 is: 133
% puts $hp 775
% flush $hp
% gets $hp
input2 is: 775
```

`exec`较为简单，但是功能没有`open`强大，下例执行`ls /`命令，输出结果会立即返回

```
% exec ls /
```

使用`exec`时如果遇到标准错误有输出内容，`tcl`脚本也会退出，这在有些应用中会导致不便。可以使用以下方法

```tcl
if { [catch { exec make } msg] } {
   puts "Something seems to have gone wrong but we will ignore it"
}
```

### 3.3.12 info

`info`主要用于调试，可以检查当前的上下文中的各种信息

检查当前可用的内置和外部/仅外部命令，可以加pattern

```
% info commands
% info procs
```

检查变量是否存在，是返回`1`

```
% info exists var
```

检查`expr`可用的数学函数，可以加pattern

```
% info functions
```

查看全局，局部以及所有变量，可以加pattern

```
% info globals
% info locals
% info vars
```

查看当前运行该脚本的程序，例如`/usr/bin/tclsh`

```
% info nameofexecutable
```

### 3.3.13 source

和shell一样，`tcl`也支持`source`

```tcl
source libprober.tcl
```

### 3.3.14 运行时创建命令：eval

有时我们在一个阶段无法确定下一步要执行什么样的命令，包括命令名称。这时候就可以使用`eval`，shell中也有相同的用法

```tcl
eval $cmd
```

### 3.3.15 模块化与命名空间

除了`source`以外，`tcl`也支持将代码制作成`package`，并在我们使用到的代码中引用，例如我们想要使用一个名叫`libfrt`的包，版本`1.11`

```tcl
package require libfrt 1.11
```

添加`-exact`参数表示只接受特定版本。如果没有该参数，可以允许同一个主版本号下的更新版本

```tcl
package require -exact libfrt 1.11
```

通常每一个`package`都是一个`tcl`文件，在开头使用如下声明

```tcl
package provide libfrt 1.11
```

> 一个包也可以使用`package require`依赖其他包，常用的有`package require Tcl 8.6`，声明`tcl`的版本

对于一个目录下的所有`tcl`包，我们需要使用一个`pkgIndex.tcl`来描述它们。在当前目录下启动`tclsh`，运行以下命令生成`pkgIndex.tcl`

```
% pkg_mkIndex -direct . lib*.tcl
```

> `pkg_mkIndex`命令会到指定目录下（这里是`.`）查找指定文件名，检查这些文件中的`package provide`声明，并将`package`信息输出到`pkgIndex.tcl`
>
> 在其他文件中首次使用`package require`引用包时，`tcl`会到`tcl_pkgPath`以及`auto_path`下查找`pkgIndex.tcl`文件，包会被立即加载，这些目录见下，其中`auto_path`可以在运行时更改，我们可以将自己的查找路径添加入`auto_path`

```
% echo $tcl_pkgPath                 
{/usr/lib} 
% echo $auto_path
/usr/lib/tcl8.6 /usr/lib
```

> 除`-direct`加载模式以外，还有`-lazy`模式，只有当使用到实际命令时才会加载包
>
> `tcl`也可以支持使用`load`命令加载`.so`库文件，这里不讲述

**命名空间**

`tcl`支持和C++一样的命名空间机制，解决方法、变量名冲突的问题。建议所有`tcl`包都要使用命名空间机制

一个命名空间中的方法可以访问到同命名空间的变量和方法，也可以访问到全局变量和方法。命名空间可以嵌套。命名空间使用`::`作分隔，可以使用绝对路径（示例`::custom::frt`）或相对路径（`custom::frt`）

命名空间中的命令可以使用`export`以允许被其他命名空间`import`后直接使用，调用的还是原方法

查看当前命名空间，绝对路径

```
% namespace current
::
```

命名空间内的变量可以在`namespace eval`命令内使用`variable`命令声明，可以有初始值

```tcl
namespace eval ::custom {
    variable state
    variable name "null"
}
```

声明方法时如下，只需在方法名中规定命名空间即可。在其他代码中`require`该包以后就可以通过绝对或相对命名路径使用

```tcl
proc ::custom::proc1 {} {

}
```

`export`也需要在命名空间内执行

```tcl
namespace eval ::custom {
    namespace export proc1 proc2
}
```

**Ensemble**

`tcl`支持将一个命名空间改为一个命令，该空间内的命令成员变成该命令的子命令，这种机制称为`ensemble`。例如原先的`custom::proc1 arg`，就可以通过`custom proc1 arg`调用。`tcl`自带的很多函数都是使用这种机制实现的

需要在命名空间内执行`namespace ensemble`命令，以下命令将`::custom`命名空间转换成`custom`命令

```tcl
namespace eval ::custom {
    namespace ensemble create
    namespace ensemble create -command ::newcmd
}
```

> 使用`-command`可以将`ensemble`命令创建为指定名称的命令，这里为`newcmd`，其默认值为`custom`

### 3.3.16 错误处理

在`tcl`中，一条命令不仅会有`return`返回值，还有返回状态。命令可以触发异常，那么返回状态就是异常，同时全局变量`errorInfo`会记录异常信息。在嵌套的程序中异常是会逐级触发的，假设`a`调用了`b`，`b`调用了`c`，如果`c`触发异常，那么`b`和`a`也会依次触发异常

> 前面说过`tcl`中的循环本质上仍是命令。循环的`continue`和`break`其实就是触发了异常，循环命令通过这些异常判断下一步如何执行

异常可以使用`error`命令触发，使用`catch`命令捕捉

```tcl
error "Error occurred" "proc: some type of error" 127;
```

> `error`后面依次可以加3个参数，依次为打印的信息`message`，记录到变量`errorInfo`的内容，以及错误码`errorCode`（也是一个变量）

使用`catch`可以捕捉一个错误，但`catch`本身永远可以成功执行。如果`catch`的指令执行异常，`catch`会返回`1`

```tcl
set status [catch command];
```

可以使用一个变量存储命令执行的返回（`return`）结果

```tcl
set status [catch command result];
```

`return`本身更加通用，同样可以用于触发异常

```tcl
return -code error -errorinfo $info -errorcode 127
```

### 3.3.17 命令行参数

命令行参数数量通过全局变量`argc`获取，变量`argv0`为调用当前脚本时使用的命令（例如`./test.tcl`），其余所有用户给出的命令行参数存放在列表`argv`中，例如获取第一个命令行参数

```tcl
set arg0 [lindex $argv 0];
```

除命令行参数外，还可以获取shell环境变量，通过数组`env`

```tcl
set path $env(PATH);
```

### 3.3.18 Tcl网络开发

`tcl`可以支持网络编程，这在OpenOCD中有应用

`tcl`可以使用`socket`命令启动一个服务器或客户端，并在TCP连接建立后触发指定的命令

在`3030`端口启动一个服务器等待连接，连接建立时调用`server_handle`命令，返回服务器ChannelID，服务器的`cid`只能用于关闭连接，不可用于数据传输

```tcl
set cid [socket -server server_handle 3030];
```

`server_handle`必须要能够接收`3`个参数，分别为`{channel address port}`，分别为客户端的ChannelID，地址以及端口。服务器需要使用客户端的ChannelID进行数据读写

```tcl
proc server_handle {channel addr port} {    
}
```

不加`-server`参数可以启动一个客户端连接。如下，连接到`tcl`服务器的`3030`端口

```tcl
set cid [socket -async "192.168.1.1" 3030];
```

> `-async`异步连接表示允许`socket`命令在连接没有建立完成时就返回

可以指定客户端的地址（有多个网络的情况下），端口

```tcl
set cid [socket -async -myaddr "192.168.1.3" -myport 9700 "192.168.1.24" 3030];
```

网络编程通常需要结合`fileevent`和`vwait`使用

`fileevent`可以在ChannelID状态改变时调用相应的命令，`writable`表示通道可写，`readable`表示可读，使用阻塞实现安全读写

```tcl
fileevent $cid readable command
fileevent $cid writeable command
```

`vwait`可以在一个变量被设定之前保持阻塞状态。这个变量可以由`fileevent`调用的命令设定，或连接建立时调用的命令设定。下例中等待变量`semaphore`后继续执行

```tcl
vwait semaphore
```

`tcl`给出的官方示例

```tcl
proc serverOpen {channel addr port} {
    global connected
    set connected 1
    fileevent $channel readable "readLine Server $channel"
    puts "OPENED"
}

proc readLine {who channel} {
    global didRead
    if { [gets $channel line] < 0} {
	fileevent $channel readable {}
	after idle "close $channel;set out 1"
    } else {
	puts "READ LINE: $line"
	puts $channel "This is a return"
	flush $channel;
	set didRead 1
    }
}

set connected 0
# catch {socket -server serverOpen 33000} server
set server [socket -server serverOpen 33000]

after 100 update

set sock [socket -async 127.0.0.1 33000]
vwait connected

puts $sock "A Test Line"
flush $sock
vwait didRead
set len [gets $sock line]
puts "Return line: $len -- $line"

catch {close $sock}
vwait out
close $server
```

### 3.3.19 文件进阶：fblocked和fconfigure

`tcl`支持两种读写（文件和socket）方式，一种是阻塞的，一种是非阻塞的。在有阻塞的读写中，如果使用`gets`读取缓冲区，而缓冲区内没有有效的数据，`gets`会一直等待直到数据被全部放到缓冲区；而使用`puts`写缓冲区时，如果缓冲区已满，`puts`会等待直到缓冲区出现空闲空间。编写程序时需要注意`flush`的使用以及规避死锁

非阻塞模式下`gets`不会检查缓冲区，而是直接读取。必须至少读取一行数据，出现了行结束符才能读取到该行字符。否则`gets`（后不加变量参数）读取不到数据，直接返回空（此时使用`fblocked`检查，返回`1`）

在非阻塞模式下，依旧可以使用`fileevent`触发缓冲读取，并紧接着使用`fblocked`检查是否还有剩余数据

`fblocked`命令用于检查缓冲区是否有有效数据，或通道已经关闭

`fconfigure`命令用于配置通道的各项参数，例如是否阻塞，缓冲区大小等

使用`fconfigure`关闭阻塞，同时可以`-buffersize`设定缓冲大小，`-translation`设定一行的结束符

```tcl
fconfigure $cid -blocking false -buffersize 1024
```

> 不同平台的行结束符不同，例如Windows平台为`crlf`，Mac平台为`cr`，Unix平台为`lf`。默认`auto`会自动进行转换

### 3.3.20 时间

使用`clock`命令

自epoch开始的时间（秒）

```tcl
clock seconds
```

`clock format`可以将一个时钟值转换为可读格式

```tcl
clock format [clock seconds] -gmt true -format "%y-%m-%d %H:%M:%S"
```

> `-gmt`表示使用GMT时间，`-format`可用格式如下

| 格式 | 定义 |
| :- | :- |
| `%y` `%Y` | 两位数、四位数年份 |
| `%m` `%b` `%B` | 两位数、简写、全称月份 |
| `%d` | 两位数日期 |
| `%H` `%I` | 24、12小时制两位数小时 |
| `%M` | 两位数分钟 |
| `%S` | 两位数秒 |
| `%p` | 上下午 |
| `%a` `%A` | 简写、全称星期 |
| `%j` | 年中天数 |
| `%D` | `%m/%d/%y` |
| `%r` | `%I:%M:%S %p` |
| `%R` | `%H:%M` |
| `%T` | `%H:%M:%S` |
| `%Z` | 时区名 |

## 3.4 expect编程

### 3.4.1 简介

`expect`相当于一个扩展版的`tcl`，它可以执行一个交互式终端程序并按照设计好的规则与其交互。在shell应用中，`expect`填补了shell无法和程序交互的空缺，可以用于shell脚本中`ssh` `rsync` `ftp`等交互式命令。它也可以用于黑盒测试，由用户编写测试点，可以用于Oj系统。DejaGnu就是基于`expect`开发的，使用到了`shell`和`tcl`

`expect`脚本实质上依旧是`tcl`脚本，遵守`tcl`语法，习惯上使用`.exp`后缀，开头如下

```tcl
#!/usr/bin/expect --
```

> `expect`中最关键的部分只有`4`条命令，分别为`spawn` `expect` `send` `interact`。会使用这`4`条命令就足以满足大部分`expect`应用需求了
>
> `spawn`用于执行一个外部的可执行文件，`expect`用于匹配外部程序的标准输出内容并调用对应处理命令，`send`用于输入字符串到外部程序的标准输入，`interact`用于将控制权转移给用户

### 3.4.2 示例

```tcl
set timeout -1
set passwd [lindex $argv 0]

spawn rsync -avz /home/tmp/repo/ user@192.168.1.4/repo/
expect "192.168.1.4) Password: " {
	send "$passwd\n"
}
expect "192.168.1.4) OTP code: " {
	interact
}
```

> 上述代码连接到一个`rsync`服务器并同步文件，使用到了所有`4`个基本命令。`timeout`是`expect`下内置的一个全局变量，默认值为`10`，设为`-1`时关闭命令的超时退出

### 3.4.3 命令详解

`spawn`命令直接将运行程序的名称、参数列出即可，被调用程序的stdin、stdout和stderr会被绑定到`expect`

```tcl
set pid [spawn -noecho command arg1 arg2]
```

> `spawn`命令返回的是运行的command在系统中的PID（也可以使用`exp_pid`命令获取）。同时全局变量`spawn_id`会被设置为当前运行程序的句柄，可以使用`close $spawn_id`命令关闭`expect`和程序的连接
>
> `spawn_id`可以赋为其他值，例如`$user_spawn_id` `$error_spawn_id`等，使用不多
>
> `-noecho`参数使`spawn`执行程序时不在终端输出命令行

`expect`命令中可以指定多个匹配模式，使用正则表达式格式。只要被控制程序的标准输出和其中一个模式匹配上，就会执行对应的命令

单匹配模式

```tcl
expect "pattern" {
    command
}
```

多匹配模式，按顺序依次匹配。一个`expect`命令只能匹配一次，执行完成后就会转到下一个`expect`命令并等待

```tcl
expect {
    "pattern1" {
        command
    }
    "pattern2" {
        command
    }
    timeout {
        command
    }
    eof {
        command
    }
}
```

> 特殊模式`timeout`表示超时，`eof`表示程序返回了EOF。`default`表示`timeout`或`eof`

> `exp_continue`用于`expect`命令内，例如上述的多模式，可以使`expect`继续运行而不是返回，执行下一条命令

`send`命令将指定字符串输入到程序的标准输入

```tcl
send "input string\r"
```

> 模拟键盘输入，`\r`就是回车键，发送`\r`以后缓冲内的字符串才会发送到程序。如果需要输入`-`开头的字符串，需要使用`send -- "-input\r"`
>
> `send -null 5`表示发送`5`个`null`字符
>
> 使用`send -s "string\r"`可以减缓发送速度，需要设置全局变量`set send_slow {1 0.1}`，表示以`1`字节为单位，每次发送`1`单位的字符数量时中间隔`0.1`秒。类似还可以使用`-h`模拟真实的人类输入，设置全局变量`set send_human {0.1 0.2 1.5 0.05 2}`，表示字符之间隔`0.1`秒，单词之间隔`0.2`秒，随机变化参数`1.5`（越大越不随机），限制间隔最小`0.05`秒，最大`2`秒
>
> 使用`send_err`命令可以从stderr输出指定字符串

`interact`命令将程序的stdin、stdout和stderr暂时移交给用户

除了最常用的无参数用法，`interact`还支持用户输入特定字符串时执行特定命令，同样可以支持多字符串的匹配（用户输入不会被传给运行的程序）

```tcl
interact {
    "reset" {
        command
    }
    \003 {
        exit
    }
    "interactive"
}
```

> 匹配的字符串后面如果没有命令，表示输入该字符串后继续以交互模式运行

`close`命令显式关闭程序连接，同时杀死程序，例如在`exec kill $pid`时需要使用到。默认情况下`expect`和`interact`在检测到程序退出时也会隐式执行一次`close`

```tcl
close -i spawn_id
```

> 调用`close`有时需要在后面加上`wait`命令

`disconnect`命令会断开当前和程序的连接，但程序继续在后台运行，不再受`expect`的控制

```tcl
disconnect
```

`exit`直接退出`expect`，同时向运行的程序发送一个EOF。程序可能会停止，也有可能由init接管

```tcl
exit
```

> 可以使用`-onexit handler`指定退出时执行的命令

`sleep`暂停，秒

```tcl
sleep 3
```

`trap`可以覆盖`expect`在接收到信号时执行的默认命令

```tcl
trap {command} SIGINT
```

忽略一种信号

```tcl
trap SIG_IGN SIGINT
```

`wait`命令等待，直到我们使用`spawn`运行的程序退出

```tcl
wait
```

`log_file`命令指定日志文件

```tcl
log_file "sample.log"
```

> 可以使用`send_log`向日志文件输出指定字符串

```tcl
send_log -- "Successful"
```

> 可以使用`log_user`命令开启、关闭`expect`的日志输出

```tcl
log_user 0
```

`expect_user`和`expect`用法相同，但是它会从用户这里读取标准输入。不常用

```tcl
expect_user "pattern" command
```

`send_user`类似，用于输出一个字符串到stdout

```tcl
send_user "string\r"
```

`remove_nulls`可以指定是否消除被控制程序输出中的`null`字符

```tcl
remove_nulls 1
```