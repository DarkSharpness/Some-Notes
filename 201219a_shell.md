# Linux命令行以及Shell脚本

记录Linux下一些常见的命令的比较有用的用法，以及Shell脚本的编写

## 参考书籍

Linux命令行与Shell脚本编程大全 3rd Edition. Richard Blum, Christine Bresnahan, 2016

## 1 常用基本命令以及命令行参数

### 1.1 文件管理

#### 1.1.1 ls或dir

列出文件

```shell
ls

命令行参数
-R 递归显示目录下内容
-a 列出所有，包括.开头的隐藏文件
-l 详细信息，格式：mode owner group size time name
    mode：l代表链接，d代表目录，b代表块设备，c代表字符设备，p代表FIFO。rwx分别代表读写运行权限
-F 用于区分目录，在目录后加/
-h 显示文件大小时自动换算为K，M，G
--time=atime 显示访问时间而非修改时间
-i inode编号，系统中每一个文件和目录都有，且唯一
```

文件匹配

```shell
ls *.txt            显示以.txt结尾
ls date?.txt        显示date1.txt，datea.txt等
ls date[12].txt     显示date1.txt，date2.txt
ls date[1-3].txt    显示date1.txt，date2.txt，date3.txt
ls date[!1].txt     不显示date1.txt
```

#### 1.1.2 pwd

打印当前目录

#### 1.1.3 cd 

到一个目录下

../代表父目录，./代表当前目录

#### 1.1.4 touch

新建/访问一下文件

```shell
touch test.txt
```

#### 1.1.5 cp

拷贝文件

```shell
cp source.txt destination.txt
cp source.txt destination/

命令行参数
-r 递归，用于复制一个目录
-i 遇到同名文件询问是否覆盖
-v 显示当前动作
-p 保留文件时间戳，mode，用户等信息
--preserve=mode,ownership,timestamps
--preserve=all
-f 强制拷贝
```

#### 1.1.6 mv

移动/重命名文件

```shell
mv source.txt destination.txt
```

#### 1.1.7 rm和rmdir

删除/删除目录

```shell
rm 

命令行参数
-i 询问是否删除
-r 递归删除一个目录
-f 强制删除
```

#### 1.1.8 mkdir

创建目录

```shell
mkdir 

命令行参数
-p 如果创建多级目录，则递归生成
```

#### 1.1.9 ln

链接

```shell
ln file link

命令行参数
无参 硬链接，信息和源文件相同，是同一个文件（使用同一个inode），等同于引用源文件，只能用于同一个文件系统
-s 符号链接，创建的是一个符号文件，不是同一个文件，可以用于不同文件系统之间的引用
```

#### 1.1.10 file

查看文件类型

#### 1.1.11 cat

输出/连接文件，并输出到标准输出

```shell
cat file1.txt
cat file1.txt file2.txt

命令行参数
-n -b 显示行号
```

#### 1.1.12 less和more

分页文本查看器

#### 1.1.13 tail和head

查看一个文件的开头n行或结尾n行

```shell
head -n 5 log.txt
tail -n 5 log.txt
tail -5 log.txt
```

#### 1.1.14 文件归档、压缩和解压缩

归档常用工具：tar

压缩常用工具：gzip，bzip2，zip，xz，zstd

解压缩：gzip，bzip2，unzip，xz，zstd

**tar**

```shell
tar option file

命令行参数
一般操作
-x 解压
-u 更新，仅更改新近修改的文件
-c -f file1 file2 创建归档
-t 列出内容
-f 指出文件
-p 保留权限
-v 显示过程

解压选项
-a 根据文件后缀自动决定解压方式
-z 使用gzip
--zstd 使用zstd
-j 使用bzip2
-J 使用xz
```

**gzip**

```shell
gzip option file

命令行参数
-d 解压
-t 测试压缩包
-v 显示过程
-q 无输出
-c 输出到标准输出，常用于管道操作
-1 最快，最小压缩率
-9 最慢，最大压缩率
```

**bzip2**

```shell
bzip2 option file

命令行参数
-d 解压
-z 压缩
-k 保留输入文件
-t 测试压缩包
-v 显示过程
-q 无输出
-c 输出到标准输出，常用于管道操作
-1 最快，最小压缩率
-9 最慢，最大压缩率
```

**xz**

```shell
xz option file

命令行参数
-d 解压
-z 压缩
-k 保留输入文件
-t 测试压缩包
-v 显示过程
-q 无输出
-c 输出到标准输出，常用于管道操作
-0 最快，最小压缩率
-9 最慢，最大压缩率
```

**zstd**

```shell
zstd option file -o file

命令行参数
-d 解压
-k 保留输入文件（默认）
--test 测试压缩包
-v 显示过程
-q 无输出
-c 输出到标准输出，常用于管道操作
-1 最快，最小压缩率
-19 最慢，最大压缩率
```

**zip/unzip**

```shell
zip option file

命令行参数
-u 仅更新以及添加的文件
-q 不显示过程
-v 显示过程
-T 测试压缩包
-1 最快压缩，最小压缩率
-9 最慢压缩，最大压缩率
```

```shell
unzip option file

命令行参数
-p 解压到管道
-l 列出包含的文件
-t 测试压缩包
-p 更新文件
-q 不显示过程
-v 显示过程
-o 直接覆盖文件
```

#### 1.1.15 sort

对文件内容排序

```shell
sort file1.txt

命令行参数
-n 按数字识别并排序
-g 按浮点/科学计数法排序
-M 按月份简写排序
-b 忽略起始空白
-f 忽略大小写
-o file 写入到指定文件
-r 升序改降序
-t ':'指定分隔符
-k 指定排序字段
```

#### 1.1.16 grep

在一串字符中查找匹配的行

```shell
grep options pattern file.txt
cat file.txt | grep option pattern
egrep regexp file.txt

pattern可以为正则表达式

命令行参数
-v 反选输出
-n 显示行号
-c 匹配行数
-e pattern 指定多个模式
```

#### 1.1.17 which和type

which和type可以用于在bash可执行文件路径变量下查找指定的文件，另外type还可以用于指示一个命令是否是内建命令

```shell
which lsblk
type cd
```

#### 1.1.18 chmod和umask

chmod可以更改文件的权限，而umask可以更改当前创建文件时使用的默认权限。chmod的三个权限分别使用u，g，o表示

**在linux中，-代表普通文件，l代表链接，d代表目录，b代表块设备，c代表字符设备**

**一般的权限可以使用三位八进制表示，比如rwxr-xr--可以表示为754**

**linux的权限除rwx以外，x位常见的还有t和s。s代表运行时重新设置UID和GID，常用于sudo等，而t代表保留文件或目录**

```shell
chmod u+x ./test1.sh
chmod 777 ./test2.sh
```

使用umask时，遮挡指定权限位，比如022，设置权限755。0022的第一位八进制为粘着位，分别代表使能SUID，SGID以及粘着位。

**SUID指的就是文件被用户使用时会以文件属主身份运行，SGID同理，但是也会使得一个目录下创建的文件全部使用目录的属组，而粘着指的就是进程结束以后文件还驻留在内存**

```shell
umask 0022
umask 022
```

#### 1.1.19 chown和chgrp

```shell
chown k file.txt
chgrp sample file.txt
```

#### 1.1.20 date

用于显示时间

```shell
date +%M%S
date --date="@2147483647" #计算一个具体的UNIX时间对应的日期与时间

常用格式
%a %A 星期简写以及全称
%b %B 月份简写以及全称
%Y %y 年份
%m 月份，补0
%d 日期，补0
%u 星期，1..7
%H 小时，24，补0
%I 小时，12，补0
%P %p AM或PM
%M 分钟，补0
%S 秒种，补0
%N 纳秒
%s 从UNIX零点开始的秒数
%j 一年中的第几天
```

### 1.2 系统管理

#### 1.2.1 ps

显示当前进程

```shell
ps

命令行参数

UNIX
过滤
-A -e 显示所有进程
-a 列出除控制进程以及无终端进程以外所有进程
-d 列出除控制进程以外的进程
-C cmdlist 列出所有在cmd列表中的进程（命令名，如xinit）
-G -g grplist 列出所有在group列表中的进程（组名或组ID）
-U userlist 列出属主uid在userlist中的进程（用户名或用户ID）
-u userlist 显示有效用户uid在userlist中的进程
-p pidlist 显示PID在pidlist中的进程
-s sessionlist 显示会话ID在sessionlist中的进程
-t ttylist 显示终端ID在ttylist中的进程
显示格式
无参 显示默认参数（PID,TTY,TIME,CMD）
-o format 仅显示format规定输出列
-O format 显示默认输出列以及format规定输出列
-F 显示完整格式（default+UID,PPID,C,SZ,RSS,PSR,STIME）
-M 显示安全信息（default+LABEL）
-c 显示额外调度器信息（default+CLS,PRI）
-j 显示任务信息（default+PGID,SID）
-l 显示长列表（default+F,S,UID,PPID,C,PRI,NI,ADDR,SZ,WCHAN）
-z 显示安全标签（SELinux）
-H 层级显示
-n namelist WCHAN显示的值
-L 显示进程的线程

BSD
过滤
T 显示于当前终端有关
a 显示和任意终端有关
g 显示所有，包括控制进程
x 显示所有，包括无终端
r 仅显示运行中
U 属主用户UID
p 进程PID
t 终端tty号
显示格式
O 格式
z 安全信息SELinux
j 任务信息
l 长模式
o format 仅format
----新增格式----
s 信号格式
u 基于用户
v 基于虚拟内存
N namelist WCHAN显示的值
O order 显示顺序
S 将子进程数据加到父进程上
c 显示真实命令名称
e 显示命令的环境变量
f 分层显示
h 不显示头信息（表头）
k sort 按某列排序
n 用户ID和组ID
H 将线程按进程显示
m 在进程后显示线程
L 列出所有格式指定符
```

显示的各参数含义\
**UID:**      进程属主\
**PID:**      进程ID\
**PPID:**     父进程ID\
**C:**        CPU利用率\
**STIME:**    启动时时间\
**TTY:**      终端号\
**TIME:**     累计CPU时间\
**CMD:**      程序名\
**F:**        进程系统标记\
**S:**        进程状态（D不可中断休眠，S可中断休眠，I空闲的内核进程，R运行或可运行，Z僵尸进程，T停止）\
**PRI:**      优先级，越小的数字代表越高的优先级\
**NI:**       谦让度\
**ADDR:**     内存地址\
**SZ:**       swap所需大致空间\
**WCHAN:**    进程休眠的内核函数地址\
**PSR:**      运行在哪颗CPU上

BSD格式\
**VSZ:**      进程占内存大小\
**RSS:**      未swap时占用的物理内存\
**STAT:**     双字符状态码（UNIX格式加第二个字符，<高优先级，N低优先级，L有页面锁定在内存，s控制进程，l多线程，+运行在前台）

**常用用法参数：**

UNIX格式：
```shell
显示STIME，PSR
ps -l 
显示S，UID，PPID，PRI，NI，ADDR，SZ
ps -F
显示所有
ps -e
显示一个用户的进程
ps -U userid
显示一个终端的进程
ps -t tty1
显示除控制进程以外的进程
ps -d
```

BSD格式：
```shell
显示USER，PID，CPU，MEM，VSZ，RSS，TTY，STAT，START，TIME，CMD
ps u
显示F，UID，PID，PPID，PRI，NI，VSZ，RSS，WCHAN，STAT，TTY，TIME，CMD
ps l
显示线程
ps m
累计进程占用资源
ps S
按指定列排序显示
ps k sort
所有进程，包括控制
ps g
所有进程，包括无终端
ps x
所有终端
ps a
运行中
ps r
```

#### 1.2.2 top

和ps类似，区别是top是实时监测显示

部分显示参数注释\
**VIRT**      占用虚拟内存总量\
**RES**       占用物理内存总量\
**SHR**       共享内存总量\
**S**         进程状态（D休眠可中断，R运行，S休眠，T跟踪或停止，Z僵尸进程）\
**TIME+**     累计CPU时间

#### 1.2.3 kill和killall

向进程发送信号

kill使用PID指定进程，killall使用进程名指定进程

```shell
kill -s SIGNAL 2350
killall -s SIGNAL http*

可用信号
HUP 挂起
INT 中断
QUIT 结束运行
KILL 无条件终止
SEGV Segment错误
TERM 尽可能终止
STOP 无条件停止运行但不终止
TSTP 停止暂停并在后台运行
CONT STOP或TSTP后继续运行
```

#### 1.2.4 mount和umount

挂载文件系统

```shell
mount /dev/sdxx /mnt

命令行参数
-a -aF 挂载所有在/etc/fstab里的文件系统
-f 模拟挂载
-v 显示挂载过程
-l 自动添加标签
-n 挂载但不注册到/etc/mtab
-p num 加密挂载
-o 指定挂载选项（ro只读,rw读写,user,check=none,loop）
-L label
-U uuid
-t 指定文件系统类型
```

#### 1.2.5 du和df

```shell
du /directory
查看一个目录占用的空间

命令行参数
-h 自动换算为k,M,G
-s 统计

df /directory
查看一个目录所在文件系统剩余空间

命令行参数
-h 自动换算为k,M,G
```

#### 1.2.6 用户管理

**useradd添加用户**

```shell
useradd k

常用命令行参数
-m 添加同时穿创建home目录
-e 设置账户过期时间，使用YYYY-MM-DD指定
-g group 设置登录组
-G group1 group2 设置除登录组以外的附属组
-n 创建一个和用户同名的新组（默认行为）
-u 指定uid
```

**userdel删除用户**

```shell
userdel k

常用命令行参数
-r 同时删除home
```

**usermod修改用户字段**

```shell
usermod k
usermod -G sample k 

常用命令行参数
-c 添加备注
-e 修改过期日期
-g 修改默认登录组
-G 修改附属组
-l 修改登录名
-L 锁定账户
-p 修改密码
-U 解除锁定
```

**passwd/chpasswd修改密码**

```shell
passwd k
chpasswd k:123456
```

**chsh和chfn**

chsh可以修改默认登录shell，而chfn用于修改/etc/passwd

```shell
chsh -s /bin/zsh k
```

**groupadd创建组**

```shell
groupadd sample
```

**groupmod修改组**

```shell
groupmod sample

常用命令行参数
-g 修改GID
-n 修改组名
```

### 1.3 shell的基本概念以及用法

#### 1.3.1 命令的运行以及shell的父子关系

命令进程由bash创建，bash为一个命令进程的父进程。这点可以从ps的PPID参数看出。在命令提示符之后输入bash（或其他shell，如zsh等），可以启动一个子shell，通过`exit`命令退出并返回父shell。

查看目前是最底层shell之上第几层子shell，使用变量$BASH_SUBSHELL查看即可。

#### 1.3.2 连续执行，进程列表

类似C语言中的语句，shell可以使用 **;** 分隔一行中的多个命令，比如

```shell
cd ../ ; pwd ; ls ; cd ~
```

而加上圆括号，则会启动一个子shell执行这些命令，这就是进程列表

```shell
( cd ../ ; pwd ; ls ; cd ~ )
```

而花括号不同，其只相当于分隔符的作用，命令在当前shell执行，并且注意每一个命令后面都要加上分号，这也表明其包含的只是一个顺序执行命令的序列

```shell
{ cd ../ ; pwd ; ls ; cd ~ ;}
```

#### 1.3.3 后台运行

可以将一个或一行命令置入后台运行，在命令最后加上 **&**，可以在当前shell启动一个进程并将其转到后台，此时用户可以进行其他作业，但后台进程依然会在当前终端输出

```shell
ls & 
```

#### 1.3.4 协程

不同于后台运行，协程会在后台新建一个子shell并运行程序，执行结果不会在当前终端显示

```shell
coproc ls
```

也可以对协程命名

```shell
coproc MyTask { sleep 10 ; ls }
```

生成shell的成本并不低，所以尽量减少子shell的级数

#### 1.3.5 内建命令和外部命令

Bash的外部命令一般可以在/bin找到，而内建命令由bash本身实现。典型的内建命令有`cd`，`exit`，`history`等。

可以使用type查看一个命令是否为内建或外部命令，有的命令同时有内建和外部实现，可以在`type`后加上`-a`参数

```shell
type -a pwd
type -a echo
```

#### 1.3.6 history查看命令记录

使用`history`查看命令记录，或删除命令记录，记录条数由$HISTSIZE决定

```shell
history 

命令行参数
-c 清除记录
```

重复执行上一条命令，只要使用`!!`命令

```shell
!!
```

#### 1.3.7 alias命令别名

查看以及设置当前的命令别名，**注意赋值表达式不能有空格**

```shell
alias 

命令行参数
command='command alias'

常用
alias ls='ls --color=auto'
```

## 2 shell脚本基础

包含了基本shell脚本编写的各方面

### 2.1 变量

#### 2.1.1 局部变量

shell下的变量一般使用`$`引用。局部变量一般使用小写字母，只对当前shell可见，**对子shell也不可见**，可以使用`set`查看当前的所有局部、用户定义和全局变量

```shell
set
```

设置局部变量，**注意赋值表达式不能有空格**

```shell
my_var=sample
my_var="sample with space"
```

删除局部变量，使用`unset`

```shell
unset my_var
```

#### 2.1.2 全局变量

**全局变量对父shell的所有子进程可见**，可以使用`env`查看所有全局变量，`printenv`也可以用于查看个别变量，也可以通过`echo`返回使用$引用的变量。bash启动时的变量在 */etc/profile* 设定，或在带有PAM的系统中，在 */etc/environment* 或 *~/.pam_environment* 设定，bash启动在 *~/.bashrc* 更改。登录shell有/etc/profile，而创建的交互shell不会访问 */etc/profile* ，只会访问 *~/.bashrc*

```shell
env
printenv HOME
echo $HOME
```

设置全局变量，可以将一个局部变量使用`export`设定为全局变量，**注意赋值表达式不能有空格**

```shell
MY_VAR="sample global"
export MY_VAR
```

全局变量只能在父进程删除，使用`unset`

**常用全局变量：**

*SHELL:* 默认shell

*HOME:* 当前用户主目录

*PATH:* shell用于查找命令的路径，追加方法：`PATH=$PATH:my_path`

*USER:* 当前用户

*PS1:* 命令提示符格式

**bash自有变量（只可通过$引用）：**

*UID:* 当前用户ID

*BASH_SUBSHELL:* shell嵌套级别

*BASHPID:* 当前bash的PID

*COLUMNS:* 当前终端可用宽度

*HOSTNAME:* 当前主机名

*HOSTTYPE:* 当前使用主机的CPU指令集

*LINENO:* 当前执行的行号

*OLDPWD:* 之前的目录

*PPID:* 父进程PID

*PWD:* 当前目录

*RANDOM:* 返回一个0~32767的随机数

*SECONDS:* 启动shell到现在的秒数

#### 2.1.3 结构变量

**数组变量：** 可以使用圆括号将多个值括起来，使用下标访问，修改或使用`unset`置空。但是注意不是所有shell都对数组支持良好

```
myarray=(one two three four)
echo ${myarray[0]}
echo ${myarray[*]}
```

### 2.2 脚本基本构成

脚本使用`#!`指定要使用的shell，而使用`#`将一行注释

```shell
#!/bin/bash
# This is a comment
```

假设要显示指定字符，使用echo命令即可，如果不想换行可以添加`-n`

```shell
echo This is a test
echo -n This is a test
echo "This is a 'test'"
```

### 2.3 使用一个命令的输出结果

可以使用`$()`或者``将想要的命令括起来，并取其输出。可以将命令的输出赋值到一个变量

```shell
output=$(ls -a)
output=`ls -a`
```

一个实用的例子，就是自动命名文件

```shell
name=log-$(date +%m%d%H%M%S).txt
touch $name
```

### 2.4 重定向

#### 2.4.1 输出重定向：

将命令的输出重定向到一个文件

```shell
ls -a > ls.txt #新建或覆写
ls -a >> ls.txt #追加到文件尾
```

#### 2.4.2 输入重定向：

将文件重定向到一个命令的标准输入，比如用于统计字数的wc命令

```shell
wc < test.txt
```

内联重定向，可以指定输入的终止符，到达终止符后命令即停止并输出结果

```shell
wc << END
> string1
> string2
> END
```

其中，次提示符由`$PS2`指定，这里是`>`

### 2.5 管道

管道可以看作内存中的一个FIFO缓冲区，将一个程序的标准输出连接到另一个程序的标准输入。

```shell
ls /bin | less #使用查看/bin下的文件
```

```shell
xz -dkc package.tar.xz | tar -xv #解压缩，和tar -Jxvf作用等价
```

### 2.6 整数、浮点以及字符串运算

#### 2.6.1 传统的Bourne shell格式

使用`expr`（/bin/sh）

```shell
expr arg operator arg

可用运算符
算数运算（返回运算结果）： + - * / %
逻辑运算（返回一个arg值）： & |
比较运算（返回整数0或1）： > >= < <= == !=
```

注意，所有在shell中有特殊含义的运算符，比如\*，/，&，|，>，< 都要加上转义符`\`才可正常工作

```shell
字符串运算

匹配正则表达式，返回匹配到的符合的字符串的字符数总和
expr STRING : REGEXP
expr match STRING REGEXP

子字符串，返回从START开始的LENGTH个字符，索引从1计数
expr substr STRING START LENGTH
例如 expr substr hello 1 4 返回hell

计算字符串长度
expr length STRING

查找一个CHARS第一次出现的位置
expr index STRING CHARS
例如 expr index hello l 返回3
```

#### 2.6.2 bash格式

使用`$[]`（/bin/bash），**特殊符号不需要转义**

```shell
var=$[num operator num]

例如sample=$[($var1 + $var2) * $var3]
```

#### 2.6.3 双括号

常用，`(())`用于算术以及逻辑运算， `[[]]`用于字符串比较，见if-then判断部分

#### 2.6.4 浮点计算

以上方法仅适用于整数运算，浮点运算需要使用专用的工具，在类UNIX系统下常见的有bc

使用bc时必须对内建变量scale赋值，以指定小数点位数

使用命令替换，echo配合管道符

```shell
var=$(echo "scale = 2; var1 = 3; var2 = 7; var1 + var2 + 5.33" | bc)
```

使用内联输入重定向

```shell
var=$(bc << EOF
    scale = 2
    var1 = 3
    var2 = 7
    var1 + var2 + 5.33
    EOF
)
```

### 2.7 退出状态

可以使用变量`$?`查看上一个命令的退出状态

```shell
echo $?

常见状态码
0 成功
1 一般未知错误
2 不适合的shell命令
126 命令无法执行 
127 命令未找到
130 已通过^C终止
255 正常退出码之外的状态码
```

也可以使用`exit`指定退出码

```shell
exit 5
```

### 2.8 判断

if-then结构，如果if之后的命令成功运行（注意是返回0，且只能是命令），则执行then之后的语句

```shell
if CMD
then 
    CMDs
elif CMD
then 
    CMDs
else
    CMDs
fi
```

if之后的命令可以使用test以实现条件满足性的检测，比如一个变量是否为空

```shell
if test $var
then 
    CMDs
fi
```

以上用法不常用，一般还是使用方括号的格式替代test命令

```shell
if [ condition ]
then
    CMDs
fi
```

并且可以使用`&&`或`||`符合条件

```shell
if [ condition1 ] && [ condition2 ]
then 
    CMDs
fi
```

常用的除if-then以外，判断结构同样支持类似其他语言的`case`

```shell
case $var in 
pattern1 | pattern2)
    CMDs;;
pattern3)
    CMDs;;
*)
    CMDs;;
esac
```

case只可以使用变量作为其判断依据，并且可以使用或`|`

**一般常见的条件检测（condition域）**

#### 2.8.1 整型数值

整型数值比较，shell不使用大于小于号

```shell
n1 -eq n2 相等
n1 -gt n2 大于
n1 -ge n2 大于等于
n1 -lt n2 小于
n1 -le n2 小于等于
n1 -ne n2 不等于
```

示例

```shell
if [ $var -eq 1 ]
then 
    var=$[$var + 1]
fi
```

#### 2.8.2 字符串比较

注意大于小于号必须要在前面添加转义符。另外，字符串的比较是根据ASCII的顺序，大写字母被认为小于小写字母

```shell
str1 = str2 相等
str1 != str2 不相等
str1 \< str2 小于
str1 \> str2 大于
-n str1 长度非0
-z str1 长度0
```

示例

```shell
if [ $str1 \> $str2 ]
then 
    echo $str1
fi
```

#### 2.8.3 文件处理

```shell
-e file 存在
-d file 存在并且是一个目录
-f file 存在并且是一个文件
-s file 存在并非空
-r file 存在并可读
-w file 存在并可写
-x file 存在并可执行
-O file 存在并属于当前用户
-G file 存在且属于当前用户默认组
file1 -nt file2 file1比file2新
file1 -ot file2 file1比file2旧
```

示例

```shell
if [ -f file.txt ]
then 
    rm -f file.txt
fi
```

#### 2.8.4 双括号

格式：使用`(())`和`[[]]`

**双圆括号**`(())`语句一般用于特殊算术逻辑运算以及比较赋值，支持位运算。可以在`if`之后以及作为一般语句使用。可以替代`test`以及其等价`[]`，但它不是`test`

```shell
if (( $var1 == $var2 ** 2 ))
then 
    (( var1 = $var2 + 1 ))
fi
```

如上，双括号在一般语句中用于赋值，而在if之后用于比较，因为其所有的执行仅返回执行码。可以使用的算术符号如下，不需要转义

```shell
全部用于(())以内

+ - * / % 一般算术符
! && || 逻辑运算
~ & | << >> 位运算
< > == != >= <= 比较
= 赋值
val++ val-- ++val --val 加一或减一
```

**双方括号**`[[]]`用于字符串比较，返回执行结果码（不是所有shell都良好支持）

```shell
if [[ $str == e* ]]
then 
    echo "yes"
fi
```

其中e*是一个pattern

> 说到这里，shell中这么多类型括号的使用非常令人迷惑。整理一下：\
`${}`将一个变量括起来，常用于数组变量\
`$()`用于提取一个命令的执行结果输出，常用于赋值\
`$[]`可以看成`expr`的等价，用于计算整数以及比较，通过标准输出返回结果\
`{}`用于一个命令区块，执行一串命令\
`()`用于命令列表，使用`;`分隔\
`[]`可以看成`test`的等价，用于处理整数、字符串以及文件相关，返回执行结果码\
``(())``用于整数运算、特殊运算、赋值以及比较，返回执行结果码，但是并不是`test`的等价\
``[[]]``用于字符串比较，返回执行结果码

### 2.9 迭代/遍历

一般使用`for`进行迭代。**由于需要对迭代变量进行赋值，这里的变量不添加引用符`$`，这和`case`不同**，不要将两者混淆。另外`for`的迭代变量在迭代后会一直保持有效

```shell
for var in list
do
    CMDs
done
```

示例

```shell
for i in GNU\'s NOT Unix 
do
    echo $i
done
```

```shell
string="GNU's NOT Unix"
for i in $string
do 
    echo $i
done
```

结果

```
GNU's
NOT
Unix
```

**同样，`for`也可以使用shell展开的通配符，用于遍历文件，和使用$(ls /dir/)等价**

```shell
for i in /dir/*
do 
    file $i
done
```

**注：在默认情况下，bash将空格，制表符，以及换行符作为字段分隔的依据，这样导致`for`遇到含空格的变量后就会出现问题。可以有两种问题解决，一个是使用`""`，另一个是修改`$IFS`变量**

示例

```shell
for i in GNU\'s "N O T" Unix
do 
    echo $i
done
```

或在bash下

```shell
IFS=$'\n' # 将换行符'\n'作为唯一字段分隔符
IFS=$'\n':; # 将'\n'以及冒号、分号作为字段标识符。使用冒号可以在读取例如/etc/passwd时发挥妙用
```

### 2.10 循环

#### 2.10.1 C风格for

C风格的`for`的使用方法是特制的，并不符合传统shell中变量使用的常识，使用应当小心。虽然使用双括号，但是并不能使用双括号的原理去理解。

```shell
for (( i=1, j=15; i < 11; i++, j-- ))
do
    echo $i,$j
done
```

并且如上，C风格`for`支持**多于一个迭代变量**

#### 2.10.2 while

`while`使用和if-then相同的`test`命令，根据执行返回的状态码判断是否继续循环

```shell
while CMD
do
    CMDs
done
```

示例

```shell
while CMD
do
    CMDs
done
```

`while`可以使用多个测试命令

示例

```shell
while echo $i
    [ $i -ge 1 ]
do
    echo "message"
    i=$i-1
done
```

#### 2.10.3 until

`until`和`while`格式相同，**区别在于`until`只在当测试命令返回异常（非0）时才继续迭代**，当测试命令返回0时才终止

```shell
until [ $i -gt 15 ]
do
    i=$i+1
done
```

#### 2.10.4 break

`break`是一个语句，用法和C语言中的break同理，**区别是可以通过`break n`指定要跳出的循环层级数**

示例

```shell
while [ $i -ge 0 ]
do
    j=4

    while [ $j -ge 0 ]
    do
        if [ $i -eq 3 ]
        then 
            break 2
        else
            j=$j-1
        fi
    done

    i=$i-1
done
```

#### 2.10.5 continue

`continue`同样和C语言中的continue同理，如果满足一定条件就会跳过之后的命令

示例

```shell
while [ $i -ge 0 ]
do
    if [ $i -eq 5 ]
    then
        i=$i-1 
        continue
    else
        i=$i-1
    fi
done
```

#### 2.10.6 处理输出

可以将一个循环的输出统一处理，通过重定向或管道

示例

```shell
while [ $i -ge 0 ]
do
    echo "This is $i"
    i=$i-1
done > test.txt
```

管道同理

### 2.11 用户输入

#### 2.11.1 命令行参数

**shell使用`$#`获取输入的命令行参数数量，使用`$0`引用执行当前命令时的输入（比如`./test.sh`），使用`$1`引用第1个命令行参数，使用`$2`引用第2个命令行参数**，以此类推。命令行参数默认使用空格作分隔，如果要传入带空格的参数就要使用引号

脚本的名称可以使用命令`basename $0`提取，通常用于创建两个名称不同而内容相同的脚本，用于功能区分

此外，**最后一个命令行参数可以使用`${!#}`提取**（花括号以内不可以使用`$`，只能使用`!`代替）

**使用不符合要求的命令行参数会导致脚本出错。为提高程序健壮性，要养成对参数做有效性检查的习惯，比如使用`[ -n $1 ]`检查参数是否为空**

#### 2.11.2 遍历所有参数

遍历参数除了直接使用`$#`和`$1`等之外，还可以使用`$*`以及`$@`。两者都记录了所有参数，但是`$@`更加常用。**`$@`将所有输入参数作为一个字符串中的单独单词，可以使用迭代`for`对其进行遍历访问**。而`$*`则相反，将所有参数作为一个整体，需要使用特殊方式访问

示例

```shell
for i in "$@"
do 
    echo $i
done
```

**使用`shift`指令遍历**

`shift`可以将从`$1`开始的所有参数向左移动一格，这也是一种遍历的方法

示例

```shell
while [ -n $1 ]
do 
    echo $1
    shift
done
```

### 2. 信号

### 2. 作业控制

### 2. 调整优先级

### 2. 设置定时运行


## 3 shell脚本进阶

shell脚本的一些高级特性

### 3.1 函数

### 3.2 sed和gawk

### 3.3 正则表达式

### 3.4 使用dialg生成伪图形界面