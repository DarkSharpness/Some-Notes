# AVR单片机深入学习

基于Arduino，了解AVR单片机的底层工作原理，像学8051一样学习AVR，摆脱对Arduino IDE的依赖，仅仅利用Arduino廉价且普及的硬件

## 参考资料

[Microchip AVR](https://www.microchip.com/en-us/products/microcontrollers-and-microprocessors/8-bit-mcus/avr-mcus)

[Microchip Developer](https://www.microchipdeveloper.com)

[Arduino资料文档](src/210702a01/)


## 0 Arduino硬件解析

由浅入深的硬件分析

## 0.1 Arduino硬件博物馆：各版本Arduino外观以及对比

### 0.1.1 Arduino UNO

UNO作为Arduino最经典的一款开发板，分为很多个版本，因为各种克隆版、授权代工、改良版等等实在太多了。

> 这里遵循TB商家的命名习惯做一些定义：
>
> **官方版**代指**所有遵循官方电路以及PCB设计生产的开发板**，这些开发板包括正版开发板（TB商家一般称为**原装进口正版**、**意大利官方英文版**等），国内授权代工版（目前已停产，一般称为**官方中文版**等），以及一些国内厂家根据官方网站提供的PCB文件生产的官方盗版（一般称为**官方版本**），这些开发板共同的特点就是usb电路部分都是使用一片正方形的ATmega16u2或8u2的单片机（需要下载固件），并且一般会印上Arduino的logo
>
> **改良版**代指**国内一些厂家由官方电路更改而来，重新自行设计PCB之后生产的开发板**（一般称为**改良版**或**改进版**）。这些改良版的共同特点是usb部分使用了南京沁恒的CH340芯片，是一个16脚长方形芯片，可以大大降低成本（ATmega16u2和ATmega328P一样是个完整功能的AVR单片机，价格较高）。而主控芯片一般使用贴片ATmega328P，也有少部分和官方版一样使用插槽安装直插式DIP芯片，并且一般不会打印Arduino的logo
>
> **克隆版**代指所有非官方工厂（包括官方代工）来源的开发板，包括了官方盗版以及改良版。现在新款的原装和代工版的PCB一般使用蓝绿色油墨

**官方版**

官方版UNO有新版UNO R3和旧版UNO两种，其中旧版已经非常少见。在Arduino中AVR单片机基本都是使用的16Mhz的晶振

新版UNO R3电路[查看](src/210702a01/Arduino_Uno_R3.pdf)

旧版UNO电路[查看](src/210702a01/Arduino_Uno.pdf)

官方新版与旧版电路区别主要在5V稳压芯片以及13脚的LED电路上

> 旧版5V稳压芯片采用一片MC33269D-5.0，这个5V三端稳压有两种不同的封装，所以图中画了两个，实际只安装一种封装的芯片
>
> ![](images/210702a001.png)
> 
> 新版R3的5V稳压芯片采用一片AMS1117-5.0
>
> ![](images/210702a002.png)
>
> 旧版13脚LED直接和328P的IO（PB5）相连，通过电阻限流
>
> ![](images/210702a003.png)
>
> 新版R3的13脚LED利用了板载运放LM358中未使用的一个运放，作为一个跟随器用，利用运放输入高阻抗特性隔离LED负载，可以减小PB5口的电流负载，同时13脚理论阻值无穷大
>
> ![](images/210702a004.png)
>
> 此外，新版相对于旧版在电源口部分添加了IOREF引脚，用于为扩展板提供参考IO电平

原装英文版（引自Arduino官网）

![](images/210702a005.jpg)

背面

![](images/210702a009.jpg)

> 进口的价格非常高，同样价格可以买一打克隆版了。当然土豪不差钱无所谓

官方中文版（自摄）

![](images/210702a006.jpg)

背面

![](images/210702a010.jpg)

> Arduino官方授权中国厂商代工。这块中文版前主人将其用于小车电机控制，由于未知原因导致16u2芯片固件异常无法烧录，而328P芯片已被取下转移至旧版UNO上使用。之后有修复教程，以及16u2的开发（事实上UNO没有328P也可以当开发板用，功能和之后提到的Leonardo类似，可以模拟键盘，但是可扩展性稍差）

官方盗版（自摄）

![](images/210702a007.jpg)

背面

![](images/210702a011.jpg)

> 陪伴我时间最长的一块开发板，从刚上高中用到现在。这些克隆版缺点就是焊接工艺较差，元器件歪斜，但是工作稳定性没什么区别

旧版官方盗版（自摄）

![](images/210702a008.jpg)

背面

![](images/210702a012.jpg)

> 捡到的板子。字体形状比较奇怪，应该是当时的厂商没有相应的字体文件。比新版少一些接口，usb是使用的ATmega8u2而非16u2，复位键在中间，三端稳压不一样，功能方面和新版R3基本相同

**改良版**

改良版电路[查看](src/210702a01/Uno_ch340.jpg)

> 改良版就是将原ATmega16u2部分换成较为廉价的CH340，并且使用\#DTR作为复位信号

改良版（自摄）

![](images/210702a030.jpg)

背面

![](images/210702a031.jpg)


### 0.1.2 Arduino Nano

和UNO一样，Nano也有多种。Nano事实上是缩小版的UNO，同样使用ATmega328P，区别在usb部分。官方版一般使用FT232RL

**官方版**

原装英文版（引自Arduino官网）

![](images/210702a017.jpg)

官方盗版（自摄）

![](images/210702a032.jpg)

背面

![](images/210702a033.jpg)

> 官方版usb部分都采用FTDI的FT232RL

**改良版**

改良版（自摄）

![](images/210702a034.jpg)

背面

![](images/210702a035.jpg)

> 改良版usb部分使用CH340


### 0.1.3 Arduino Leonardo

Leonardo因为没有单独的usb电路，所以没有所谓改良版。主控采用ATmega32u4，封装可能不同。另有Arduino Micro，就是Leonardo的缩小版，它和Leonardo的关系类似于UNO和Nano的关系

官方版电路[查看](src/210702a01/Leonardo_R3.pdf)

**官方版**

原装英文版（引自Arduino官网）

![](images/210702a018.jpg)

背面

![](images/210702a019.jpg)

官方盗版（自摄）

![](images/210702a036.jpg)

背面

![](images/210702a037.jpg)


### 0.1.4 Arduino Mega 2560

Mega2560使用ATmega2560-16AU作为主控芯片，本质和328P差不多，IO较多

这里只给出官方图片

**官方版**

原装英文版（引自Arduino官网）

![](images/210702a020.jpg)

背面

![](images/210702a021.jpg)


### 0.1.5 Arduino DUE

Arduino DUE主控芯片为SAM3X8E，使用32位ARM Cortex-M3核心而非AVR，IO电平为3.3V，不属于常规AVR开发板，比起UNO、Mega 2560等传统Arduino，和STM32更加相近，这里仅展示其新旧两种版本

新版DUE电路[查看](src/210702a01/Arduino_Due_V2.pdf)

旧版DUE电路[查看](src/210702a01/Arduino_Due.pdf)

> DUE功耗较大，新版以及旧版使用的5V供电电路不同。旧版使用的是LM2734Y构建的分立开关电源，有一个较大的黑色方形电感，缺点是容易啸叫。新版采用集成式开关电源MPM3610

**官方版**

原装英文版（引自Arduino官网）

![](images/210702a013.jpg)

背面

![](images/210702a014.jpg)

> 原装进口一样也是很贵，一般要350左右，不差钱的可以考虑

旧版官方盗版（自摄）

![](images/210702a015.jpg)

背面

![](images/210702a016.jpg)

> 相比官方原版，没有安装RTC晶振（32.768kHz）。入手时全新50多米，比很多2560还便宜一些


## 0.2 Arduino电路结构解析

只给出UNO以及Leonardo两种开发板的电路分析，其他经典AVR衍生版基本同理

### 0.2.1 UNO

这里再放一下UNO R3的[pdf](src/210702a01/Arduino_Uno_R3.pdf)

> 官方版本的UNO事实上使用了两片AVR单片机，一片是直插式DIP28的ATmega328P，另一片是贴片TQFP32的ATmega16u2。ATmega16u2作为usb芯片拥有usb所需的电路模块，而其他方面较328P较弱。
>
> ATmega16u2相比328P拥有usb模块，而缺少了计数器/定时器2，I2C模块以及AD模数转换

**电源**

![](images/210702a025.png)

> 由上图分析。Arduino UNO支持从DC口以及USB供电，主要电路以及MCU全部使用5V供电，3.3V供电仅仅用于为LM358（作为比较器使用）提供参考电压（左上角），当然也可以通过3.3V接口向外设供电。通过DC供电时，设AMS1117输出5V正常，LP2985输出3.3V，那么只有当VIN大于6.6V时，MOS管FDN340P才会截止，此时完全使用1117的5V供电。如果此时VIN输入电压小于6.6V（或VIN未连接），此时MOS管导通，主要由USB供电
>
> 设置这个电路就是为了防止在同时连接VIN和USB时USB口电流倒灌损坏电脑
>
> 328P分为数字部分供电以及模拟部分供电，这里都使用5V，其中模拟部分AVCC输入串联一个10uH电感

**GPIO**

![](images/210702a026.png)

> UNO引出了328P所有的引脚。这些引脚可以做普通IO功能。其中，PC兼做AD输入以及I2C；PD包含了UART，外部中断，计数器输入以及比较器输入；PB包含了SPI
>
> UART通过1k电阻直接和16u2相连。AREF为ADC模拟参考电压输入，IOREF直连5V为扩展板提供IO参考电压。SPI另外引出到一个6pin接口ICSP，用于AVRISP烧录，一般用于烧录空芯片、修复BootLoader功能

**USB电路以及复位电路**

![](images/210702a027.png)

> USB部分以ATmega16u2为中心。16u2同样引出了专门的ISP接口可用于烧录固件，另外的4个引脚在ISP（ICSP1）接口旁边，一般不焊接排针。usb接口通过22欧电阻连接到16u2，16u2没有专门的复位按钮，只能通过ICSP1接口复位。16u2和328P一样使用了一个16MHz的晶振，封装不同。
>
> 16u2和328P之间有3条线连接，除UART之外（TX、RX指示灯使用16u2另外的GPIO），16u2的PD7还连接到了328P的**复位电路部分**，在通过usb下载程序时16u2会自动复位328P
>
> 通过观察可以发现，328P的复位引脚通过10k电阻上拉到5V，同时通过100nF电容连接到32u4的PD7，PD7通过1k电阻接地。
>
> 上电后，**16u2的PD7输出低电平**，328P的RESET脚为0V，之后10k电阻为100nF电容充电，\#RESET失效，328P开始工作。**下载时，16u2的PD7给出一个正脉冲即可实现328P的复位**。此时电容C5两端都为5V而被放电。在正脉冲的下降沿后，328P的RESET引脚瞬间又被拉低到0V，328P复位，之后328P内部的BootLoader进入到ISP模式，烧录开始


### 0.2.2 Leonardo

Leonardo R3的[pdf](src/210702a01/Leonardo_R3.pdf)

Leonardo只有一片ATmega32u4，基本相当于拥有了16u2和328P的功能，下载程序原理和UNO完全不同，32u4的BootLoader可以直接从usb读取并更新代码，同时32u4可以编程变为任意的usb设备（UNO的16u2也可以，但是由于IO很多未引出所以一般利用价值不大）。另外32u4支持JTAG

**电源**

Leonardo的电源部分和UNO基本相同，不再赘述

**GPIO**

![](images/210702a028.png)

> Leonardo除用于UART指示灯的IO之外引出了32u4其他所有的IO。除GPIO作用外，PF还包括了ADC输入以及JTAG功能；PD部分包含了4个外部中断，以及部分ADC输入，UART，I2C，计数器输入，PWM输出（OCxx），互补PWM输出（OC4x）；PE包含了比较器输入，6号外部中断以及BootLoader的选择性执行（可通过熔丝位配置）；PC包含了PWM输出，互补PWM输出以及AD输入0；PB包含了SPI，PWM输出，互补PWM输出，AD输入11，外部中断等
>
> 同样，Leonardo也将32u4的ISP单独引出，用于ISP烧录

**USB电路以及复位电路**

![](images/210702a029.png)

> 同样，usb接口通过22欧电阻连接到32u4的usb输入。而32u4在下载时的复位机制和UNO完全不同，在通过usb下载时32u4使用的是软件复位而不是通过硬件复位，所以在Windows下面开发会发现Leonardo会自动插拔。而经过观察发现，RESET在默认状态下只有通过一个10k电阻上拉到5V，复位只有通过按下按钮或将ISP端口的RST拉低


## 1 AVR单片机深入分析

主要以ATmega328P/16U2/32u4为例，参考数据手册

## 1.1 AVR简介以及内存架构

AVR CPU核心结构如下

![](images/210702a038.png)

主要的存储设备包括通用寄存器，特殊寄存器，RAM，ROM，IO寄存器，熔丝位等

AVR使用了哈佛结构，将数据（SRAM）以及指令存储区（Flash）分开并且独立编址。内部可以看作使用了简单的两级流水（预取指和执行），仅支持LOAD/STORE访存，有专门的IN/OUT指令可以用于IO内存区域的读写，并且使用了大量的通用寄存器，多达32个

AVR单片机系统结构如下

![](images/210702a040.png)

可以看到，SRAM和程序Flash使用不同的数据总线，各自单独编址


### 1.1.1 内部寄存器以及位于IO空间的寄存器

**内部寄存器**

8位版AVR拥有32个8位通用寄存器（另有AVR32，是32位机），编号从**R0**到**R31**，其中**R27:R26**组成**X**寄存器可以用于寻址，同理**R29:R28**组成**Y**寄存器，**R31:R30**组成**Z**寄存器

> **SREG**状态寄存器：拥有**I**中断使能、**T**位操作寄存器、**H**半进位标记、**S**符号标记（**N xor V**）、**V**溢出标记、**N**负值标记、**Z**零值标记、**C**进位标记。发生中断时不会自动保存和恢复，需要由中断服务软件实现
>
> **PC**程序计数器：指令地址，长度和单片机Flash容量有关（328P有32k字节的Flash，PC为14位长（16k words）），用户不可直接访问。**注意，PC每增加1，对应Flash中的2字节，而不是1字节**，这和之后的数据寻址不同，数据寻址以字节为单位

**IO空间寄存器**

> **RAMPX RAMPY RAMPZ**：分别用于和**X**寄存器**R27:R26**，**Y**寄存器**R29:R28**，**Z**寄存器**R31:R30**连接，用于支持大于64kB的间接寻址（SRAM或Flash）
>
> **RAMPD**：用于和**Z**寄存器连接，支持大于64kB的直接寻址
>
> **EIND**：用于和**Z**寄存器连接，支持长跳转指令
>
> **SP**栈寄存器：堆栈指针，长度16位，有的只有8位（SPL）。堆栈**自上向下**增长，使用到堆栈操作的指令主要有`PUSH POP ICALL RCALL RET RETI`


### 1.1.2 内存结构以及寻址方式

**程序Flash**

![](images/210702a041.png)

由于AVR指令长度为16或32，CPU使用PC取指时在程序Flash中也是2字节对齐的。**Flash分为两个部分，Bootloader区和应用程序区，两个区域相对独立**，有各自的熔丝控制位，以及不同的安全保护措施

Flash可以通过`ELPM LPM SPM`指令进行字节数据访问，使用**Z**寄存器作为指针，而`ELPM`会添加上**RAMPZ**寄存器，可以访问大于64k的空间

在不同单片机中`SPM`指令的执行流程可能不相同，**Flash只能以Page为单位进行擦除，有些单片机可以以word（2字节）为单位写入，而另一些单片机不支持word为单位的写入，只能以Page为单位写入，这样的单片机中会有一个Page Buffer，需要将缓冲写满以后一次性写入到Page**。一般使用**Z**寄存器作为指针，而使用**R1:R0**作为数据寄存器

这些指令也可以用于熔丝位的访问

> 和STC的51单片机直接将Bootloader固件写死不同，AVR的Bootloader可以更改，Flash同样支持读时写技术（Read While Write）。Bootloader是一段程序，如果复位后进入ISP模式，可以在被CPU读取执行同时，CPU对Flash本身数据单元进行擦除与烧写操作，甚至是Bootloader本身的数据。这样CPU可以从任意有效数据输入端更新Flash的数据，比如UART，USB等。而从ICSP进行下载由硬件支持，不依赖于Bootloader，可以用于Bootloader的修复

**SRAM**

![](images/210702a039.png)

SRAM分为4个区间，分别为**寄存器、IO寄存器、扩展IO寄存器、内部SRAM**

| 区间 | 地址范围 | 解释 |
| :-: | :-: | :-: |
| 寄存器        | 0x0000 ~ 0x001F | 32个通用寄存器R0 ~ R31 |
| IO寄存器      | 0x0020 ~ 0x005F | 共计64个，可以使用IO指令IN/OUT直接访问，使用地址0x0000 ~ 0x003F，也可以使用普通访存指令访问，使用地址0x0020 ~ 0x005F。这片区域的**低32字节（共256bit）**同样支持8051一样的**位寻址**，位操作指令有`SBI CBI SBIS SBIC` |
| 扩展IO寄存器  | 0x0060 ~ 0x00FF | 共计160个，只能使用普通访存指令访问，使用地址0x0060 ~ 0x00FF |
| 内部SRAM      | 0x0100 ~ | 只能使用普通访存指令访问 |

通用寄存器之间只能通过`MOV MOVW`传送数据，分别为传送单个寄存器和传送两个寄存器（word）

整个SRAM数据区可以通过`LD ST`指令进行字节数据访问，使用**X Y Z**寄存器作为指针，最多可以访问当前数据区64kB空间，如需要访问其他空间需要更改相应的**RAMP**寄存器

可以访问SRAM的还有堆栈指令

立即数装载指令`LDI`只能使用R16 ~ R31，例如`LDI R30,0x3D`，而直接地址装载指令`LDS`（长32位）可以使用所有的32个通用寄存器，例如`LDS R3,0x0F33`

**EEPROM**

EEPROM不可直接寻址，只能通过寄存器操作。EEPROM有**数据寄存器，地址寄存器，控制寄存器**三种寄存器。EEPROM擦写寿命大约是100000次


### 1.1.3 16位寄存器访问方式

由于AVR是8位机，所以不能直接处理16位寄存器，16位寄存器的读写需要通过两次操作。为保证16位寄存器的**所有位同时被读写**，AVR在内部使用了16位的临时寄存器，该寄存器对用户不可见

**AVR对16位寄存器高位和低位的读写顺序有明确要求**

**写操作**：写16位寄存器时，**需要先写高位，再写低位**。高位被写入时被存到临时寄存器中，之后在写入低位同时高位和低位共2字节数据同时被自动写入到16位寄存器中

**读操作**：读16位寄存器时，**需要先读低位，再读高位**。读取低位时高位会在同一时刻被自动传输到临时寄存器中，只要再次读取高位即可


### 1.1.4 引脚定义

**328P的引脚定义**

![](images/210702a049.png)

![](images/210702a050.png)

**32u4的引脚定义**

![](images/210702a051.png)

**16u2的引脚定义**

![](images/210702a052.png)


### 1.1.5 中断

不同AVR单片机的中断向量表也不同，因为不同单片机带有的外设模块不同

> **AVR中所有中断的优先级都是固定的不可更改的，优先级以中断向量表的地址为参考，地址越低的拥有越高的优先级，RESET复位中断拥有最高优先级**

**328P的中断向量表**

328P拥有2k字节的内部SRAM以及32k字节的Flash

![](images/210702a042.png)

**16u2的中断向量表**

16u2拥有512字节的内部SRAM以及16k字节的Flash

![](images/210702a043.png)

![](images/210702a044.png)

**32u4的中断向量表**

32u4拥有2.5k字节的内部SRAM以及32k字节的Flash

![](images/210702a045.png)

![](images/210702a046.png)

> 因为Flash分为Bootloader以及应用程序两个区域，可以通过熔丝位**BOOTRST BOOTSZ**以及**MCUCR**寄存器位**IVSEL**更改中断向量指令的实际位置，这在ATmega系列的单片机中通用，如下图，可以分别设置复位中断和其余中断的位置。**BOOTRST**用于设置RESET中断的位置，**BOOTSZ**用于设置Bootloader区域的大小

![](images/210702a047.png)

> 其中IVSEL位需要在IO寄存器**MCUCR**设置，地址为0x35（使用`IN OUT`）或0x55（使用`LD ST`）。**在对IVSEL进行更改之前，需要首先向IVCE写入1，此时会自动禁止中断，之后需要在4个时钟以内向IVSEL写值，同时需要将IVCE置0（写0xN2/0xN0）。如果超出4个时钟，IVCE会自动置0，写入失败**

![](images/210702a048.png)


## 1.2 外部中断

外部中断引脚分为两种，一种是普通的**INT**引脚，使用的是普通的INTx中断，一个引脚对应一个中断。另一种是**PCINT**（Pin Change）引脚，使用的是PCINTx中断，多个引脚共用一个中断

INT支持的4种中断形式有低电平中断，以及上升沿/下降沿/边沿触发中断，而PCINT仅仅支持引脚变化中断

**注意这些引脚即便是配置成输出也会触发中断**

|  | 328P | 16u2 | 32u4 |
| :-: | :-: | :-: | :-: |
| PCINT | PCI0..PCI2 | PCI0,PCI1 | PCI0 |
| INT | INT0,INT1 | INT0..INT7 | INT0..INT3,INT6 |

> 328P中一共有3个PCI中断，23个PCINT引脚，**PCI0对应引脚PCINT(7..0)，PCI1对应引脚PCINT(14..8)，PCI2对应引脚PCINT(23..16)**
>
> 16u2中有2个PCI中断，13个PCINT引脚，**PCI0对应引脚PCINT(7..0)，PCI1对应引脚PCINT(12..8)**
>
> 32u4中有1个PCI中断，8个PCINT引脚，**PCI0对应引脚PCINT(7..0)**
>
> PCI中断中的每一位可以通过对应的PCMSK0/PCMSK1/PCMSK2寄存器进行配置

外部中断控制寄存器主要有EICRx，EIMSK，EIFR，PCICR，PCIFR，PCMSKx六种寄存器


**EICRx寄存器**

用于控制**INTx**外部中断的触发方式，有4种可用方式

> 328P只有一个**EICRA**，2个INT中断，其中**ISC0x**配置**INT0**中断，**ISC1x**配置**INT1**中断，定义如下，**00代表低电平触发，01代表边沿触发，10代表下降沿触发，11代表上升沿触发**

![](images/210702a053.png)

![](images/210702a058.png)

> 16u2拥有**EICRA**和**EICRB**两个寄存器，8个INT中断，配置定义和上表相同

![](images/210702a054.png)

![](images/210702a055.png)

> 32u4拥有**EICRA**和**EICRB**两个寄存器，5个INT中断，地址和16u2相同

![](images/210702a056.png)

![](images/210702a057.png)


**EIMSK寄存器**

用于设置**INTx**中断屏蔽位

> 将328P的EIMSK寄存器中的**INT0**或**INT1**设为1，并且使能状态寄存器中的全局中断位I，允许相应中断

![](images/210702a059.png)

> 16u2的**EIMSK**，对应8个中断

![](images/210702a060.png)

> 32u4的**EIMSK**，对应5个中断，寄存器地址同上

![](images/210702a061.png)


**EIFR寄存器**

用于指示触发中断的**INTx**引脚号

> 在**INTx**触发中断时，328P的**EIFR**中的相应位会置1，在跳转进入中断服务程序之后相应位会自动置0，也可以向该位**写1**（注意不是写0）软件清除该位。**另外在低电平触发模式时这些位都不会置位**

![](images/210702a062.png)

> 16u2的**EIFR**，8个中断

![](images/210702a063.png)

> 32u4的**EIFR**，5个中断，寄存器地址同上

![](images/210702a064.png)


**PCICR寄存器**

一整组PCI的中断屏蔽

> 向328P的PCICR寄存器相应位**PCIEx**设为1可以使能相应的PCI中断，单独的引脚屏蔽位在**PCMSKx**设置

![](images/210702a065.png)

> 16u2的**PCICR**，2个中断

![](images/210702a066.png)

> 32u4的**PCICR**，1个中断，寄存器地址同上

![](images/210702a067.png)


**PCIFR寄存器**

指示**PCI**中断号

> 328P中的**PCIFR**寄存器，中断触发时对应位置1，并且会在跳转至中断服务程序时自动清0，也可以**写1**软件清零

![](images/210702a068.png)

> 16u2中的**PCIFR**，2个中断

![](images/210702a069.png)

> 32u4中的**PCIFR**，1个中断，寄存器地址同上

![](images/210702a070.png)


**PCMSKx寄存器**

一组PCI中单独引脚的中断屏蔽

> 328P拥有3个寄存器**PCMSK0**，**PCMSK1**，**PCMSK2**，可以将相应的位置1使能对应引脚中断

![](images/210702a071.png)

![](images/210702a072.png)

![](images/210702a073.png)

> 16u2拥有2个寄存器**PCMSK0**，**PCMSK1**

![](images/210702a074.png)

![](images/210702a075.png)

> 32u4只拥有1个寄存器**PCMSK0**，寄存器地址同上

![](images/210702a076.png)


## 1.3 时钟控制

AVR的时钟系统相比8051单片机要复杂很多，带USB功能的型号（16u2和32u4）有PLL锁相环用以提供USB所需48Mhz的时钟

### 1.3.1 328P的时钟系统架构详解

![](images/210702a077.png)

如上图，时钟系统以控制单元为核心，分5路输出到**定时器，GPIO，ADC，CPU和RAM部分以及Flash和EEPROM部分**，切断CPU时钟可以使CPU停止工作，而IO时钟提供给SPI，I2C，UART，定时器，外部中断使用（I2C的地址识别和时钟无关），定时器可以使用系统主时钟源也可以使用异步的外部时钟或低速的32.768khz外部振荡器（作为RTC使用）

系统时钟源可以选择外部时钟输入，外接晶振，低频外接晶振以及内部RC振荡器。而定时器和看门狗可以使用独立的振荡器

**系统主时钟源与相关熔丝位**

> 328P支持多种不同的主时钟源，可以通过熔丝位设置，用于配置时钟源的熔丝位都位于三个熔丝字节的最低一个字节（有关熔丝位的基本介绍参考[1.14熔丝位](210702a_avr.md#114-熔丝位)），如下

![](images/210702a081.png)

> 其中，**CKDIV8**用于配置是否对输入的系统时钟进行8分频，置1不分频。
>
> **CKOUT**用于配置是否在引脚**PB0**进行时钟输出。
>
> 而**SUT**指Startup Time，因为单片机的**振荡器在开始工作的时候有一个逐渐稳定的过程**，此时单片机还不能开始工作，所以需要设定一个在上电到复位信号失效的延时，通过**SUT**设置。**SUT一般设为默认的最大延时即可**，在使能BOD时改为对应配置即可
>
> **补充：AVR单片机一般都支持Brown-Out-Detection（BOD）即掉电检测，并且会进行相应的复位。BOD的功能实际和SUT重复，所以熔丝位提供了相应的配置选项，需要在使能BOD时使用**

> 328P一共可配置使用6种不同的主时钟源，通过熔丝位**CKSELx**配置时钟，出厂时默认0010，使用内部的RC振荡器（8.0Mhz），定义如下
>
> ![](images/210702a080.png)
>
> 选择**External Clock外部时钟**需要在**XTAL1**引脚输入时钟，并且时钟不能有超过2%的变化，如果需要调节频率要通过**预分频器**调节，**SUT**设为10
>
> 选择**128k内部RC振荡器**会使用单片机自带的低功耗RC振荡器，此时单片机引脚XTAL1和XTAL2可以当作GPIO使用。此种模式振荡器精准度较低，**SUT**设为10
>
> 选择**内部RC振荡器**会使用单片机自带的高速RC振荡器，频率为8Mhz左右，此时单片机引脚XTAL1和XTAL2可以当作GPIO使用，可以通过**OSCCAL**寄存器进行校准，**是328P出厂默认设置**，**SUT**设为10
>
> 选择**低频晶体振荡器**会使用到外接的晶振，一般为32.768khz，连接在TOSC1和TOSC2引脚（和XTAL1和XTAL2共用引脚），这种模式一般用在启动时震荡频率不敏感的场合。该种模式下**CKSEL**一般设为0101，**SUT**设为10
>
> **以下2种配置归类为外部振荡器类型，为常用配置**
>
> 共用的配置定义
>
> ![](images/210702a095.png)
>
> 选择**Full Swing（满幅）全功率晶体振荡器**同样需要使用到外部晶振，比如Arduino使用的是16Mhz的晶振，此时振荡放大器以满功率工作（XTAL2输出满幅），晶振连接在XTAL1和XTAL2引脚，**这也是最常用的配置方式**，适用于干扰较重的场合。该种模式下一般使用400k到20Mhz晶振，12到22pF电容，**CKSEL**设为0111，**SUT**设为11（不使用BOD）或01（使用BOD）
>
> 选择**低功耗晶体振荡器**晶振连接和常用的Full Swing模式类似，区别是此时振荡放大器不是满功率输出，较为省电，但是容易受干扰影响。该种模式需要根据振荡频率设定**CKSEL**，一般使用900k到16Mhz晶振，12到22pF电容。**SUT**设为11（不使用BOD）或01（使用BOD）。使用900k到3Mhz振荡器**CKSEL3..0**设为1011，3Mhz到8Mhz振荡器**CKSEL3..0**设为1101，8Mhz到16Mhz振荡器**CKSEL3..0**设为1111

**相关配置寄存器**

**OSCCAL寄存器**

OSCCAL寄存器用于设置**RC振荡器**的校正系数

![](images/210702a082.png)

> OSCCAL寄存器有一个出厂设定值，这个值在单片机复位时会自动写入到该寄存器。可以在运行时通过程序调节，大约在7.3Mhz到8.1Mhz之间调节，一般用不上

**CLKPR寄存器**

CLKPR寄存器用于设置时钟的预分频系数

![](images/210702a083.png)

分频系数定义如下

![](images/210702a084.png)

> 其中，**CLKPCE**位是更改使能，**CLKPSx**为分频系数设置。**在复位时熔丝位CKDIV8的值会决定CLKPSx的初值，如果CKDIV8为0那么默认CLKPSx=0011（8分频）**。设置分频的步骤如下
>
> 1. 向CLKPR写入0x80（即置CLKPE为1，其余位为0）
>
> 2. 在之后4个周期以内同时向寄存器写入0x0N（即设置CLKPS的值同时置CLKCE为0）
>
> 设置该寄存器时建议**关闭中断**防止过程被打断


### 1.3.2 16u2的时钟系统架构详解

![](images/210702a078.png)

16u2相比328P去掉了定时器的异步时钟源，并且由于没有ADC模块所以也没有ADC时钟输出。16u2有usb模块，所以需要使用**PLL**提供48Mhz的高频时钟。PLL的时钟虽然和系统时钟使用同一个时钟源，但是相对系统时钟独立，**拥有自己的预分频配置**。由于PLL始终将时钟乘以6，而USB的标准频率是48Mhz，所以**PLL预分频之后需要提供一个8Mhz的时钟**

和328P只能通过熔丝位配置时钟源不同，**16u2支持使用软件通过寄存器配置时钟源**

16u2也**不支持异步时钟源**

16u2熔丝位低字节位定义和328P完全相同，这里不再赘述

**系统主时钟源与相关熔丝位**

> 由于16u2不支持低速32.768khz的时钟源，所以**CKSELx**熔丝位的定义也稍有不同，0101 ~ 0100不再有用，其余有关系统主时钟源配置的定义和328P完全相同
>
> ![](images/210702a085.png)
>
> 出厂时16u2的**CKSELx**熔丝位默认配置为0010使用内部RC振荡器，**SUT**默认配置为10为最大，**CKDIV**默认配置为0使用8分频

**PLL时钟源**

这是16u2相比328P增加的部分

> PLL的结构如下，相关配置位定义见寄存器配置
> 
> ![](images/210702a092.png)

**相关配置寄存器**

16u2除了拥有**CLKPR**以及**OSCCAL**寄存器以外，还添加了**CLKSEL0**，**CLKSEL1**（注意不是熔丝位CKSEL），**CLKSTA**，**PLLCSR**共4个寄存器

**OSCCAL寄存器**

和328P定义完全相同，略

**CLKPR寄存器**

略

**CLKSEL0寄存器**

和328P不同，16u2支持通过寄存器软件更改时钟和振荡器参数。**CLKSEL0**用于设置**SUT**参数以及振荡器的选择与开关，定义如下

![](images/210702a087.png)

> 其中，**RCSUTx**用于设置**使用RC振荡器**时的SUT参数，在启动时熔丝位**SUTx**会**自动装载**到此处。设置这两位**没有任何作用**所以维持默认值即可
>
> **EXSUTx**寄存器同理，用于设置**使用外部振荡器或晶振**时的SUT参数，区别是更改该两位之后重启振荡器会生效（RC振荡器不可重启）
>
> **RCE**和**EXTE**分别作为RC振荡器和外部/晶体振荡器的**开关**，置1开启置0关闭
>
> **CLKS**用于设置时钟源类型，置1使用外部/晶体振荡器，置0使用RC振荡器。**该位会在复位后根据熔丝位的设置自动选择**

**CLKSEL1寄存器**

该寄存器用于设置使用相应时钟（内部RC振荡器或外部时钟/晶体振荡器）时的**CKSELx**参数（启动时从熔丝位自动装载到**相应位**）

![](images/210702a088.png)

> **RCCKSELx**用于设置在使用RC振荡器作为时钟源时的CKSEL。由于RC模式只能设置为0010，所以更改无效，维持默认值即可
>
> **EXCKSELx**用于设置在使用外部/晶体振荡器作为时钟源时的CKSEL。区别是可以更改SUT参数，在clock switch之后生效

**CLKSTA寄存器**

该寄存器用于指示时钟源状态，1为开启0为关闭，定义如下

![](images/210702a089.png)

> **RCON**指示RC振荡器状态，**EXTON**指示外部/晶体振荡器状态

**PLLCSR寄存器**

该寄存器专用于PLL配置，以及指示PLL状态，**划重点**

> **注意，Atmel官方文档对于16u2的PLL配置寄存器的描述存在失误，目前也没有任何修正版本**。截图如下，寄存器的读写权限也不对应
>
> ![](images/210702a090.png)
>
> 之后参考了Atmel Studio中相关的头文件，分别找到了16u2和32u4有关PLL设置的寄存器定义

```c
//  16u2

#define PLLCSR _SFR_IO8(0x29)
#define PLOCK 0
#define PLLE 1
#define PLLP0 2
#define PLLP1 3
#define PLLP2 4
```

```c
//  32u4

#define PLLCSR _SFR_IO8(0x29)
#define PLOCK 0
#define PLLE 1
#define PINDIV 4

#define PLLFRQ _SFR_IO8(0x32)
#define PDIV0 0
#define PDIV1 1
#define PDIV2 2
#define PDIV3 3
#define PLLTM0 4
#define PLLTM1 5
#define PLLUSB 6
#define PINMUX 7
```

> Arduino维护者在代码中也提到了这个问题，参考github上[代码](https://github.com/apachiww/ArduinoCore-avr/blob/master/cores/arduino/USBCore.cpp)（个人Fork）的第681行开始，由此发现问题所在

```c
#elif defined(__AVR_AT90USB82__) || defined(__AVR_AT90USB162__) || defined(__AVR_ATmega32U2__) || defined(__AVR_ATmega16U2__) || defined(__AVR_ATmega8U2__)
	// for the u2 Series the datasheet is confusing. On page 40 its called PINDIV and on page 290 its called PLLP0
#if F_CPU == 16000000UL
	// Need 16 MHz xtal
	PLLCSR |= (1 << PLLP0);
#elif F_CPU == 8000000UL
	// Need 8 MHz xtal
	PLLCSR &= ~(1 << PLLP0);
#endif
```

> 16u2和32u4的PLL部分完全不相同，32u4使用了2个寄存器控制PLL（多了**PLLFRQ**）。由以上分析Atmel（Microchip）的文档编写者可能误将两者混在一起了（~~实习生~~）
>
> PLL电路也是错误的，实际16u2的时钟系统和AT90USB162是基本一样的
>
> 16u2文档中的错误电路，多出了很多不存在的信号
>
> ![](images/210702a086.png)
>
> AT90USB162的电路
>
> ![](images/210702a092.png)
>

最后根据Arduino官方的代码，参考了[AT90USB162](https://www.microchip.com/en-us/product/AT90USB162)的资料如下。**这是16u2的PLLCSR寄存器的正确定义**。该图中**PLLPx**的读写权限的标记应当是R/W

![](images/210702a093.png)

> **PLLE**是PLL的开关，置1启动。**注意如果使用的是RC振荡器，将PLLE置位时RC振荡器会自动启动**
>
> **PLOCK**是PLL锁定指示位，在PLL启动之后需要经过大约1ms到100ms该指示位才会置位，表示PLL输出和输入参考时钟已经锁定相位，**此时PLL才可以使用**
>
> **PLLPx**是PLL的预分频参数，**PLLP2..0**为000时不分频，为001时使用2分频


### 1.3.3 32u4的时钟系统架构详解

![](images/210702a079.png)

32u4的时钟系统和16u2的主要区别在于PLL部分，PLL既可以使用系统时钟也可以直接使用RC振荡器，另外由于32u4比16u2多了一个高速定时器，PLL除了给usb提供时钟以外还要为高速定时器提供时钟

和16u2一样，32u4**不支持异步时钟**

**系统主时钟源与相关熔丝位**

> 32u4的时钟熔丝位配置和16u2又是不同的。和16u2相反，32u4相比328P**没有振荡器的满幅模式**，只有低功耗模式。32u4支持低频32.768khz的外部振荡器
>
> ![](images/210702a094.png)
>
> 32u4分为两种，最普通的32u4默认出厂熔丝设置为使用**低功耗振荡器**并且设置系统时钟8分频（CKSELx=1110，SUTx=01），而32u4RC默认出厂熔丝设置为使用RC振荡器
>
> 32u4支持4种时钟源，这些时钟源的熔丝位设置和328P完全相同，这里不再赘述

**PLL时钟源**

32u4的PLL和16u2的不同，支持将8Mhz时钟倍频后输出32 ~ 96Mhz的时钟，为usb以及高速定时器提供时钟。并且32u4的PLL模块有预分频也有输出分频，可以分别单独设置

> 32u4的PLL时钟模块使用了2个寄存器**PLLCSR**和**PLLFRQ**进行配置。PLL电路结构如下
>
> ![](images/210702a096.png)

**相关配置寄存器**

**OSCCAL寄存器**

略

**CLKPR寄存器**

略

**CLKSEL0寄存器**

同16u2，以下同理，略

**CLKSEL1寄存器**

略

**CLKSTA寄存器**

略

**PLLCSR寄存器**

32u4的**PLLCSR**定义和16u2不同。这里的**PLLCSR**只有3个有效位，如下

![](images/210702a091.png)

> **PINDIV**为PLL输入预分频，置0不分频，置1对输入时钟（振荡器等）进行2分频，需要在**启动PLL之前**进行设置
>
> **PLLE**和**PLOCK**分别为PLL使能（启动）和PLL锁定指示位，同16u2

**PLLFRQ寄存器**

该寄存器用于设置PLL的输出分频，以及高速定时器的时钟源

![](images/210702a097.png)

> **PINMUX**用于选择PLL的时钟源，置0使用PLL预分频器（独立于系统时钟预分频器），置1直接使用内置8Mhz的RC振荡器，这样可以将usb和系统时钟分离开来，系统可以使用晶振
>
> **PLLUSB**用于设置usb的输入分频（PLL），置0不分频（此时PLL应当输出48Mhz），置1分频（此时PLL应当输出96Mhz）
>
> **PLLTMx**用于设置高速计时器的输入分频（PLL），当**PLLTM1..0**为00时断开时钟，01时不分频，10时进行1.5分频，11时进行2分频
>
> **PDIVx**用于设置PLL的时钟输出频率，见下
>
> ![](images/210702a098.png)
>
> Atmel建议在正常5v供电时，将**PDIV3..0**设置为1010，输出96Mhz时钟，将**PLLUSB**置1进行2分频之后得到48Mhz的时钟


## 1.4 GPIO

AVR的GPIO结构相比8051也要复杂很多，功能更加强大


### 1.4.1 AVR的GPIO基本电路结构

一般的AVR都有多组GPIO，比如328P的GPIO有PORTB，PORTC，PORTD等。每一组IO最多可以包含8个IO，单个IO的结构如下。可以注意到328P的GPIO使用了大量的Buffer。以下对于GPIO做一个详细的分析

![](images/210702a099.png)

> 在一般模式下面，一组GPIO有3个主要的控制寄存器，分别为**DDRx**（Data Direction Register，用于设置IO的输入输出），**PINx**（Port Input，用于读取引脚输入），**PORTx**（GPIO输出的状态）。以下没有特殊说明，寄存器名称都代指一组IO中的1位
>
> 和8051相比，AVR的GPIO由于其更加复杂严谨的设计，并且可以设置输入输出模式，所以输出高电平和低电平的负载驱动能力是基本相近的（足以点亮LED），不像8051输出高电平基本没有驱动能力可以轻易被拉低
>
> 仔细观察之后可以大致将该电路分为5个部分，分别为**上拉电阻**，**数据方向**，**输出数据**，**引脚读取**以及**休眠控制**
>
> 首先从**上拉电阻**（左上角）开始分析。上拉电阻只有在GPIO数据寄存器**PORTx**为1，并且数据方向**DDRx**为0（作为输入，关闭Buffer）相应的上拉才会生效。另外，建议将不使用的引脚上拉
>
> **数据方向**寄存器**DDRx**置1使能输出，置0禁止输出，此时如果没有上拉电阻那么引脚处于高阻态模式
>
> **输出数据**寄存器**PORTx**可以直接置位，置1输出高电平置0低电平，也会受到**PINx**寄存器的影响，见下
>
> **引脚读取**寄存器**PINx**一般是作为只读寄存器读取引脚状态使用，并且读取的是Buffer之后的电平状态，和**PORTx**寄存器的输出状态**没有必然联系**。也可以向**PINx**寄存器写1，可以**翻转PORTx相应位，改变输出**。另外，为了消除寄存器亚稳态的影响，输入端使用了两个寄存器（Synchronizer），注意**这会带来0.5到1.5个时钟的延迟**
>
> **休眠控制**和[休眠模式](210702a_avr.md#112-休眠模式)有关。休眠模式时SLEEP信号为高电平，此时施密特触发器输入端会被拉低到0，Buffer关闭，这样可以保证信号的确定性，降低功耗（对于CMOS电路来说中间电平是最消耗能源的）
>
> 最终可以得到各种配置模式定义如下
>
> ![](images/210702a101.png)
>
> 注意：由于从输入高阻态（**PORTx**为0，**DDRx**为0）到输出高电平（**PORTx**为1，**DDRx**为1）一定会经历一个中间状态01或10，在这两个状态中**建议使用输入上拉（PORTx为1，DDRx为0）模式**，此时如果有需要也可以在**MCUCR**临时禁用上拉。从01到10的转换同理，建议通过00中间状态跳转

另外GPIO会和单片机中的一些外设模块如SPI，I2C，UART，中断，ADC输入等复用，此时实际的GPIO电路会变成类似如下所示的结构（仅作为示意）

![](images/210702a100.png)

> 该种模式事实上和各外设的使能与否有关，相关的配置需要参考之后的各章节。由电路分析，其实就是在之前除引脚读取之外的4个部分（都和输出有关）添加了复用接口，如果使能了其他功能就会Override覆盖原始的普通GPIO功能。另外引出了模拟输入输出以及数字输入接口


### 1.4.2 328P的GPIO

以下为328P的GPIO复用情况

**PORTB**

![](images/210702a102.png)

> 1. 在PB7和PB6作为振荡器接口使用时，所有寄存器**PORTx**，**PINx**以及**DDRx**读取都为0
>
> 2. SPI接口的SCK在Master模式时为输出，Slave模式时为输入（此时上拉电阻依然可以配置）。在Slave模式时\#SS配置为输入。同时SPI接口兼具ICSP下载功能
>
> 3. OC2A和OC1A OC1B分别为定时器2的比较输出A和定时器1的比较输出AB。ICP1为定时器1的捕获输入
>
> 4. CLKO用于输出系统时钟，通过熔丝位配置

**PORTC**

![](images/210702a103.png)

> 1. 复位输入\#RESET通过熔丝位**RSTDISBL**配置，此时PC6相应寄存器读取都为0
>
> 2. 当**TWCR**的TWEN置位时，TWI使能，此时SDA以及SCL为开集输出无上拉电阻
>
> 3. ADCx为模数转换器输入，理想输入电阻无穷大。不同输入通道使用的电源不同（328P使用了两个电源，一个为数字电路部分供电，一个为模拟电路部分供电）。ADC4和ADC5使用**数字电源**，其余使用**模拟电源**

**PORTD**

![](images/210702a104.png)

> 1. AIN0和AIN1分别为比较器的正相以及反相输入，理论输入电阻无穷大
>
> 2. OC2B和OC0A OC0B分别为定时器2的分别为定时器2的比较输出B和定时器0的比较输出AB。T0和T1分别为定时器0和1的外部时钟输入
>
> 3. XCK为UART外部时钟输入，TXD和RXD分别为UART发送和接收端口。使能UART的发送和接收模块时会分别自动将这些端口配置为发送和接收

**相关配置寄存器**

**MCUCR寄存器**

寄存器**MCUCR**中的**PUD**用于控制IO的上拉电阻

![](images/210702a113.png)

> 将**PUD**位置1可以禁用所有的上拉电阻

**PORTB寄存器**

![](images/210702a114.png)

**DDRB寄存器**

![](images/210702a115.png)

**PINB寄存器**

![](images/210702a116.png)

**PORTC寄存器**

![](images/210702a117.png)

**DDRC寄存器**

![](images/210702a118.png)

**PINC寄存器**

![](images/210702a119.png)

**PORTD寄存器**

![](images/210702a120.png)

**DDRD寄存器**

![](images/210702a121.png)

**PIND寄存器**

![](images/210702a122.png)


### 1.4.3 16u2的GPIO

以下为16u2的GPIO复用情况

**PORTB**

![](images/210702a105.png)

**PORTC**

![](images/210702a106.png)

> 1. dW是Debug Wire，在熔丝位**DWEN**使能以后启用。一般用不上

**PORTD**

![](images/210702a107.png)

> 1. \#CTS和\#RTS分别为UART1的发送流控制信号以及接收流控制信号，XCK为UART1外部时钟

**相关配置寄存器**

**MCUCR寄存器**

寄存器**MCUCR**中的**PUD**用于控制IO的上拉电阻

![](images/210702a123.png)

> 将**PUD**位置1可以禁用所有的上拉电阻

**PORTB寄存器**

![](images/210702a124.png)

**DDRB寄存器**

![](images/210702a125.png)

**PINB寄存器**

![](images/210702a126.png)

**PORTC寄存器**

![](images/210702a127.png)

**DDRC寄存器**

![](images/210702a128.png)

**PINC寄存器**

![](images/210702a129.png)

**PORTD寄存器**

![](images/210702a130.png)

**DDRD寄存器**

![](images/210702a131.png)

**PIND寄存器**

![](images/210702a132.png)


### 1.4.4 32u4的GPIO

以下为32u4的GPIO复用情况，32u4有5组GPIO

**PORTB**

![](images/210702a108.png)

> 1. \#RTS为UART的时钟接收流控制信号
>
> 2. OC.4B和\#OC.4B分别为定时器T4的比较输出B，是一对互补信号

**PORTC**

![](images/210702a109.png)

> 1. OC.4A和\#OC.4A分别为定时器T4的比较输出A，是一对互补信号
>
> 2. OC.3A为定时器T3的比较输出A

**PORTD**

![](images/210702a110.png)

> 1. OC.4D和\#OC.4D分别为定时器T4的比较输出D，是一对互补信号
>
> 2. \#CTS为UART的时钟发送流控制信号

**PORTE**

![](images/210702a111.png)

> 1. 复位时将\#HWB接地，可以允许在复位之后执行Bootloader（在非复位状态下可以使用正常功能），通过设置熔丝位**HWBE**使能

**PORTF**

![](images/210702a112.png)

> 1. TDI、TDO、TMS以及TCK为JTAG引脚，使能JTAG时不能使用普通功能

**相关配置寄存器**

**MCUCR寄存器**

同16u2，略

**PORTB寄存器**

同16u2，略

**DDRB寄存器**

略

**PINB寄存器**

略

**PORTC寄存器**

地址0x08(0x28)

![](images/210702a133.png)

**DDRC寄存器**

地址0x07(0x27)

![](images/210702a134.png)

**PINC寄存器**

地址0x06(0x26)

![](images/210702a135.png)

**PORTD寄存器**

略

**DDRD寄存器**

略

**PIND寄存器**

略

**PORTE寄存器**

地址0x0E(0x2E)

![](images/210702a136.png)

**DDRE寄存器**

地址0x0D(0x2D)

![](images/210702a137.png)

**PINE寄存器**

地址0x0C(0x2C)

![](images/210702a138.png)

**PORTF寄存器**

地址0x11(0x31)

![](images/210702a139.png)

**DDRF寄存器**

地址0x10(0x30)

![](images/210702a140.png)

**PINF寄存器**

地址0x0F(0x2F)

![](images/210702a141.png)


## 1.5 定时器

AVR中的定时器有多种用途，可以用于PWM输出，为UART提供时钟，外部计数，定时等

> 首先引入几个定义
>
> 1. **TOP**代指计数器达到最大值
>
> 2. **BOTTOM**代指计数器达到0
>
> 3. **MAX**代指计数器达到0xFF或0xFFFF


### 1.5.1 328P的定时器

**8位定时器TCNT0**

定时器**TCNT0**拥有2个单独的比较寄存器（输出引脚分别为**OC0A**和**OC0B**），3个不同的中断源（**TOV0**，**OC0A**和**OC0B**），可以用于PWM输出以及频率脉冲输出，计数，定时等

使用**TCNT0**时需要将**PRTIM0**置零，见[休眠模式](#112-休眠模式)

8位定时器的结构如下，其中标**粗体**的寄存器是可以使用CPU访问的

![](images/210702a142.png)

> 由上图分析，定时器1拥有**TCNT0**，**OCR0A**，**OCR0B**，**TCCR0A**以及**TCCR0B**一共5个主要的寄存器，另外有中断控制寄存器**TIFR0**和**TIMSK0**
>
> 其中，**TCNT0**寄存器为计数器，可以向上计数或向下计数，可以通过CPU强行置数，**注意置数后一个计数周期内将会屏蔽比较输出（这样可以在计数器初始化时将TCNT0和OCR0x初始化为相同的值而不触发比较输出）**。**OCR0A**可以作为比较寄存器A使用，也可以用于设置计数TOP值，**OCR0B**只能作为比较寄存器B使用
>
> 当比较器检测到**TCNT0**计数器数值和**OCR0A**以及**OCR0B**相同时，在下一个时钟比较标记会置位，可以通过软件写入1复位。此时如果使能中断就会产生中断，执行中断时标记位会**自动硬件复位**。另外输出引脚也是可以配置不同的输出模式的，如PWM，脉冲等，也可以通过强制置位改变比较器输出引脚的状态
>
> **TCCR0A**和**TCCR0B**分别用于控制比较器输出A和B
>
> 定时器**TCNT0**有3个外部引脚，分别为T0时钟输入，OC0A和OC0B为比较输出。输出引脚**必须在定时器初始化之前配置为输出**，具体原因参考下图

![](images/210702a143.png)

> 定时器的寄存器配置会影响到IO，OC0A和OC0B为输出寄存器，而**DDRx**寄存器不受影响

**工作模式**

定时器**TCNT0**一共支持4种工作模式，分别为**一般模式（Normal）**，**相同时清零模式（CTC）**，**高速PWM模式（Fast PWM）**，**相校正PWM模式（Phase Correct PWM）**

> 1. **一般模式**下定时器向上计数，当计数溢出之后自动从0开始重新计数，同时**TOV0**溢出标记置位（需要软件复位）。如果使能了**TOV0**中断，执行中断服务程序时标记位会**自动清零**
>
> 2. **CTC模式**下定时器工作示意图如下，每一次触发比较都会使得**OC0x**置位。注意，在当定时器**TCNT0**当前计数值大于想要的**OCR0x**比较值时，设置**OCR0x**后定时器会继续计数直到溢出，**而并不会立即触发比较**。另外，输出寄存器**OC0x**也可以配置为Toggle模式，也就是每触发一次比较就切换一下状态
>
> ![](images/210702a144.png)
>
> 3. **高速PWM模式**事实上为单坡（Single Slope）PWM模式，工作示意图如下（相比之后的相校正PWM定时器只递增计数，所以可以输出两倍频率的PWM信号）。定时器的最大计数值**TOP**可以是0xFF也可以是寄存器**OCR0A**。而PWM方波信号输出端OC0A或OC0B（**正相**）在计数到达BOTTOM以后就**置位**，而在触发比较到计数到TOP的区间就会**复位**，这就是PWM的基本原理。还可以将输出设置为**反相**输出。比较寄存器可以是**OCR0A**或**OCR0B**，可以设置PWM的占空比。**注意，这种模式下计数溢出中断TOV0依然起作用（可以屏蔽）**，可以通过该中断设置下一次的比较值
>
> ![](images/210702a145.png)
>
> 4. **相校正PWM（Phase Correct PWM）模式**为双坡（Dual Slope）PWM模式，工作示意图如下。这种模式的特征在于占空比改变时相位不变，最大只能达到高速PWM一半的频率。同高速PWM，定时器的最大计数值**TOP**可以是0xFF也可以是寄存器**OCR0A**。
>
> ![](images/210702a146.png)

**寄存器定义**

**16位定时器**

**工作模式**

**寄存器定义**

**8位异步定时器**

**工作模式**

**寄存器定义**


### 1.5.2 16u2的定时器


### 1.5.3 32u4的定时器


## 1.6 ADC以及比较器

只有328P和32u4有ADC，16u2只有比较器

## 1.7 SPI

## 1.8 I2C

## 1.9 UART

## 1.10 USB

## 1.11 单片机的复位和Watchdog看门狗

## 1.12 休眠模式

## 1.13 BootLoader相关

BootLoader作为AVR单片机启动时运行的第一个程序，具有很重要的作用。通过UART或USB的在线程序下载就是由BootLoader软件实现


## 1.14 AVR ISP下载协议

Atmel的AVR单片机通用的下载协议，通过SPI（ICSP）接口下载，由硬件支持所以和BootLoader无关，可以用于更新修复BootLoader等


## 1.15 熔丝位

熔丝位一般用于配置一些基础参数以及安全设置

> 事实上STC的8051单片机也有熔丝位，比如指令时钟的调节，以及ALE引脚的设置，就是通过编程软件更改熔丝位设置实现

**更改熔丝位一定要三思，否则单片机很容易变砖，只能通过高压编程（通过专用的高压编程接口，需要在\#RST输入12V）或强行输入时钟的方法修复**

包括ATmega328P，16u2，32u4的熔丝位，以及作用


## 1.16 熔丝位设置错误解决方法

熔丝位设置错误一般可以通过输入外部时钟修复。但是如果设置使用了内部时钟，就只能通过高压编程器恢复了（这是解决熔丝位设置错误的最终解决方法）

这里提供这两种方案的具体实现，并且会提供一种可行的高压编程器的DIY方案


## 2 从零开始搭建开发环境

从零开始的AVR开发环境，基于VSCode，包括了软件的安装，环境的配置，工具链的使用，Makefile的编写等

## 2.1 为什么要从零开始

Arduino IDE适用于没有硬件基础的初学者，开发一些简单的应用。通过Arduino IDE入门Arduino非常简单，网上有随处可见的教程。而作为使用sdcc51+Makefile入门8051的强迫症患者，~~我们要学会刀耕火种~~，摆脱对Arduino开发环境以及软件框架的依赖，了解工具链的工作流程以及Makefile的编写

> 从大部分专业者角度看，Arduino IDE事实上并不好用，~~和Keil一样~~不支持代码提示，基本没有管理大型工程的能力，缺乏灵活性，而且bug不少，尤其是包管理器，当你开发大项目的时候就会后悔了。此外在单片机上用C++和Arduino的软件框架虽然可以降低入门难度，但是会降低代码效率。这也是很多人认为Arduino只适合做玩具的原因
>
> 这个教程的基本宗旨之一，就是尽量通过专业（~~硬核~~）的方法，基于底层的开源工具开发Arduino

> 据说最近Arduino出了一个新的Arduino IDE 2.0，目前（2021.7.24）处于beta阶段。试了一下，果然是套皮VSCode，和Keil新出的在线版Keil Studio如出一辙。只能说VSCode已经是dssq了


## 2.2 工具链

## 2.3 烧录以及仿真调试

使用两种方法，和Arduino IDE一样使用串口（依赖于Bootloader），以及使用ISP编程。基于开源工具`avrdude`


## 2.4 Makefile

## 2.5 VSCode配置

## 3 开发示例

## 3.1 GPIO操作

## 3.2 时钟设置

## 3.3 定时器

## 3.4 SPI

## 3.5 I2C

## 3.6 UART

## 3.7 ADC

## 3.8 比较器

## 3.9 PWM

## 3.10 中断编程示例

## 3.11 Bootloader分析与定制

## 3.12 16u2的固件分析与定制
