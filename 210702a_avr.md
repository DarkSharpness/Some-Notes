# AVR单片机深入学习

基于Arduino，了解AVR单片机的底层工作原理，像学8051一样学习AVR，摆脱对Arduino IDE的依赖，仅仅利用Arduino廉价且普及的硬件

## 参考资料

[Microchip AVR](https://www.microchip.com/en-us/products/microcontrollers-and-microprocessors/8-bit-mcus/avr-mcus)

[Microchip Developer](https://www.microchipdeveloper.com)

[Arduino资料文档](src/210702a01/)


## 0 Arduino硬件解析

由浅入深的硬件分析

## 0.1 Arduino硬件博物馆：各版本Arduino外观以及对比

### 0.1.1 Arduino UNO

UNO作为Arduino最经典的一款开发板，分为很多个版本，因为各种克隆版、授权代工、改良版等等实在太多了。

> 这里遵循TB商家的命名习惯做一些定义：
>
> **官方版**代指**所有遵循官方电路以及PCB设计生产的开发板**，这些开发板包括正版开发板（TB商家一般称为**原装进口正版**、**意大利官方英文版**等），国内授权代工版（目前已停产，一般称为**官方中文版**等），以及一些国内厂家根据官方网站提供的PCB文件生产的官方盗版（一般称为**官方版本**），这些开发板共同的特点就是usb电路部分都是使用一片正方形的ATmega16u2或8u2的单片机（需要下载固件），并且一般会印上Arduino的logo
>
> **改良版**代指**国内一些厂家由官方电路更改而来，重新自行设计PCB之后生产的开发板**（一般称为**改良版**或**改进版**）。这些改良版的共同特点是usb部分使用了南京沁恒的CH340芯片，是一个16脚长方形芯片，可以大大降低成本（ATmega16u2和ATmega328P一样是个完整功能的AVR单片机，价格较高）。而主控芯片一般使用贴片ATmega328P，也有少部分和官方版一样使用插槽安装直插式DIP芯片，并且一般不会打印Arduino的logo
>
> **克隆版**代指所有非官方工厂（包括官方代工）来源的开发板，包括了官方盗版以及改良版。现在新款的原装和代工版的PCB一般使用蓝绿色油墨

**官方版**

官方版UNO有新版UNO R3和旧版UNO两种，其中旧版已经非常少见。在Arduino中AVR单片机基本都是使用的16Mhz的晶振

新版UNO R3电路[查看](src/210702a01/Arduino_Uno_R3.pdf)

旧版UNO电路[查看](src/210702a01/Arduino_Uno.pdf)

官方新版与旧版电路区别主要在5V稳压芯片以及13脚的LED电路上

> 旧版5V稳压芯片采用一片MC33269D-5.0，这个5V三端稳压有两种不同的封装，所以图中画了两个，实际只安装一种封装的芯片
>
> ![](images/210702a001.png)
> 
> 新版R3的5V稳压芯片采用一片AMS1117-5.0
>
> ![](images/210702a002.png)
>
> 旧版13脚LED直接和328P的IO（PB5）相连，通过电阻限流
>
> ![](images/210702a003.png)
>
> 新版R3的13脚LED利用了板载运放LM358中未使用的一个运放，作为一个跟随器用，利用运放输入高阻抗特性隔离LED负载，可以减小PB5口的电流负载，同时13脚理论阻值无穷大
>
> ![](images/210702a004.png)
>
> 此外，新版相对于旧版在电源口部分添加了IOREF引脚，用于为扩展板提供参考IO电平

原装英文版（引自Arduino官网）

![](images/210702a005.jpg)

背面

![](images/210702a009.jpg)

> 进口的价格非常高，同样价格可以买一打克隆版了。当然土豪不差钱无所谓

官方中文版（自摄）

![](images/210702a006.jpg)

背面

![](images/210702a010.jpg)

> Arduino官方授权中国厂商代工。这块中文版前主人将其用于小车电机控制，由于未知原因导致16u2芯片固件异常无法烧录，而328P芯片已被取下转移至旧版UNO上使用。之后有修复教程，以及16u2的开发（事实上UNO没有328P也可以当开发板用，功能和之后提到的Leonardo类似，可以模拟键盘，但是可扩展性稍差）

官方盗版（自摄）

![](images/210702a007.jpg)

背面

![](images/210702a011.jpg)

> 陪伴我时间最长的一块开发板，从刚上高中用到现在。这些克隆版缺点就是焊接工艺较差，元器件歪斜，但是工作稳定性没什么区别

旧版官方盗版（自摄）

![](images/210702a008.jpg)

背面

![](images/210702a012.jpg)

> 捡到的板子。字体形状比较奇怪，应该是当时的厂商没有相应的字体文件。比新版少一些接口，usb是使用的ATmega8u2而非16u2，复位键在中间，三端稳压不一样，功能方面和新版R3基本相同

**改良版**

改良版电路[查看](src/210702a01/Uno_ch340.jpg)

> 改良版就是将原ATmega16u2部分换成较为廉价的CH340，并且使用\#DTR作为复位信号

改良版（自摄）

![](images/210702a030.jpg)

背面

![](images/210702a031.jpg)


### 0.1.2 Arduino Nano

和UNO一样，Nano也有多种。Nano事实上是缩小版的UNO，同样使用ATmega328P，区别在usb部分。官方版一般使用FT232RL

**官方版**

原装英文版（引自Arduino官网）

![](images/210702a017.jpg)

官方盗版（自摄）

![](images/210702a032.jpg)

背面

![](images/210702a033.jpg)

> 官方版usb部分都采用FTDI的FT232RL

**改良版**

改良版（自摄）

![](images/210702a034.jpg)

背面

![](images/210702a035.jpg)

> 改良版usb部分使用CH340


### 0.1.3 Arduino Leonardo

Leonardo因为没有单独的usb电路，所以没有所谓改良版。主控采用ATmega32u4，封装可能不同。另有Arduino Micro，就是Leonardo的缩小版，它和Leonardo的关系类似于UNO和Nano的关系

官方版电路[查看](src/210702a01/Leonardo_R3.pdf)

**官方版**

原装英文版（引自Arduino官网）

![](images/210702a018.jpg)

背面

![](images/210702a019.jpg)

官方盗版（自摄）

![](images/210702a036.jpg)

背面

![](images/210702a037.jpg)


### 0.1.4 Arduino Mega 2560

Mega2560使用ATmega2560-16AU作为主控芯片，本质和328P差不多，IO较多

这里只给出官方图片

**官方版**

原装英文版（引自Arduino官网）

![](images/210702a020.jpg)

背面

![](images/210702a021.jpg)


### 0.1.5 Arduino DUE

Arduino DUE主控芯片为SAM3X8E，使用32位ARM Cortex-M3核心而非AVR，IO电平为3.3V，不属于常规AVR开发板，比起UNO、Mega 2560等传统Arduino，和STM32更加相近，这里仅展示其新旧两种版本

新版DUE电路[查看](src/210702a01/Arduino_Due_V2.pdf)

旧版DUE电路[查看](src/210702a01/Arduino_Due.pdf)

> DUE功耗较大，新版以及旧版使用的5V供电电路不同。旧版使用的是LM2734Y构建的分立开关电源，有一个较大的黑色方形电感，缺点是容易啸叫。新版采用集成式开关电源MPM3610

**官方版**

原装英文版（引自Arduino官网）

![](images/210702a013.jpg)

背面

![](images/210702a014.jpg)

> 原装进口一样也是很贵，一般要350左右，不差钱的可以考虑

旧版官方盗版（自摄）

![](images/210702a015.jpg)

背面

![](images/210702a016.jpg)

> 相比官方原版，没有安装RTC晶振（32.768kHz）。入手时全新50多米，比很多2560还便宜一些


## 0.2 Arduino电路结构解析

只给出UNO以及Leonardo两种开发板的电路分析，其他经典AVR衍生版基本同理

### 0.2.1 UNO

这里再放一下UNO R3的[pdf](src/210702a01/Arduino_Uno_R3.pdf)

> 官方版本的UNO事实上使用了两片AVR单片机，一片是直插式DIP28的ATmega328P，另一片是贴片TQFP32的ATmega16u2。ATmega16u2作为usb芯片拥有usb所需的电路模块，而其他方面较328P较弱。
>
> ATmega16u2相比328P拥有usb模块，而缺少了计数器/定时器2，I2C模块以及AD模数转换

**电源**

![](images/210702a025.png)

> 由上图分析。Arduino UNO支持从DC口以及USB供电，主要电路以及MCU全部使用5V供电，3.3V供电仅仅用于为LM358（作为比较器使用）提供参考电压（左上角），当然也可以通过3.3V接口向外设供电。通过DC供电时，设AMS1117输出5V正常，LP2985输出3.3V，那么只有当VIN大于6.6V时，MOS管FDN340P才会截止，此时完全使用1117的5V供电。如果此时VIN输入电压小于6.6V（或VIN未连接），此时MOS管导通，主要由USB供电
>
> 设置这个电路就是为了防止在同时连接VIN和USB时USB口电流倒灌损坏电脑
>
> 328P分为数字部分供电以及模拟部分供电，这里都使用5V，其中模拟部分AVCC输入串联一个10uH电感

**GPIO**

![](images/210702a026.png)

> UNO引出了328P所有的引脚。这些引脚可以做普通IO功能。其中，PC兼做AD输入以及I2C；PD包含了UART，外部中断，计数器输入以及比较器输入；PB包含了SPI
>
> UART通过1k电阻直接和16u2相连。AREF为ADC模拟参考电压输入，IOREF直连5V为扩展板提供IO参考电压。SPI另外引出到一个6pin接口ICSP，用于AVRISP烧录，一般用于烧录空芯片、修复BootLoader功能

**USB电路以及复位电路**

![](images/210702a027.png)

> USB部分以ATmega16u2为中心。16u2同样引出了专门的ISP接口可用于烧录固件，另外的4个引脚在ISP（ICSP1）接口旁边，一般不焊接排针。usb接口通过22欧电阻连接到16u2，16u2没有专门的复位按钮，只能通过ICSP1接口复位。16u2和328P一样使用了一个16MHz的晶振，封装不同。
>
> 16u2和328P之间有3条线连接，除UART之外（TX、RX指示灯使用16u2另外的GPIO），16u2的PD7还连接到了328P的**复位电路部分**，在通过usb下载程序时16u2会自动复位328P
>
> 通过观察可以发现，328P的复位引脚通过10k电阻上拉到5V，同时通过100nF电容连接到32u4的PD7，PD7通过1k电阻接地。
>
> 上电后，**16u2的PD7输出低电平**，328P的RESET脚为0V，之后10k电阻为100nF电容充电，\#RESET失效，328P开始工作。**下载时，16u2的PD7给出一个正脉冲即可实现328P的复位**。此时电容C5两端都为5V而被放电。在正脉冲的下降沿后，328P的RESET引脚瞬间又被拉低到0V，328P复位，之后328P内部的BootLoader进入到ISP模式，烧录开始


### 0.2.2 Leonardo

Leonardo R3的[pdf](src/210702a01/Leonardo_R3.pdf)

Leonardo只有一片ATmega32u4，基本相当于拥有了16u2和328P的功能，下载程序原理和UNO完全不同，32u4的BootLoader可以直接从usb读取并更新代码，同时32u4可以编程变为任意的usb设备（UNO的16u2也可以，但是由于IO很多未引出所以一般利用价值不大）。另外32u4支持JTAG

**电源**

Leonardo的电源部分和UNO基本相同，不再赘述

**GPIO**

![](images/210702a028.png)

> Leonardo除用于UART指示灯的IO之外引出了32u4其他所有的IO。除GPIO作用外，PF还包括了ADC输入以及JTAG功能；PD部分包含了4个外部中断，以及部分ADC输入，UART，I2C，计数器输入，PWM输出（OCxx），互补PWM输出（OC4x）；PE包含了比较器输入，6号外部中断以及BootLoader的选择性执行（可通过熔丝位配置）；PC包含了PWM输出，互补PWM输出以及AD输入0；PB包含了SPI，PWM输出，互补PWM输出，AD输入11，外部中断等
>
> 同样，Leonardo也将32u4的ISP单独引出，用于ISP烧录

**USB电路以及复位电路**

![](images/210702a029.png)

> 同样，usb接口通过22欧电阻连接到32u4的usb输入。而32u4在下载时的复位机制和UNO完全不同，在通过usb下载时32u4使用的是软件复位而不是通过硬件复位，所以在Windows下面开发会发现Leonardo会自动插拔。而经过观察发现，RESET在默认状态下只有通过一个10k电阻上拉到5V，复位只有通过按下按钮或将ISP端口的RST拉低


## 1 AVR单片机深入分析

主要以ATmega328P/16U2/32u4为例，参考数据手册

## 1.1 AVR简介以及内存架构

AVR CPU核心结构如下

![](images/210702a038.png)

主要的存储设备包括通用寄存器，特殊寄存器，RAM，ROM，IO寄存器，熔丝位等

AVR使用了哈佛结构，将数据（SRAM）以及指令存储区（Flash）分开并且独立编址。内部可以看作使用了简单的两级流水（预取指和执行），仅支持LOAD/STORE访存，有专门的IN/OUT指令可以用于IO内存区域的读写，并且使用了大量的通用寄存器，多达32个

AVR单片机系统结构如下

![](images/210702a040.png)

可以看到，SRAM和程序Flash使用不同的数据总线，各自单独编址


### 1.1.1 内部寄存器以及位于IO空间的寄存器

**内部寄存器**

8位版AVR拥有32个8位通用寄存器（另有AVR32，是32位机），编号从**R0**到**R31**，其中**R27:R26**组成**X**寄存器可以用于寻址，同理**R29:R28**组成**Y**寄存器，**R31:R30**组成**Z**寄存器

> **SREG**状态寄存器：拥有**I**中断使能、**T**位操作寄存器、**H**半进位标记、**S**符号标记（**N xor V**）、**V**溢出标记、**N**负值标记、**Z**零值标记、**C**进位标记。发生中断时不会自动保存和恢复，需要由中断服务软件实现
>
> **PC**程序计数器：指令地址，长度和单片机Flash容量有关（328P有32k字节的Flash，PC为14位长（16k words）），用户不可直接访问。**注意，PC每增加1，对应Flash中的2字节，而不是1字节**，这和之后的数据寻址不同，数据寻址以字节为单位

**IO空间寄存器**

> **RAMPX RAMPY RAMPZ**：分别用于和**X**寄存器**R27:R26**，**Y**寄存器**R29:R28**，**Z**寄存器**R31:R30**连接，用于支持大于64kB的间接寻址（SRAM或Flash）
>
> **RAMPD**：用于和**Z**寄存器连接，支持大于64kB的直接寻址
>
> **EIND**：用于和**Z**寄存器连接，支持长跳转指令
>
> **SP**栈寄存器：堆栈指针，长度16位，有的只有8位（SPL）。堆栈**自上向下**增长，使用到堆栈操作的指令主要有`PUSH POP ICALL RCALL RET RETI`


### 1.1.2 内存结构以及寻址方式

**程序Flash**

![](images/210702a041.png)

由于AVR指令长度为16或32，CPU使用PC取指时在程序Flash中也是2字节对齐的。**Flash分为两个部分，Bootloader区和应用程序区，两个区域相对独立**，有各自的熔丝控制位，以及不同的安全保护措施

Flash可以通过`ELPM LPM SPM`指令进行字节数据访问，使用**Z**寄存器作为指针，而`ELPM`会添加上**RAMPZ**寄存器，可以访问大于64k的空间

在不同单片机中`SPM`指令的执行流程可能不相同，**Flash只能以Page为单位进行擦除，有些单片机可以以word（2字节）为单位写入，而另一些单片机不支持word为单位的写入，只能以Page为单位写入，这样的单片机中会有一个Page Buffer，需要将缓冲写满以后一次性写入到Page**。一般使用**Z**寄存器作为指针，而使用**R1:R0**作为数据寄存器

这些指令也可以用于熔丝位的访问

> 和STC的51单片机直接将Bootloader固件写死不同，AVR的Bootloader可以更改，Flash同样支持读时写技术（Read While Write）。Bootloader是一段程序，如果复位后进入ISP模式，可以在被CPU读取执行同时，CPU对Flash本身数据单元进行擦除与烧写操作，甚至是Bootloader本身的数据。这样CPU可以从任意有效数据输入端更新Flash的数据，比如UART，USB等。而从ICSP进行下载由硬件支持，不依赖于Bootloader，可以用于Bootloader的修复

**SRAM**

![](images/210702a039.png)

SRAM分为4个区间，分别为**寄存器、IO寄存器、扩展IO寄存器、内部SRAM**

| 区间 | 地址范围 | 解释 |
| :-: | :-: | :-: |
| 寄存器        | 0x0000 ~ 0x001F | 32个通用寄存器R0 ~ R31 |
| IO寄存器      | 0x0020 ~ 0x005F | 共计64个，可以使用IO指令IN/OUT直接访问，使用地址0x0000 ~ 0x003F，也可以使用普通访存指令访问，使用地址0x0020 ~ 0x005F。这片区域的**低32字节（共256bit）**同样支持8051一样的**位寻址**，位操作指令有`SBI CBI SBIS SBIC` |
| 扩展IO寄存器  | 0x0060 ~ 0x00FF | 共计160个，只能使用普通访存指令访问，使用地址0x0060 ~ 0x00FF |
| 内部SRAM      | 0x0100 ~ | 只能使用普通访存指令访问 |

通用寄存器之间只能通过`MOV MOVW`传送数据，分别为传送单个寄存器和传送两个寄存器（word）

整个SRAM数据区可以通过`LD ST`指令进行字节数据访问，使用**X Y Z**寄存器作为指针，最多可以访问当前数据区64kB空间，如需要访问其他空间需要更改相应的**RAMP**寄存器

可以访问SRAM的还有堆栈指令

立即数装载指令`LDI`只能使用R16 ~ R31，例如`LDI R30,0x3D`，而直接地址装载指令`LDS`（长32位）可以使用所有的32个通用寄存器，例如`LDS R3,0x0F33`

**EEPROM**

EEPROM不可直接寻址，只能通过寄存器操作。EEPROM有**数据寄存器，地址寄存器，控制寄存器**三种寄存器。EEPROM擦写寿命大约是100000次


### 1.1.3 16位寄存器访问方式

由于AVR是8位机，所以不能直接处理16位寄存器，16位寄存器的读写需要通过两次操作。为保证16位寄存器的**所有位同时被读写**，AVR在内部使用了16位的临时寄存器，该寄存器对用户不可见

**AVR对16位寄存器高位和低位的读写顺序有明确要求**

**写操作**：写16位寄存器时，**需要先写高位，再写低位**。高位被写入时被存到临时寄存器中，之后在写入低位同时高位和低位共2字节数据同时被自动写入到16位寄存器中

**读操作**：读16位寄存器时，**需要先读低位，再读高位**。读取低位时高位会在同一时刻被自动传输到临时寄存器中，只要再次读取高位即可


### 1.1.4 引脚定义

**328P的引脚定义**

![](images/210702a049.png)

![](images/210702a050.png)

**32u4的引脚定义**

![](images/210702a051.png)

**16u2的引脚定义**

![](images/210702a052.png)


### 1.1.5 中断

不同AVR单片机的中断向量表也不同，因为不同单片机带有的外设模块不同

> **AVR中所有中断的优先级都是固定的不可更改的，优先级以中断向量表的地址为参考，地址越低的拥有越高的优先级，RESET复位中断拥有最高优先级**

**328P的中断向量表**

328P拥有2k字节的内部SRAM以及32k字节的Flash

![](images/210702a042.png)

**16u2的中断向量表**

16u2拥有512字节的内部SRAM以及16k字节的Flash

![](images/210702a043.png)

![](images/210702a044.png)

**32u4的中断向量表**

32u4拥有2.5k字节的内部SRAM以及32k字节的Flash

![](images/210702a045.png)

![](images/210702a046.png)

> 因为Flash分为Bootloader以及应用程序两个区域，可以通过熔丝位**BOOTRST BOOTSZ**以及**MCUCR**寄存器位**IVSEL**更改中断向量指令的实际位置，这在ATmega系列的单片机中通用，如下图，可以分别设置复位中断和其余中断的位置。**BOOTRST**用于设置RESET中断的位置，**BOOTSZ**用于设置Bootloader区域的大小

![](images/210702a047.png)

> 其中IVSEL位需要在IO寄存器**MCUCR**设置，地址为0x35（使用`IN OUT`）或0x55（使用`LD ST`）。**在对IVSEL进行更改之前，需要首先向IVCE写入1，此时会自动禁止中断，之后需要在4个时钟以内向IVSEL写值，同时需要将IVCE置0（写0xN2/0xN0）。如果超出4个时钟，IVCE会自动置0，写入失败**

![](images/210702a048.png)


## 1.2 外部中断

外部中断引脚分为两种，一种是普通的**INT**引脚，使用的是普通的INTx中断，一个引脚对应一个中断。另一种是**PCINT**（Pin Change）引脚，使用的是PCINTx中断，多个引脚共用一个中断

INT支持的4种中断形式有低电平中断，以及上升沿/下降沿/边沿触发中断，而PCINT仅仅支持引脚变化中断

**注意这些引脚即便是配置成输出也会触发中断**

|  | 328P | 16u2 | 32u4 |
| :-: | :-: | :-: | :-: |
| PCINT | PCI0..PCI2 | PCI0,PCI1 | PCI0 |
| INT | INT0,INT1 | INT0..INT7 | INT0..INT3,INT6 |

> 328P中一共有3个PCI中断，23个PCINT引脚，**PCI0对应引脚PCINT(7..0)，PCI1对应引脚PCINT(14..8)，PCI2对应引脚PCINT(23..16)**
>
> 16u2中有2个PCI中断，13个PCINT引脚，**PCI0对应引脚PCINT(7..0)，PCI1对应引脚PCINT(12..8)**
>
> 32u4中有1个PCI中断，8个PCINT引脚，**PCI0对应引脚PCINT(7..0)**
>
> PCI中断中的每一位可以通过对应的PCMSK0/PCMSK1/PCMSK2寄存器进行配置

外部中断控制寄存器主要有EICRx，EIMSK，EIFR，PCICR，PCIFR，PCMSKx六种寄存器


### 1.2.1 EICRx寄存器

用于控制**INTx**外部中断的触发方式，有4种可用方式

> 328P只有一个**EICRA**，2个INT中断，其中**ISC0x**配置**INT0**中断，**ISC1x**配置**INT1**中断，定义如下，**00代表低电平触发，01代表边沿触发，10代表下降沿触发，11代表上升沿触发**

![](images/210702a053.png)

![](images/210702a058.png)

> 16u2拥有**EICRA**和**EICRB**两个寄存器，8个INT中断，配置定义和上表相同

![](images/210702a054.png)

![](images/210702a055.png)

> 32u4拥有**EICRA**和**EICRB**两个寄存器，5个INT中断，地址和16u2相同

![](images/210702a056.png)

![](images/210702a057.png)


### 1.2.2 EIMSK寄存器

用于设置**INTx**中断屏蔽位

> 将328P的EIMSK寄存器中的**INT0**或**INT1**设为1，并且使能状态寄存器中的全局中断位I，允许相应中断

![](images/210702a059.png)

> 16u2的**EIMSK**，对应8个中断

![](images/210702a060.png)

> 32u4的**EIMSK**，对应5个中断，寄存器地址同上

![](images/210702a061.png)


### 1.2.3 EIFR寄存器

用于指示触发中断的**INTx**引脚号

> 在**INTx**触发中断时，328P的**EIFR**中的相应位会置1，在跳转进入中断服务程序之后相应位会自动置0，也可以向该位**写1**（注意不是写0）软件清除该位。**另外在低电平触发模式时这些位都不会置位**

![](images/210702a062.png)

> 16u2的**EIFR**，8个中断

![](images/210702a063.png)

> 32u4的**EIFR**，5个中断，寄存器地址同上

![](images/210702a064.png)


### 1.2.4 PCICR寄存器

一整组PCI的中断屏蔽

> 向328P的PCICR寄存器相应位**PCIEx**设为1可以使能相应的PCI中断，单独的引脚屏蔽位在**PCMSKx**设置

![](images/210702a065.png)

> 16u2的**PCICR**，2个中断

![](images/210702a066.png)

> 32u4的**PCICR**，1个中断，寄存器地址同上

![](images/210702a067.png)


### 1.2.5 PCIFR寄存器

指示**PCI**中断号

> 328P中的**PCIFR**寄存器，中断触发时对应位置1，并且会在跳转至中断服务程序时自动清0，也可以**写1**软件清零

![](images/210702a068.png)

> 16u2中的**PCIFR**，2个中断

![](images/210702a069.png)

> 32u4中的**PCIFR**，1个中断，寄存器地址同上

![](images/210702a070.png)


### 1.2.6 PCMSKx寄存器

一组PCI中单独引脚的中断屏蔽

> 328P拥有3个寄存器**PCMSK0**，**PCMSK1**，**PCMSK2**，可以将相应的位置1使能对应引脚中断

![](images/210702a071.png)

![](images/210702a072.png)

![](images/210702a073.png)

> 16u2拥有2个寄存器**PCMSK0**，**PCMSK1**

![](images/210702a074.png)

![](images/210702a075.png)

> 32u4只拥有1个寄存器**PCMSK0**，寄存器地址同上

![](images/210702a076.png)


## 1.3 时钟控制

AVR的时钟系统相比8051单片机要复杂很多，带USB功能的型号（16u2和32u4）有PLL锁相环用以提供USB所需48Mhz的时钟

### 1.3.1 328P的时钟系统架构详解

![](images/210702a077.png)

如上图，时钟系统以控制单元为核心，分5路输出到**定时器，GPIO，ADC，CPU和RAM部分以及Flash和EEPROM部分**，切断CPU时钟可以使CPU停止工作，而IO时钟提供给SPI，I2C，UART，定时器，外部中断使用（I2C的地址识别和时钟无关），定时器可以使用系统主时钟源也可以使用异步的外部时钟或低速的32.768khz外部振荡器（作为RTC使用）

系统时钟源可以选择外部时钟输入，外接晶振，低频外接晶振以及内部RC振荡器。而定时器和看门狗可以使用独立的振荡器

**系统主时钟源**

> 328P支持多种不同的主时钟源，可以通过熔丝位设置，用于配置时钟源的熔丝位都位于三个熔丝字节的最低一个字节（参考[1.14熔丝位](210702a_avr.md#114-熔丝位)），如下

![](images/210702a081.png)

> 其中，**CKDIV8**用于配置是否对输入的系统时钟进行8分频，置1不分频。
>
> **CKOUT**用于配置是否在引脚**PB0**进行时钟输出。
>
> 而**SUT**指Startup Time，因为单片机的**振荡器在开始工作的时候有一个逐渐稳定的过程**，此时单片机还不能开始工作，所以需要设定一个在上电到复位信号失效的延时，通过**SUT**设置。**SUT一般设为默认的最大延时即可**

> 328P一共可配置使用6种不同的主时钟源，通过熔丝位**CKSELx**配置时钟，出厂时默认0010，使用内部的RC振荡器（8.0Mhz），定义如下
>
> ![](images/210702a080.png)
>
> 可用的时钟源中，选择**External Clock外部时钟**需要在**XTAL1**引脚输入时钟，并且时钟不能有超过2%的变化，如果需要调节频率要通过**预分频器**调节，**SUT**设为10
>
> 选择**128k内部RC振荡器**会使用单片机自带的低功耗RC振荡器，此时单片机引脚XTAL1和XTAL2可以当作GPIO使用。此种模式振荡器精准度较低，**SUT**设为10
>
> 选择**内部RC振荡器**会使用单片机自带的高速RC振荡器，频率为8Mhz左右，此时单片机引脚XTAL1和XTAL2可以当作GPIO使用，可以通过**OSCCAL**寄存器进行校准，**是出厂默认设置**，**SUT**设为10
>
> 选择**低频晶体振荡器**会使用到外接的晶振，一般为32.768khz，连接在TOSC1和TOSC2引脚（和XTAL1和XTAL2共用引脚），这种模式一般用在启动时震荡频率不敏感的场合。该种模式下**CKSEL**一般设为0101，**SUT**设为10
>
> 选择**Full Swing（满幅）全功率晶体振荡器**同样需要使用到外部晶振，比如Arduino使用的是16Mhz的晶振，此时振荡放大器以满功率工作（XTAL2输出满幅），晶振连接在XTAL1和XTAL2引脚，**这也是最常用的配置方式**，适用于干扰较重的场合。该种模式下一般使用400k到20Mhz晶振，12到22pF电容，**CKSEL**设为0111，**SUT**设为11
>
> 选择**低功耗晶体振荡器**晶振连接和常用的Full Swing模式类似，区别是此时震荡放大器不是满功率输出，较为省电，但是容易受干扰影响。该种模式需要根据震荡频率设定**CKSEL**，一般使用900k到16Mhz晶振，12到22pF电容，**SUT**设为11。使用900k到3Mhz振荡器**CKSEL3..0**设为1011，3Mhz到8Mhz振荡器**CKSEL3..0**设为1101，8Mhz到16Mhz振荡器**CKSEL3..0**设为1111

**相关配置寄存器**

**OSCCAL寄存器**

OSCCAL寄存器用于设置**RC振荡器**的校正系数

![](images/210702a082.png)

> OSCCAL寄存器有一个出厂设定值，这个值在单片机复位时会自动写入到该寄存器。可以在运行时通过程序调节，大约在7.3Mhz到8.1Mhz之间调节，一般用不上

**CLKPR寄存器**

CLKPR寄存器用于设置时钟的预分频系数

![](images/210702a083.png)

分频系数定义如下

![](images/210702a084.png)

> 其中，**CLKPCE**位是更改使能，**CLKPSx**为分频系数设置。**在复位时熔丝位CKDIV8的值会决定CLKPSx的初值，如果CKDIV8为0那么默认CLKPSx=0011（8分频）**。设置分频的步骤如下
>
> 1. 向CLKPR写入0x80（即置CLKPE为1，其余位为0）
>
> 2. 在之后4个周期以内同时向寄存器写入0x0N（即设置CLKPS的值同时置CLKCE为0）


### 1.3.2 16u2的时钟系统架构详解

![](images/210702a078.png)

16u2相比328P去掉了定时器的异步时钟源，并且由于没有ADC模块所以也没有ADC时钟输出。16u2有usb模块，所以需要使用**PLL**提供48Mhz的高频时钟。PLL的时钟虽然和系统时钟使用同一个时钟源，但是相对系统时钟独立，**拥有自己的预分频配置**。由于PLL始终将时钟乘以6，而USB的标准频率是48Mhz，所以**PLL预分频之后需要提供一个8Mhz的时钟**

和328P只能通过熔丝位配置时钟源不同，**16u2支持使用软件通过寄存器配置时钟源**

16u2熔丝位低字节位定义和328P完全相同，这里不再赘述

**系统主时钟源**

> 由于16u2不支持低速32.768khz的时钟源，所以**CKSELx**熔丝位的定义也稍有不同，0101 ~ 0100不再有用，其余有关系统主时钟源配置的定义和328P完全相同
>
> ![](images/210702a085.png)
>
> 出厂时16u2的**CKSELx**熔丝位默认配置为0010使用内部RC振荡器，**SUT**默认配置为10为最大，**CKDIV**默认配置为0使用8分频

**PLL时钟源**

这是16u2相比328P增加的部分

> PLL的结构如下，相关配置位定义见寄存器配置
> 
> ![](images/210702a086.png)

**相关配置寄存器**

16u2除了拥有**CLKPR**以及**OSCCAL**寄存器以外，还添加了**CLKSEL0**，**CLKSEL1**（注意不是熔丝位CKSEL），**CLKSTA**，**PLLCSR**共4个寄存器

**OSCCAL寄存器**

和328P定义完全相同，略

**CLKPR寄存器**

略

**CLKSEL0寄存器**

和328P不同，16u2支持通过寄存器软件更改时钟和振荡器参数。**CLKSEL0**用于设置**SUT**参数以及振荡器的选择与开关，定义如下

![](images/210702a087.png)

> 其中，**RCSUTx**用于设置**使用RC振荡器**时的SUT参数，在启动时熔丝位**SUTx**会**自动装载**到此处。设置这两位**没有任何作用**所以维持默认值即可
>
> **EXSUTx**寄存器同理，用于设置**使用外部振荡器或晶振**时的SUT参数，区别是更改该两位之后重启振荡器会生效（RC振荡器不可重启）
>
> **RCE**和**EXTE**分别作为RC振荡器和外部/晶体振荡器的**开关**，置1开启置0关闭
>
> **CLKS**用于设置时钟源类型，置1使用外部/晶体振荡器，置0使用RC振荡器。**该位会在复位后根据熔丝位的设置自动选择**

**CLKSEL1寄存器**

该寄存器用于设置使用相应时钟时的**CKSELx**参数（启动时从熔丝位自动装载到**相应位**）

![](images/210702a088.png)

> **RCCKSELx**用于设置在使用RC振荡器作为时钟源时的CKSEL。由于RC模式只能设置为0010，所以更改无效，维持默认值即可
>
> **EXCKSELx**用于设置在使用外部/晶体振荡器作为时钟源时的CKSEL。区别是可以更改SUT参数，在clock switch之后生效

**CLKSTA寄存器**

该寄存器用于指示时钟源状态，1为开启0为关闭，定义如下

![](images/210702a089.png)

> **RCON**指示RC振荡器状态，**EXTON**指示外部/晶体振荡器状态

**PLLCSR寄存器**

该寄存器专用于PLL配置，**划重点**，定义如下

![](images/210702a090.png)

> 参考PLL的电路结构
>
> ![](images/210702a086.png)


### 1.3.3 32u4的时钟系统架构详解

![](images/210702a079.png)




## 1.4 GPIO

AVR的GPIO结构相比8051也要复杂很多，功能更加强大

### 1.4.1 GPIO基本结构

### 1.4.2 328P的GPIO

### 1.4.3 16u2的GPIO

### 1.4.4 32u4的GPIO


## 1.5 SPI

## 1.6 I2C

## 1.7 UART

## 1.8 ADC以及比较器

## 1.9 USB

## 1.10 定时器

## 1.11 单片机的复位和Watchdog看门狗

## 1.12 BootLoader相关

BootLoader作为AVR单片机启动时运行的第一个程序，具有很重要的作用。通过UART的在线程序下载就是由BootLoader软件实现


## 1.13 AVR ISP下载协议

Atmel的AVR单片机通用的下载协议，通过SPI（ICSP）接口下载，由硬件支持所以和BootLoader无关，可以用于更新修复BootLoader等


## 1.14 熔丝位

熔丝位一般用于配置一些基础参数以及安全设置

> 事实上STC的8051单片机也有熔丝位，比如指令时钟的调节，以及ALE引脚的设置，就是通过编程软件更改熔丝位设置实现

**更改熔丝位一定要三思，否则单片机很容易变砖，只能通过高压编程（通过专用的高压编程接口，需要在\#RST输入12V）或强行输入时钟的方法修复**

包括ATmega328P，16u2，32u4的熔丝位，以及作用


## 1.15 熔丝位设置错误解决方法

熔丝位设置错误一般可以通过输入外部时钟修复。但是如果设置使用了内部时钟，就只能通过高压编程器恢复了

这里提供这两种方案的具体实现，并且会提供一种可行的高压编程器的DIY方案


## 2 从零开始搭建开发环境

从零开始的AVR开发环境，包括了软件的安装，环境的配置，工具链的使用，Makefile的编写等

## 2.1 为什么要从零开始

直接用Arduino IDE不香吗awa

~~那就从1开始~~

Arduino IDE适用于没有硬件基础的初学者，开发一些简单的应用。作为使用sdcc51入门8051的强迫症患者，~~我们要学会刀耕火种~~，摆脱对Arduino开发环境以及软件框架的依赖，了解工具链的工作流程以及Makefile的编写（Arduino IDE事实上也不好用，不支持代码提示，基本没有管理大型工程的能力，而且bug不少，当你开发大项目的时候就会后悔了，而且在单片机上滥用C++一定程度会降低代码效率）

> 据说最近Arduino出了一个新的Arduino IDE 2.0，目前（2021.7.24）处于beta阶段。试了一下，果然是套皮VSCode


## 2.2 工具链

## 2.3 烧录以及仿真

使用两种方法，和Arduino IDE一样使用串口（依赖于Bootloader），以及使用ISP编程


## 2.4 Makefile

## 2.5 VSCode配置

## 3 开发示例

## 3.1 GPIO操作

## 3.2 时钟

## 3.3 定时器

## 3.4 SPI

## 3.5 I2C

## 3.6 UART

## 3.7 ADC

## 3.8 比较器

## 3.9 PWM

## 3.10 中断编程示例

## 3.11 编写一个Bootloader

## 3.12 编写一个16u2的固件
