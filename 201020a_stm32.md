# ARM Cortex-M体系结构研究，STM32学习笔记（基于GNU工具链）

## 参考资料

*《ARM Cortex-M3与Cortex-M4权威指南（第3版）》，Joseph Yiu，2015.11，清华大学出版社*


## 1 ARMv7-M体系结构

## 1.1 简介

目前在低功耗微控制器中最主流的32位ARM核心有Cortex-M3以及Cortex-M4。这两种核心都使用**3级流水线**，**哈佛总线结构**，以及**统一的内存地址空间**，总共可以寻址**4GB**

Cortex-M核心内建了中断控制器系统，称为**NVIC**（Nested Vectored Interrupt Controller），中文翻译为**嵌套向量中断控制器**，是属于核心的一部分。它支持最多240个中断请求以及8到256个中断优先级（具体要看实际的核心配置，一般是8到16级优先级居多）

Cortex-M支持在一个MCU系统中集成多个处理器核心

另外Cortex-M还支持可选的MPU，用于提高运行时内存的安全性（在Cortex-M3、M4中如果没有特殊需求一般MPU用处不是很大，在Cortex-M7中由于缓存的存在所以需要使用到MPU的部分功能）


## 1.2 ISA与微架构概览

由于MCU存储资源有限，为压缩程序大小，ARMv7-M的CPU只支持Thumb-2，不支持32位的ARM指令集。该指令集是对旧有Thumb指令集的扩展，是16位（2字节）或32位（4字节）可变长度的。其中很多常用指令都使用16位编码以减小代码长度

+ 支持硬件除法

+ 支持字节（B）、半字（H）、单字（W）、双字（D）存储器访问与数据操作，可变的大小端模式

+ 支持累乘加`MAC`以及饱和指令

+ 支持多种跳转以及函数调用指令

Cortex-M4相比Cortex-M3多出了一些适用于DSP的指令，比如对于浮点数的硬件支持，以及SIMD指令等


### 1.2.1 架构，系统总线与中断控制

**架构**

ARMv7-M的处理器为典型的32位机，其通用寄存器（GPR），数据总线，总线接口都是32位，寻址也是32位所以总共支持4GB的内存空间。不同于8051等早期单片机，ARM使用统一的内存架构，包括SRAM，程序Flash以及各种外设寄存器等都位于相同的内存空间，拥有唯一的地址。这些使用ARM Cortex-M核心的MCU既可以在Flash中运行程序，也可以将程序放到SRAM中运行

**总线**

之前说过Cortex-M3，Cortex-M4都是使用3级流水线的哈佛结构，取指令和存取数据可以同时执行，当然前提是指令和数据不使用同一条总线。程序指令可以放在Flash或SRAM，而运行时RAM只能使用SRAM。**一般在一个MCU中会有多片SRAM以及Flash，尽管它们使用统一的内存编址，这些存储器都拥有物理上独立的总线。CPU核心以及DMA等通过总线交换矩阵和它们连接，可以同时访问不同的存储器**。这种情况下，如果将指令和数据放在同一片SRAM中将会导致总线冲突，降低流水线效率，**建议指令和运存不要使用同一片存储器**。以下是STM32F4中典型的总线结构

![](images/201020a015.png)

基于Cortex-M的MCU内部都使用了AMBA标准总线，该标准由ARM规定。MCU中常见的有两种总线类型：**AHB Lite**以及**APB**。AHB总线是系统高速总线（矩阵），运行频率高，一般用于连接CPU，SRAM，Flash，DMA，APB桥，DMA-USB等。而APB用于一些低速IO外设，如I2C，SPI，USART，CAN，ADC，DAC等，**APB总线通过APB桥挂接到AHB总线**。有些MCU中的APB也分为低速APB和高速APB

Cortex-M0以及Cortex-M0+属于ARMv6-M，并且使用冯诺依曼结构。这两种核心功耗较低，门电路数量少

**中断**

对于所有Cortex-M核心，NVIC的寄存器地址都是固定且相同的，并且也是使用和SRAM、Flash以及外设IO相同的地址空间。NVIC的编程模型都是相同的。NVIC支持**外设中断**，**NMI不可屏蔽中断**以及**处理器内部异常**等多种异常和中断，总共最多支持240个中断，除NMI以外所有中断都可以单独使能或禁止。NVIC还支持中断的屏蔽功能。Cortex-M3以及M4的中断优先级可以在运行时修改，Cortex-M0和M0+不支持该功能。中断向量取出由CPU硬件自动实现，无需软件判断中断源，同时中断向量表可以重定位映射到不同的地址（默认位于地址0x00）


### 1.2.2 指令集ISA

以前更老的ARM处理器以及现在的Cortex-A核心一般支持32位ARM指令。32位的ARM指令相比Thumb以及Thumb-2在执行时具有更好的性能，但是程序较大。为优化程序大小一般需要在ARM执行模式以及Thumb模式下来回切换

由于面向MCU市场的需求，ARMv7-M直接舍弃了庞大的ARM指令。所有的Cortex-M核心（包括ARMv6-M的Cortex-M0以及M0+）都只支持Thumb-2的不同子集，ARMv7-M的处理器兼容ARMv6-M所有的指令。这些处理器也舍弃了部分在旧有Thumb中的指令，如协处理器指令，指令集状态切换指令等

绝大多数使用Cortex-M4核心的MCU都为核心配备了FPU（带FPU的M4核心），支持额外的FPU指令。而Cortex-M3没有FPU的支持


### 1.2.3 OS支持特性

Cortex-M3和M4带有SysTick节拍定时器，同时提供了两个栈指针`MSP`和`PSP`，分别用于OS和用户进程。在一般的应用中如果不使用OS特性，可以只使用`MSP`

另外，这两种CPU核心还支持特权以及非特权模式。在一般的应用中默认使用的是特权模式。非特权模式一般要在RTOS中的用户程序中才会涉及到，这种模式会限制用户对于一些模块如NVIC的访问


### 1.2.4 工作模式

Cortex-M3和M4处理器有2种运行状态，分别为**Thumb状态**以及**调试状态**。其中**Thumb状态**分为2种操作模式，执行中断或异常处理程序时为**处理模式**，正常执行程序时为**线程模式**。另外Cortex-M3和M4核心除一般的**特权模式**以外还支持**非特权模式**（Cortex-M0不支持）

状态转换示意图如下，一共可以分为3种主要的工作模式

![](images/201020a003.png)

其中特权模式到非特权模式的转换是单向的，非特权模式想要到达特权模式只能通过异常来处理。执行中断或异常时称为处理模式，这种处理模式权限上和特权模式类似。非特权模式可以保护NVIC的寄存器，防止用户程序篡改。另外在支持非特权模式的处理器（M3和M4）中，之前说过物理上有2个`SP`寄存器，一个用于特权模式，另一个用于非特权模式


## 1.3 常用软硬件以及程序架构

一般情况下，MCU厂商提供的SDK中除了各自的MCU外设库以外都会包含CMSIS（Cortex-M Software Interface Standard，由ARM提出并开发）。这个软件库包含了各种基本的库与头文件，以及针对各种Cortex-M核心的专有功能与对应函数（比如DSP函数库）

开发环境方面，以前最流行的就是Keil MDK和IAR了。然而现在各路MCU厂商都开始大力推广自家的开发环境，典型的有ST的STM32CubeIDE（基于Eclipse），TI的CCS（基于Eclipse），Microchip的Atmel Studio（基于Visual Studio）等。以前的Keil使用ARMCC编译器（现在MDK最新版已经转向基于LLVM的定制版工具链），而现在越来越多的厂商开始使用GNU工具链。这也是总趋势

在运行调试方面，一般的MCU都支持JTAG和SWD两种调试接口。目前常用的调试硬件有JLINK，ULINK以及开源的CMSIS-DAP（Debug Access Port）。其中CMSIS-DAP由于其开放的特性，近几年已经得到广泛的采用。CMSIS-DAP其实就是一种开源的调试器固件实现，走USB-HID所以在所有操作系统平台免驱，用户可以对固件进行适当的更改以后下载到一个廉价的小型开发板上将开发板变成一个调试器（最流行的就是BluePill）。而调试上位机除了各IDE集成的以外，目前在开源平台最流行的就是OpenOCD

如果想要在Linux平台开发ARM单片机，并且想要使用开源工具集，那么最少需要ARM的GNU工具链（arm-none-eabi-gcc），OpenOCD，Make等，再使用一个小核心板烧录CMSIS-DAP固件作为调试器即可

在Windows平台可以安装MSYS2使用MINGW提供的工具链


### 1.3.1 编译流程

在PC上编译单片机程序就是交叉编译。关于编译器基本原理，GNU工具链的组成与工作流程可以见[笔记](210731a_llvm.md#11-编译器基本工作流程)

编译单片机程序时，一般首先需要提供一个`.s`启动文件。这个启动文件使用汇编语言编写，相当于单片机的Bootloader，单片机在上电时会首先执行该程序对时钟等部件进行初始化，建立一个可用的程序执行环境，再调用`main()`函数入口开始执行用户程序

![](images/201020a002.png)

如上图，编译一个单片机程序，需要将所有的`.c`源代码以及`.s`汇编代码全部编译为`.o`可重定位二进制文件，最终通过`ld`链接器链接成为可执行映像。其中`ld`链接过程需要用到的链接器脚本有时会随厂商的开发环境发布。实际的应用中建议直接使用`arm-none-eabi-gcc`命令自动调用工具链


### 1.3.2 程序设计

**轮询**

轮询是最傻瓜式的程序结构，基本原理就是将整个重复的工作流程编写成为一个大循环，两次循环之间一般会加入软延时（一般是`delay()`函数）。这种程序经过恰当的设计可以实现功能，但是缺点很多：代码难以维护，循环间隔时间难以控制，能耗比差，CPU利用率较差，反应迟钝等。只适合在初学者在要求不严格的场合使用。最典型的程序就是基于软延时的Blink

**中断**

实际的应用中建议使用**定时器中断驱动**结合**状态机**的程序设计模式。这种工作模式下，定时任务不依赖CPU的软延时，而是依赖定时器产生的中断。而无法预测的突发事件同样通过中断服务程序处理。事实上中断系统才是单片机良好工作表现的根本保证，在具有优先级管理的单片机中，更高级别的中断可以打断低级别的中断程序。这种工作模式下，定时任务会有精准的时间间隔，突发事件也可以得到及时的响应。同时CPU在无任务执行时可以进入休眠或最低功耗模式，节省能源。各类操作系统也是建立于定时器中断技术之上的

**RTOS实时操作系统**

随着MCU程序的不断复杂化，有时会遇到更加复杂的控制需求，比如多个任务同时执行的需求，这种情况下使用中断程序已经难以满足要求，就需要用到时间片轮转等方式，需要一个调度器。这种情况下可以使用线程调度库或RTOS，这些RTOS一般还有信号量，队列以及消息等特性。但是使用RTOS会占用更多的资源，有些低端MCU限于内存与Flash大小很难使用RTOS，这就要结合实际进行权衡。目前已经有上百种开源RTOS，这些RTOS也是学习操作系统原理的良好选择，相比传统庞大的系统如Linux等更易于上手，同时RTOS一般还有更高的实时响应性能与执行效率，更加适合工控等领域


## 1.3.3 CMSIS

CMSIS由ARM提出并被所有使用ARM核心的MCU厂商所采用，目的是保证单片机软件的复用性，兼容性，可移植性，工具链独立性以及开放性，开发者可以通过这些代码访问Cortex-M处理器的各种特性。CMSIS还提供了DSP算法的高效实现，以及RTOS的API定义，避免开发者重复造轮子造成混乱。CMSIS-DAP调试器也是属于CMSIS项目的一部分

CMSIS包括但不限于以下功能：

+ 和处理器有关的部件的寄存器定义，如中断控制器NVIC，节拍定时器SysTick以及SCB的寄存器定义等，以及和这些外设有关的C函数（API）

+ 用于特殊指令的C函数（否则要使用内联汇编实现），如`WFI`

+ 为各种异常处理进行了命名

+ 系统的初始化函数（`SystemInit()`，对于不同的MCU该函数有不同的实现）

+ 时钟频率数值的获取

+ 常用DSP函数的实现

CMSIS事实上是可有可无的，程序开发者不使用CMSIS提供的各种定义也可以实现功能，但是建议普通开发者还是充分利用CMSIS提供的函数与功能，避免重复冗余的劳动


## 1.4 寄存器和内存架构

### 1.4.1 通用寄存器组GPR

定义如下

![](images/201020a004.png)

> 其中，`R0`到`R12`可以分为高低两组，低组8个为`R0`到`R7`，高组5个为`R8`到`R12`。限于Thumb指令的长度要求，**绝大多数16位长度的指令都只能使用低8个寄存器**。而高5个寄存器只有32位指令以及少数16位指令可用
>
> `R13`寄存器又称为`SP`，作为栈指针使用，一般不做其他用途。栈是RAM中的一片空间，用于放置局部变量，以及在函数或子程序调用、中断处理时保存寄存器现场。在Cortex-M3和M4中两个物理上的寄存器分别为`MSP`和`PSP`，分别用于**特权模式**以及**非特权模式**。在运行过程中，当前使用到的寄存器是`MSP`还是`PSP`由特殊寄存器`CONTROL`的设置决定，一般只有RTOS才会涉及到`PSP`的使用。**在ARM中栈是从高地址向低地址生长的**，同时**栈访问必须是4字节对齐的**，所以事实上`SP`的低2位没有作用，总是00。另外，**复位后`MSP`的初始值是从中断向量的最开头4字节取出的**
>
> `R14`寄存器又称为`LR`，作为链接寄存器使用。在程序中如果发生了函数或子程序调用，`LR`寄存器会自动保存该函数返回时的地址。在函数与子程序运行结束以后，`LR`中的地址就会被加载到`PC`中，CPU就可以返回到原来的地方继续执行。然而在中断程序中情况不是这样，`LR`会被更新为特殊值`EXC_RETURN`，这会在之后的中断中讲到。此外，在处理子程序调用时同样不要忘记将`LR`压栈，否则当前代码返回的地址就丢失了。因为Cortex-M的Thumb-2指令集是2字节或4字节可变长的，所以**指令的访问是2字节对齐的**，~~LR最低位看似没有意义~~。然而`LR`的最低位事实上是有意义的，部分调用指令需要**将`LR`最低位置1表示使用Thumb状态**（**这是Cortex-M在舍弃掉ARM指令后的遗留问题**）
>
> `R15`寄存器又称为`PC`，作为程序计数器使用。由于ARM处理器的流水线结构，读取`PC`获得的地址是**当前正在执行指令的地址加4（两条2字节指令长度）**。使用一般寄存器指令写`PC`寄存器会触发跳转。和`LR`寄存器类似的，使用部分跳转指令或寄存器指令操作`PC`时，需要将最低位置1表示Thumb。一般情况下函数调用以及跳转会使用子程序调用指令实现，而不是使用一般寄存器指令写`PC`。但是在访问连续的常量字符数据时可以将`PC`作为基址寄存器使用


### 1.4.2 特殊寄存器

定义如下

![](images/201020a005.png)

特殊寄存器只能通过`MRS`以及`MSR`指令进行访问，在通用寄存器以及特殊寄存器之间传输

**`PSR`寄存器**

`PSR`寄存器是程序状态寄存器，物理上一共有3个`PSR`寄存器，分别为`APSR`应用PSR，`IPSR`中断PSR和`EPSR`执行PSR。这3个PSR在汇编中可以通过符号`PSR`访问，另外也可以使用符号`APSR`和`IPSR`访问指定的PSR（符号`EPSR`不能访问，符号`IPSR`只读）。这3个寄存器的定义如下

![](images/201020a006.png)

![](images/201020a007.png)

各位的作用如下

![](images/201020a009.png)

> 其中`N`位代指Negative，如果一次整数运算导致寄存器最高位为1那么该位置1。可以用于判断结果正负
>
> `Z`位代指Zero，如果一次计算导致寄存器所有位为0那么该位置1。类似`CMP`指令同样可以将该位置1（相当于没有输出寄存器的减法）
>
> `C`位代指Carry，指示无符号运算进位。在加法中如果在最高位产生进位那么该位置1，减法看作补码加法处理。可以用于计算64位整数（C中为long long）
>
> `V`位代指Overflow，指示有符号运算溢出。所谓溢出就是如加法中正正得负或负负得正的情况，看最高位。加法（减法看作补码加）中设操作数1符号S1，操作数2符号S2，输出结果符号S3，那么$ V = (\overline{S_1}\overline{S_2}S_3)+(S_1S_2\overline{S_3}) $
>
> `Q`位用于饱和运算指令中表示发生了饱和。饱和运算一般用在DSP算法中，如果两个数相加会导致溢出那么就将结果设为可表示的最大或最小值。**该位一旦置位需要软件清零**，不会自动清零，且和条件指令`B`或`IT`无关
>
> 此外，`GE`用于Cortex-M4的整数SIMD指令。而`T`是舍弃ARM指令集以后的遗留，置1表示运行在Thumb指令模式下
>
> `IT`位共计8位，用于`If-Then`的执行以及可中断的`LDM`、`STM`指令。用于`IT`指令时称为`ITSTATE`

Cortex-M的PSR寄存器定义和其他ARM处理器（ARM7，ARM9，ARM11，Cortex-A等）有所不同，具体对比如下

![](images/201020a008.png)

**`PRIMASK`，`FAULTMASK`以及`BASEPRI`寄存器**

在ARM中，**中断优先级数字越小优先级越高**。这3个寄存器用于控制中断的屏蔽，作用和Cortex-A中的`I`（IRQ）和`F`（FIQ）位类似，**只能在特权模式下访问**，可以使用`MRS MSR`或`CPS`指令更改，如下

![](images/201020a010.png)

> `PRIMASK`只有最低一位有效，置位时将当前执行优先级设为0，会屏蔽除NMI（不可屏蔽中断）以及HardFault以外所有的异常和中断。异常返回以后不会自动清零
>
> `FAULTMASK`同样只有最低一位有效，置位时临时将当前优先级设为-1，会屏蔽除NMI以外的所有异常和中断，一般用于HardFault错误处理流程中，防止发生新的错误造成灾难性后果。异常返回后**会自动清零**
>
> `BASEPRI`的有效位位于该寄存器最后8位，长度需要看具体的处理器配置，依据优先级屏蔽中断以及异常。一般的Cortex-M3和M4都是配置为8到16级优先级，所以有效位一般为3到4位。将`BASEPRI`设为0时屏蔽不起作用，设为非0时**会屏蔽小于等于设定优先级的中断**
>
> 另外，部分ARMv6-M核心没有FAULTMASK以及BASEPRI寄存器

**`CONTROL`寄存器**

该寄存器用于控制线程模式下的特权等级，使用的栈指针，以及指示目前是否在使用FPU，定义如下。在更改`CONTROL`寄存器以后应该执行一下`ISB`同步屏障指令使得此次更改对接下来的指令生效

![](images/201020a011.png)

> `nPRIV`只在线程模式下有效，**默认置0**处于特权模式，置1处于非特权模式，**并且置1以后无法再访问`CONTROL`寄存器（只能通过发起异常返回到特权模式更改，异常处理状态下可以任意更改，该异常处理程序属于操作系统实现的一部分）**
>
> `SPSEL`用于选择使用`MSP`还是`PSP`，**默认置0**使用`MSP`，在线程模式下可以置1使用`PSP`。在处理模式下永远为0且不可更改
>
> `FPCA`只在带FPU的Cortex-M4核心中才有，如果是1**表示当前正在使用FPU**，在调用函数时需要记得保存FPU寄存器内容。在执行FPU指令以后`FPCA`会自动置位，而在异常入口处`FPCA`会自动清0，同时将FPU寄存器数据压栈。注意，如果在浮点计算上下文中`FPCA`被意外清零，那么接下来一旦发生异常或中断就会导致错误（未将FPU数据压栈）

一般的应用场景参考如下

![](images/201020a012.png)

> **解释**：
>
> 之前说过有3种执行模式，分别为**线程模式的非特权模式**，**线程模式的特权模式**以及**处理模式**
>
> 线程模式的特权模式可以有两种情况，使用`MSP`和使用`PSP`。前者00用于OS内核的运行，后者01用于特权程序的运行
>
> 线程模式的非特权模式一般只会使用`PSP`（虽然也可以使用`MSP`，但是对于大部分OS来说不会这么做）。对应11（一般不会使用10），用于非特权程序的运行。
>
> 处理模式只能使用`MSP`。在该模式下`nPRIV`位没有影响，可以任意更改（处理模式下程序本身永远处于特权模式，它有一个重要作用就是负责判断非特权模式和特权模式之间的切换），对应00或10用于绝大多数的异常以及中断程序
>
> **总之，在没有使用到OS时，无需改动`CONTROL`，使用默认的00（特权模式，`MSP`）就行。这也是绝大多数一般MCU程序的工作模式**。很多简单的OS甚至只运行在特权模式下，不会使用到非特权模式，只是充当简单的调度器使用


### 1.4.3 FPU寄存器

FPU是Cortex-M4的可选部件

**`S0`到`S31`数据寄存器**

![](images/201020a013.png)

> `S0`到`S31`寄存器单个长度为32位，可以存放一个单精度浮点数；其中两两还可通过`D0`到`D15`访问，单个长度为64位，可以存放一个双精度浮点数，但是Cortex-M4的FPU不支持双精度运算

**`FPSCR`状态以及控制寄存器**

![](images/201020a014.png)

位域定义如下

![](images/201020a016.png)

![](images/201020a017.png)

> 这些状态位以及控制位的作用可以参考IEEE754中相关内容，包括舍入，NaN等。`IDC`即**Input Denormal**，`IXC`即**Inexact**，`UFC`即**Underflow**，`OFC`即**Overflow**，`DZC`即**Divide by zero**，`IOC`即**Invalid Operation**

除了内置的`FPSCR`，还有位于内存空间的`CPACR`寄存器，用于使能浮点单元（默认关闭）

![](images/201020a018.png)


### 1.4.4 内存

前面说过Cortex-M为统一内存设计，只有一个内存地址空间。这些内存空间事实上被ARM划分成为几个区块，这些区块有固定功能。如SRAM和程序代码（Flash）可以并行访问。同时所有ARMv7-M的处理器都支持非对齐访问，并且**32位指令也可以对齐单字（4字节）或半字（2字节）**

![](images/201020a019.png)


### 1.4.5 栈

前面说过寄存器`R13`也被称为`SP`堆栈指针。堆栈使用`PUSH`和`POP`分别进行压栈和出栈操作

> 栈一般有以下几个功能：
>
> 在中断处理或函数、子程序调用时，保存寄存器现场
>
> 存储局部变量
>
> 向函数或子程序传参

ARM中的`SP`使用**满递减**方式（栈**自顶向下**生长）工作。`PUSH`时，`SP`先减小，后将要压栈的寄存器内容存储到当前`SP`所指地址（32位就是先减4后压栈，相当于存到栈空间最后4个字节。`SP`初始值应该为栈空间**最高地址+1**，最低2位永远为0）。`POP`时相反，先输出数据到寄存器后`SP`才增大


## 1.5 NVIC：中断与异常处理

![](images/201020a020.png)

NVIC可以接受外设中断IRQ，NMI，节拍定时器SysTick（用于操作系统节拍或中断运行方式），以及处理器抛出的异常作为输入源。优先级以及编号如下，最多可以配置核心支持255个异常和中断源，其中外设IRQ中断最多可以240个

NVIC包含了`SCB`系统控制模块，其中的`VTOR`用于中断向量表的重定位

![](images/201020a021.png)

![](images/201020a022.png)

> NVIC接受高电平作为中断触发，可以是脉冲（自动维持高电平）或电平触发（需要中断源维持高电平）。在中断、异常到来时NVIC会将其优先级和当前优先级对比，若**大于**当前优先级那么会转入该中断处理程序。Cortex-M核心支持硬件取出中断向量
>
> 硬件错误HardFault和总线错误、内存管理错误以及使用错误（UsageFault）相关。后三者默认是屏蔽的，就会触发HardFault

中断向量表见下，地址自下向上递增，一个元素长4字节，**存储中断程序的地址（最低位永远为1表示Thumb模式）**。可以看到0x00存储了`SP`初始值，这也是中断源数最多255而不是256的原因之一

![](images/201020a023.png)

> Cortex-M支持3种复位方式，分别是上电复位（复位所有部分），系统复位（除调试部件以外）以及处理器复位（外设以及调试部件不复位）。**处理器复位后会首先读取中断向量表的头两个字，分别赋值给`SP`和`PC`**

![](images/201020a024.png)


## 1.6 ISA详解：指令集

ARMv7-M指令集是ARMv6-M指令集的一个超集。Cortex-M4F，M3以及M0核心依次向下兼容

![](images/201020a025.png)

GNU工具链中汇编基本格式如下示例

```arm
label:
    MOVS R0, #0x12 /* 指令格式 */
```

定义常数/常量

```arm
.equ    NVIC_IRQ_SETEN,     0xE000E100 /* 大常数 */
.equ    NVIC_IRQ0_ENABLE,   0x1 /* 小常数 */

LDR R0, =NVIC_IRQ_SETEN /* 将0xE000E100加载到R0，该指令是伪指令，加上=相当于取地址（指令存不下立即数，需要先将该地址存储到一个寄存器中） */
MOVS R1, #NVIC_IRQ0_ENABLE /* 将0x1装入R1。0x1可以作为立即数直接编码到MOV指令中，所以使用#修饰 */
STR R1, [R0]

.align 4    /* 强制4字节对齐 */
TEST_DATA:
.word 0x00032C10 /* 插入数据TEST_DATA为0x00032C10 */
HELLO_TEXT:
.asciz "Hello World!"

/*
数据插入使用
.byte       1字节
.hword      2字节/半字，可以表示一条16位指令
.word       4字节/单字，可以表示一条32位指令
.quad       8字节/双字
.float      单精度浮点/32位
.double     双精度浮点/64位
.ascii      字符串
.asciz      末尾添加NULL的字符串
*/
```

尾缀用法

```arm
ADDS.N R0, #1 /* 使用16位ADD指令（Narrow），更新APSR */
ADD.W R0, #1 /* 使用32位ADD指令（Wide），不更新APSR */
ADDSEQ.W R0, R0, R1 /* 如果APSR中Z为1那么执行该指令（EQ），更新APSR（S） */
```

尾缀定义

![](images/201020a026.png)


### 1.6.1 UAL统一汇编语言简介

以前在ARM7TDMI的远古时代还不存在UAL。后来随着较新世代ISA如v6和v7的出现，为了统一各代ARM汇编的写法就产生了UAL，UAL规范和传统汇编写法主要有以下区别

> 部分运算指令从2个操作数改为3个操作数，如`ADD R0 R1`需要改写为`ADD R0 R0 R1`，遵循`OP Rd, Rn, Rm`的格式（目标寄存器放在最前）
>
> 必须明确使用`S`后缀才会更新`APSR`，例如`ADDS R0 R0 R1`（ARM7中几乎大部分指令都会强制更新APSR，这和较新的v6以及v7处理器不同）
>
> 另外，几乎所有的16位Thumb指令只能访问`R0`到`R7`寄存器，想要访问高寄存器只能使用32位Thumb指令


### 1.6.2 寄存器传送指令

**通用寄存器**

| 指令示例 | 解释 |
| :-: | :-: |
| `MOV R0, R3` | 将`R3`数据传送到`R0` |
| `MOVS R0, R3` | 同上，更新`APSR` |
| `MOV R3, #0x34` | 将立即数（**不大于8位**）传送到`R3` |
| `MOVS R3, #0x34` | 同上，更新`APSR` |
| `MOVW R6, #0x7B5A` | 赋值大立即数（9到16位）。立即数较大时汇编器会自动转换指令`MOV`为`MOVW` |
| `MOVT R6, #0x4D2C` | 赋值`R6`高16位 |
| `MVN R4, R3` | 将`R3`取反赋值给`R4` |
| `MRS R0, PRIMASK` | 特殊寄存器指令，将`PRIMASK`数据传输到`R0`。可以这样记忆：`MRS`的RS就是代表GPR在前，特殊寄存器在后 |
| `MSR PRIMASK, R0` | 将`R0`数据传输到`PRIMASK` |

> 32位立即数赋值一般使用伪指令（16以及32位指令无法编码），如`LDR R0, =0x1728D45A`，事实上使用了`LDR R0, [PC, #offset]`的寻址方式，将0x1728D45A编码到`.pool`文字池中。
>
> 还可以使用`MOVW`和`MOVT`结合使用的方法，这在特定情况下可以规避`LDR`导致数据缓存丢失的问题
>
> 如果想要将一个寄存器设为一个32位地址，可以使用伪指令`ADR`或`ADRL`，如`ADR R0, MyString`，其中`MyString`是程序文件中数据的地址标记


### 1.6.3 存储器指令

**单寄存器传输**

| 指令示例 | 解释 |
| :-: | :-: |
| `LDRB R0, [R4, #0xF]` | 将`R4+0xF`所表示的地址处**1字节**数据传输到`R0`，16位指令中立即数最大可取`0x1F`，32位指令中可取`-0xFF`到`0xFFF`，立即数域可以省略（`0x0`）。使用`LDRSB`指令对单字节数据进行符号扩展，如`0x95`转为`0xFFFFFF95`（和`APSR`无关，不要混淆）。32位指令可以加感叹号`LDRB R0, [R4, #0xF]!`表示更新`R4`值为`R4+0xF` |
| `STRB R0, [R4, #0xF]` | 将`R0`**低1字节**存储到`R4+0xF`处，立即数取值同上 |
| `LDRH R0, [R3, #0x3]` | 将`R3+0x3`处**2字节**数据传输到`R0`。使用`LDRSH`进行符号扩展，立即数取值同上 |
| `STRH R0, [R3, #0x3]` | 将`R0`**低2字节**存储到`R3+0x3`处，立即数取值同上 |
| `LDR R0, [R2, #0xA]` | 将`R2+0xA`处**4字节**数据传输到`R0`，立即数取值同上 |
| `STR R0, [R2, #0xA]` | 将`R0`存储到`R2+0xA`处，立即数取值同上 |

> `LDRB LDRSB LDRH LDRSH LDR`可以使用`PC`作为基址寄存器
>
> 可以使用**寄存器偏移**方式访问，示例`LDR R2, [R4, R5, LSL #3]`，表示从地址`R4+R5<<3`处读取，立即数可取0到3
>
> 还可以使用**后序**方式访问，示例`LDR R2, [R3], #2`，在每次访问之后会`R3`会自动加2。**适用于数组访问**
>
> 另外这些指令还有`T`结尾的版本，如`LDRT R0, [R2, #0xA]`，用于一些操作系统中特权API的实现，可以允许特权模式下的代码访问非特权内存

**双寄存器传输**

| 指令示例 | 解释 |
| :-: | :-: |
| `LDRD R2, R3, [R1, #-0x8D]` | 将`R1-0x8D`处**8字节**数据传输到`R2`和`R3`，立即数可取`-0xFF`到`0xFF` |
| `STRD R2, R3, [R1, #-0x8D]` | 将`R2`和`R3`依次存储到`R1-0x8D`处，立即数同上 |

> `LDRD`可以使用`PC`作为基址寄存器
>
> 不支持寄存器偏移方式。支持后序方式

**多寄存器传输**

| 指令示例 | 解释 |
| :-: | :-: |
| `LDMIA R1, {R2-R4, R6}` | 将`R1`处16字节数据依次存储到括号中的寄存器，每次读后地址增加。可以添加感叹号`LDMIA R1!, {R2-R4, R6}`将地址写回R1寄存器 |
| `STMIA R1, {R2-R4, R6}` | 将括号中寄存器依次存储到`R1`处，每次写后地址增加 |
| `LDMDB R3, {R1, R5-R9}` | 将`R3`之前24字节数据存储到括号中的寄存器，每次读前地址减小 |
| `STMDB R3, {R1, R5-R9}` | 将括号中寄存器存储到`R3`处，每次写前地址减小 |

**栈操作**

| 指令示例 | 解释 |
| :-: | :-: |
| `PUSH {R3, R5-R7, LR}` | 压栈，`SP`先减小后压栈。16位`PUSH`只能使用`R0-R7`以及`PC` `LR` |
| `POP {R3, R5-R7, PC}` | 出栈，出栈后`SP`才增大 |

**排他访问**

**排他访问需要硬件的支持**，使用较少（在具有MPU的MCU中比较有用，需要监控器），可以针对一片需要排他访问的内存（比如shareable）设置一个寄存器作为标志位（一般在global monitor中），保证**Read-Modify-Write**的正常运行，由一对特殊的LOAD以及STORE指令组成。信号位一般情况下为0，LOAD（占用）时置1，正常STORE（释放）后回0

> 排他访问的意义在于高优先级抢占低优先级时，如果要求低优先级的RMW操作是原子的，使用传统方法只能关中断或在高优先级中加入额外判断，这会导致高优先级任务的延迟，紧急任务得不到及时响应。使用排他访问指令就可以使得低优先级任务知道自己是否正确进行了RMW操作，事后处理而不影响高优先级任务的执行，优化实时响应性能
>
> 一般导致排他RMW操作失败的原因有内存被其他处理器访问，执行了`CLREX`或过程中遇到了中断

| 指令示例 | 解释 |
| :-: | :-: |
| `LDREXB R4, [R5]` | 将`R5`处**1字节**数据传输到`R4`，立即数可以取`0x00`到`0xFF` |
| `STREXB R0, R4, [R5]` | 将`R4`的**低1字节**传输到`R5`所指地址处，同时将存储执行结果（成功为0失败为1）返回到`R0`中，立即数同上 |
| `LDREXH R4, [R5]` | 将`R5`处**2字节**数据传输到`R4` |
| `STREXH R0, R4, [R5]` | 略 |
| `LDREX R4, [R5, #0xD]` | 略 |
| `STREX R0, R4, [R5, #0xD]` | 略 |
| `CLREX` | 用于一对LOAD以及STORE指令之间，清除标记位强制下一次排他写入失败 |


### 1.6.4 算术、饱和、逻辑、移位与数据转换

**算术**

加减法

| 指令示例 | 解释 |
| :-: | :-: |
| `ADD R1, R4, R7` | 寄存器加，`R1=R4+R7`，16位指令只能使用低寄存器，32位指令可以使用高寄存器并对`R7`进行移位，例如`ADD.W R1, R4, R7, ASR #0x1` |
| `ADD R1, #0x2C` | 立即数加，`R1=R1+0x2C`，16位指令，立即数可以取`0x00`到`0xFF` |
| `ADD R1, R4, #0x4` | 立即数加，`R1=R4+4`，16位指令立即数只能取`0x0`到`0x7`，32位指令（`.W`）可以使用高寄存器并可以使用更大的常数 |
| `ADDW R1, R4, #0xF4` | 立即数加，`R1=R4+0xF4`，只有32位，立即数最大可取`0xFFF` |
| `ADC R4, R7` | 寄存器带进位加，`R4=R4+R7`，32位示例`ADC.W R0, R1, R9, ASR #0x2` |
| `ADC R1, R4, #23` | 立即数带进位加，`R1=R4+23`，32位 |
| `SUB R2, R4, R5` | 寄存器减，`R2=R4-R5`，有16位和32位，同`ADD` |
| `SUB R2, #0x1D` | 立即数减，`R2=R2-0x1D`，只有16位，同`ADD` |
| `SUB R2, R4, #0x2` | 立即数减，`R2=R4-2`，有16位和32位，同`ADD` |
| `SUBW R2, R9, #0x3D` | 立即数减，`R2=R9-0x3D`，只有32位，同`ADDW` |
| `SBC R1, R6` | 寄存器带进位减，`R1=R1-R6`，有16位和32位，同`ADC` |
| `SBC R2, R9, #12` | 立即数带进位减，`R2=R9-12`，只有32位，同`ADC` |
| `RSB R5, R6, R8, ASR #0x1` | 寄存器反向减，`R5=R8/2-R6`，只有32位 |
| `RSB.W R4, R3, #3` | 立即数反向减，`R4=3-R3`，32位指令 |
| `RSB R1, R2, #0` | 立即数反向减，**立即数只能取0**，相当于求相反数 |

> 以上指令除`ADDW SUBW`外都可以在指令名称后加`S`后缀，如`ADDS.W R1, R4, R10`

乘除法

| 指令示例 | 解释 |
| :-: | :-: |
| `MUL R4, R5, R3` | 寄存器乘，`R4=R5*R3`，32位指令，结果只取低32位 |
| `UDIV R3, R2, R9` | 寄存器无符号除，`R3=R2/R9`，32位指令 |
| `SDIV R3, R2, R9` | 寄存器有符号除，`R3=R2/R9`，32位指令 |
| `MLA R4, R10, R5, R3` | 寄存器乘累加，`R4=R3+R10*R5`，32位指令 |
| `MLS R4, R10, R5, R3` | 寄存器乘累减，`R4=R3-R10*R5`，32位指令 |
| `SMULL R0, R1, R4, R9` | 有符号寄存器乘，`[R1:R0]=R4*R9`，32位指令，可以输出64位结果 |
| `SMLAL R0, R1, R4, R9` | 有符号寄存器乘累加，`[R1:R0]=[R1:R0]+R4*R9`，32位指令 |
| `UMULL R0, R1, R4, R9` | 无符号寄存器乘，`[R1:R0]=R4*R9`，32位指令 |
| `UMLAL R0, R1, R4, R9` | 无符号寄存器乘累加，`[R1:R0]=[R1:R0]+R4*R9`，32位指令 |

> 以上指令只有`MUL`可以加`S`后缀

饱和运算

| 指令示例 | 解释 |
| :-: | :-: |
| `SSAT R0, #12, R8, ASR #1` | 有符号饱和，取前12位，32位指令，如果饱和那么`APSR`的`Q`会置位，需要写`APSR`清除。无可加`S`后缀，可以移位`R8`。只能`LSL`或`ASR`移位 |
| `USAT R0, #12, R8` | 无符号饱和，同理 |

**逻辑与移位**

逻辑运算

| 指令示例 | 解释 |
| :-: | :-: |
| `AND R4, R5` | 寄存器与，`R4=R4&R5`，16位指令，32位示例`AND.W R4, R5, R8, LSL #4` |
| `AND R4, R8, #3` | 立即数与，`R4=R8&3`，32位指令 |
| `BIC R4, R5` | 寄存器与，`R4=R4&(~R5)`，有16位和32位，同`AND` |
| `BIC R4, R8, #3` | 立即数与，`R4=R8&(~3)`，32位指令，同`AND` |
| `ORR R4, R5` | 寄存器或，`R4=R4\|R5`，有16位和32位，同`AND` |
| `ORR R4, R8, #3` | 立即数或，`R4=R8\|3`，32位指令，同`AND` |
| `EOR R4, R5` | 寄存器异或，`R4=R4^R5`，有16位和32位，同`AND` |
| `EOR R4, R8, #3` | 立即数异或，`R4=R8^3`，32位指令，同`AND` |
| `ORN R1, R2, R8, LSL #1` | 寄存器或非，`R1=~(R2\|(R8<<1))`，32位指令 |
| `ORN R1, R2, #3` | 立即数或非，`R1=~(R2\|3)`，32位指令 |

> 可以添加`S`后缀。没有逻辑非指令，可以通过其他指令等价实现

移位

| 指令示例 | 解释 |
| :-: | :-: |
| `ASR R1, R4` | 寄存器算术右移，`R1=R1>>R4`，16位指令，32位示例`ASR.W R1, R2, R5` |
| `ASR R1, R4, #4` | 立即数算术右移，`R1=R4>>4`，16位指令，32位示例`ASR.W R1, R2, #8` |
| `LSL R1, R4` | 寄存器逻辑左移，`R1=R1<<R4`，有16位和32位，同`ASR` |
| `LSL R1, R4, #4` | 立即数逻辑左移，`R1=R4<<4`，有16位和32位，同`ASR` |
| `LSR R1, R4` | 寄存器逻辑右移，`R1=R1>>R4`，有16位和32位，同`ASR` |
| `LSR R1, R4, #4` | 立即数逻辑右移，`R1=R4>>4`，有16位和32位，同`ASR` |
| `ROR R1, R4` | 寄存器循环右移，有16位和32位，同`ASR` |
| `ROR R1, R4, #4` | 立即数循环右移，只有32位 |
| `RRX R4, R8` | 带扩展的寄存器循环右移，只有32位指令，移出的位先存入`APSR`的`C`中再移入最高位（相当于33位移位寄存器） |

> 可以添加`S`后缀。移位后`APSR`中的`C`等于最后移出的1位

**数据转换**

展开，将寄存器中的字节、半字扩展为32位单字长

| 指令示例 | 解释 |
| :-: | :-: |
| `SXTB R1, R4` | 有符号**字节**扩展，16位指令，32位示例`SXTB.W R1, R4, ROR #5`，只能使用循环右移`ROR` |
| `SXTH R1, R4` | 有符号**半字**扩展，16位指令，32位示例`SXTH.W R1, R4, ROR #5`，同`SXTB` |
| `UXTB R1, R4` | 无符号**字节**扩展，有16位和32位，同`SXTB` |
| `UXTH R1, R4` | 无符号**半字**扩展，有16位和32位，同`SXTB` |

> 无可用`S`后缀

反转，用于将寄存器中的字节交换，多用于[SIMD应用](#1611-cortex-m4浮点指令simd与乘法)

| 指令示例 | 解释 |
| :-: | :-: |
| `REV R1, R3` | 全寄存器字节反转，`R1[7:0]=R3[31:24]`，依次类推，16位指令，32位示例`REV.W R1, R10` |
| `REV16 R1, R3` | 半字字节反转，`R1[7:0]=R3[15:8], R1[15:8]=R3[7:0]`，两两交叉依次类推，有16位和32位指令，和`REV`相同 |
| `REVSH R1, R3` | 有符号半字字节反转，只反转`R1[7:0]=R3[15:8], R1[15:8]=R3[7:0]`，同时扩展符号，有16位和32位指令，和`REV`相同 |

> 无可用`S`后缀


### 1.6.5 位域处理指令

位域处理指令主要是设计用于DSP应用的，而不是类似8051和AVR的位寻址功能。ARM的寻址方式永远基于字节

| 指令示例 | 解释 |
| :-: | :-: |
| `BFC R1, #8, #16` | `R1[23:8]=0`，将寄存器中从n位开始的m位置0，32位指令 |
| `BFI R0, R1, #8, #16` | `R0[23:8]=R1[15:0]`，将一个寄存器中指定尾数嵌入到另一个寄存器指定位置，32位指令 |
| `CLZ R0, R2` | 前导0计数，计算第一个1之前的0个数，32位指令。Count Leading Zeros |
| `RBIT R1, R3` | 比特反转，`R1[31:0]=R3[0:31]`，32位指令 |
| `UBFX R0, R1, #8, #16` | `R0=R1[8:23]`，提取寄存器指定位域并使用0扩展，32位指令 |
| `SBFX R0, R1, #8, #16` | 同上，使用符号扩展，32位指令 |

> 无可用`S`后缀


### 1.6.6 比较、测试与程序流控制

**比较与测试**

| 指令示例 | 解释 |
| :-: | :-: |
| `CMP R1, R2` | 寄存器比较，相当于没有输出的**减法**，16位指令，32位指令示例`CMP.W R1, R2, ASR #1`，总是更新`APSR` |
| `CMP R1, #0xAF` | 立即数比较，16位指令，立即数最大取`0xFF`，32位指令示例`CMP.W R10, #10` |
| `CMN R1, R2` | 寄存器比较，相当于没有输出的**加法**，有16位和32位指令，同`CMP`，用于判断相反数 |
| `CMN R1, #0xAF` | 立即数比较，有16位和32位指令，同`CMP` |
| `TST R1, R2` | 寄存器测试，相当于没有输出的**与运算**，有16位和32位指令，同`CMP`，更新`APSR`的`N Z`两位 |
| `TST R1, #0xAF` | 立即数比较，有16位和32位指令，同`CMP` |
| `TEQ R1, R2` | 寄存器测试，相当于没有输出的**异或运算**，有16位和32位指令，同`CMP`，更新`APSR`的`N Z`两位 |
| `TEQ R1, #0xAF` | 立即数比较，有16位和32位指令，同`CMP` |

> 这些指令总是更新`APSR`，所以也没有可选的`S`后缀

**跳转与子程序调用**

几乎所有的普通指令都可以使用条件执行后缀，如`ADDEQ R1, R2, R3`，而事实上这些指令都是伪指令，在ARMv7-M中会自动添加`IT`指令

[条件后缀定义传送门](#16-isa详解指令集)

| 指令示例 | 解释 |
| :-: | :-: |
| `B label` | 跳转到`label`处，是16位指令，32位指令可以有更大的跳转范围，示例`B.W label`。从机器码层面看，这是事实上可以接受`APSR`中状态位判断参数的指令之一（如`EQ NE GT`等。另一条指令是`IT`）。如果使用了后缀那么跳转范围会相应的缩小，因为事实上有两条不同的`B`指令分别用于带后缀与不带后缀的情况 |
| `BX R1` | 跳转到`R1`所指位置，16位指令，`R1`最低位必须置1表示Thumb状态 |
| `BL label` | 子程序调用，跳转到`label`处，同时将该指令下一条指令的地址存入`LR(R14)`，只有32位指令 |
| `BLX R1` | 子程序调用，跳转到`R1`同时将该指令下一条指令的地址存入`LR(R14)`，只有16位指令，`R1`最低位必须置1 |
| `CBZ R1, label` | 检查`R1`的值，如果等于0那么跳转到`label`。只能向前跳转 |
| `CBNZ R1, label` | 不为0时跳转到`label` |

**If-Then跳转**

ARMv7-M中引入了`IT`指令，长度16位，在一般的汇编代码编写中用不到，汇编器会自动添加。例如我们写一条`ADDEQ R1, R1, R2`，汇编器会自动在前面添加`IT EQ`

示例1

```
IT EQ
ADDEQ R4, R5, R3
```

示例2

```
ITET NE
ADDNE R1, R5, R3
ADDEQ R4, R5, R3
ADDNE R7, R5, R3
```

示例3

```
ITETT GT
ADDGT R1, R5, R3
ADDLE R4, R5, R3
ADDGT R7, R5, R3
ADDGT R2, R5, R3
```

> `IT`可以说是ARMv7-M中设计最诡异的指令，添加后缀可以是`ITE ITT ITEE ITET ITTE ITTT ITEEE ITETT`等任意排列组合方式，后加`EQ`表示符合的条件（检查的是`PSR`）。`IT`指令之后可以跟最多4条指令，而这4条指令也必须带有后缀，如`ADDNE R1, R0, R3`，同时后缀一定要和`ITXXX`所表示的条件相符（这些后缀事实上是无意义的，它们只是重复描述了`ITETT`的条件位而已，但是代码规范规定必须添加），`T`表示符合所以使用同后缀，`E`表示不符所以使用相反后缀。`IT`指令最多跟3个后缀加1个条件后缀，其本身代表一个`T`后缀
>
> `IT`每遇到一个不符合条件的指令也会消耗一定的时间，所以有时候`IT`不一定比传统的基于`B`指令的跳转快
>
> > 基于`B`实现`If-Then`需要使用一个有条件跳转例如`BEQ`加一个无条件跳转`B`。首先执行的`BEQ`之后跟`NE`情况下的指令，接下来是一个`B`指令之后跟`EQ`情况下的指令。`BEQ`跳转到`B`之后的地址，`B`跳转到`If-Then`程序流合并处
>
> 注意，`IT`指令块中只有最后一条指令可以修改`PC`，**例如`B`等指令，只能在`IT`指令块中最后一条指令处出现**

在`PSR`中有`ITSTATE`，用于指示当前的`IT`执行状态，共计8位`PSR[26:25][15:10]`，可以分为`IT[7:5]`和`IT[4:0]`两部分。执行过程中遇到异常`IT`会被打断，之后就要使用`ITSTATE`进行恢复

> `IT[7:5]`储存该`IT`指令的条件位高3位
>
> `IT[4:0]`表示`IT`后的指令条数（看最低1的位置），并决定指令1到4执行与否。每运行一条`IT`块中的指令，右侧的0都会增加一个。参照下表，每运行一条指令都会跳到表格下一项

![](images/201020a028.png)

**表格跳转**

表格跳转指令`TBB`和`TBH`用于实现C语言的`switch`语句

| 指令示例 | 解释 |
| :-: | :-: |
| `TBB [PC, R1]` | 执行到该命令时`PC`地址为当前`TBB`命令地址+4，使用该地址作为跳转表格的基址（也即跳转表格就在`TBB`指令后面），`R1`中存储跳转项在表格中的**偏移地址**，也即跳转项位于`PC+R1`，读取跳转项直接跳转到`PC=PC+(TABLE_N)<<1`（左移一位是因为`PC`最低位为0，这样可以多1倍的跳转空间。也可以使用一般寄存器代替PC，`PC=PC+[RN+R1]<<1`，方括号表示指针解析）。最多可以相对表格基地址偏移512字节，指令长度32位 |
| `TBH [PC, R2, LSL #1]` | 表格中跳转项长度为2字节，其余相同。最多可以相对指令表格基地址偏移128k字节，长度32位 |

GNU汇编示例

```
ADR.W R0, Branch_Table
TBB [R0, R1]
Case1:
    /*Instructions*/
Case2:
    /*Instructions*/

...

Branch_Table:
.byte 0
.byte ((Case2-Case1)/2)
```


### 1.6.7 异常指令

**Supervisor Call系统调用**

系统调用使用`SVC`指令，只在涉及到操作系统的场合会有应用，关于`SVC`中断编号[见前](#15-nvic嵌套向量中断控制器)

| 指令示例 | 解释 |
| :-: | :-: |
| `SVC #0xAF` | 应用程序产生系统调用异常，后面可以跟8位数字，用于参数传递（比如应用想要调用何种系统服务），因为NMI和HardFault优先级一定比Supervisor更高所以在这两种异常中不能调用。8位参数只是一个数字对异常的行为没有影响，**系统程序需要通过已经压栈的PC获取该条SVC指令并读取该数字，因此PC一般需要在SVC调用之前压栈** |

**中断屏蔽控制**

指令`CPS`用于控制中断的屏蔽，参见[1.4.2节](#142-特殊寄存器)`PRIMASK`和`FAULTMASK`

| 指令示例 | 解释 |
| :-: | :-: |
| `CPSIE I` | `PRIMASK`清0使能中断 |
| `CPSID I` | `PRIMASK`置1禁用除NMI和HardFault外的中断 |
| `CPSIE F` | `FAULTMASK`清0 |
| `CPSID F` | `FAULTMASK`置1禁用除NMI外的中断 |


### 1.6.8 休眠指令

处理器核心休眠

| 指令示例 | 解释 |
| :-: | :-: |
| `WFI` | 等待中断，此时处理器立即进入休眠模式，可以通过中断、复位或调试唤醒 |
| `WFE` | 等待事件，此时处理器会条件性地进入休眠，可以通过中断、复位、调试或其他时间（如多核系统中其他处理器发送来的信号）唤醒 |
| `SEV` | 事件输出 |


### 1.6.9 存储器屏障

存储器屏障，一般用于具有超标量以及乱序执行的处理器系统中，可以解决一些乱序访存导致的错误

| 指令示例 | 解释 |
| :-: | :-: |
| `DMB` | 存储器屏障，确保**下一次访存**之前所有访存操作已完成 |
| `DSB` | 数据同步屏障，确保**下一指令**前所有访存操作已完成 |
| `ISB` | 指令同步屏障，清空流水线确保下一指令前所有指令执行完成 |

> Cortex-M核心因为流水线比较简单，在一般情况下是不需要用到这些屏障的。使用到屏障一般有以下几种情况：
>
> 更改`CONTROL`寄存器之后（[见前](#142-特殊寄存器)），需要使用`ISB`指令确保之后的指令使用正确的`SP`寄存器并运行在正确的模式下
>
> 如果在处理模式下使能了`SCR`寄存器的`SLEEPONEXIT`，那么就表示处理程序结束后会立即进入休眠，需要在结束时执行`DSB`保证数据安全写入到SRAM
>
> 异常挂起后，需要确保该异常在之后的操作之前执行，需要执行`DSB`和`ISB`
>
> 禁用中断后想要中断立即起效，执行`DSB`和`ISB`
>
> 自修复，执行`DSB`和`ISB`
>
> 运行时更改了程序存储Flash的映射地址，需要立即起效，执行`DSB`和`ISB`
>
> 运行时更改了数据SRAM的映射地址，需要立即起效，执行`DSB`
>
> 通过MPU更改了一片程序存储区域的配置（如权限等），且需要到该区域取指并执行，执行`DSB`和`ISB`

> 以下情况遇到问题可以尝试添加屏障
>
> 通过MPU将一片存储区域从**仅允许数据访问**更改为**可取指**，且需要到该区域取指并执行，执行`DSB`
>
> 执行`WFI`或`WFE`休眠之前，执行`DSB`
>
> 执行信号量操作时，执行`DMB`或`DSB`
>
> 修改了`SVC`指令的优先级并触发，在触发前执行`DSB`
>
> 通过`VTOR`修改了中断向量表的偏移并触发中断，在触发前执行`DSB`
>
> CPU自复位之前，执行`DSB`


### 1.6.10 杂项

| 指令示例 | 解释 |
| :-: | :-: |
| `NOP` | 什么都不做，长度16位，一般可以用于指令对齐或软延时 |
| `BKPT #0x24` | 用于调试，CPU在执行到该指令时会暂停，触发调试异常，同时用户可以执行一些调试任务。后面的8位长数字和`SVC`一样，只是用于存储参数 |


### 1.6.11 Cortex-M4：浮点指令，SIMD与乘法

可以通过CMSIS-DSP库调用这些浮点以及SIMD等高级算术功能，该函数库由ARM委托DSP Concepts（[dspconcepts.com](https://w.dspconcepts.com/)）开发。`FPSCR`寄存器定义见[1.4.3](#143-fpu寄存器)

![](images/201020a014.png)

> 开始本章之前建议先了解一下有关IEEE754-2008浮点数标准以及异常处理方案，可以[看这里](200920c_verilog.md#51-IEEE754浮点数标准)

**浮点指令**

所有的浮点指令都以`V`开头，**Cortex-M4只支持单精度浮点数的运算**，所以大部分指令使用`.F32`作为后缀

寄存器传送

| 指令示例 | 解释 |
| :-: | :-: |
| `VMOV.F32 R4, S2` | 将32位浮点寄存器`S2`数据传输到`R4` |
| `VMOV.F32 S0, R2` | 将32位浮点寄存器`R2`数据传输到`S0` |
| `VMOV.F32 S2, S3` | 将32位浮点寄存器`S3`数据传输到`S2` |
| `VMOV.F32 S5, #1.0` | 将单精度浮点数1.0传送到浮点寄存器`S5` |
| `VMOV S0, S1, R0, R1` | 将`R0 R1`两个数传输到`S0 S1` |
| `VMOV R0, R1, S0, S1` | 将`S0 S1`两个数传输到`R0 R1` |
| `VMRS.F32 R0, FPSCR` | 将浮点状态寄存器`FPSCR`数据传送到`R0` |
| `VMRS APSR_nzcv, FPSCR` | 将浮点状态寄存器`FPSCR`的`NZCV`位传送到`APSR`的状态位（多用于浮点条件运算） |
| `VMSR FPSCR, R0` | 将`R0`传送到`FPSCR` |

浮点访存

| 指令示例 | 解释 |
| :-: | :-: |
| `VLDR.F32 S0, [R1, #0xA]` | 将`R1+0xA`处4字节单精度传输到`S0`。8字节双精度使用`.F64`以及`D0`，立即数可取`-0xFF`到`0xFF`，可以使用`PC`作为基址寄存器，也可以使用`label`，示例`VLDR.F32 S0, label` |
| `VSTR.F32 S6, [R5, #0x4]` | 将`S6`中的单精度数存储到`R5+0x4`处。双精度以及立即数同上 |
| `VLDMIA.F32 R2, {S0, S3-S7}` | 传输到多个寄存器，`R2`基址递增。双精度寄存器使用`.F64`，可以添加感叹号`VLDMIA.F32 R2!, {S0, S3-S7}`表示地址写回 |
| `VSTMIA.F32 R2, {S0, S3-S7}` | 将多个寄存器存储到内存，`R2`基址递增，其余同上 |
| `VLDMDB.F32 R2, {S0, S3-S7}` | 传输到多个寄存器，`R2`基址递减 |
| `VSTMDB.F32 R2, {S0, S3-S7}` | 将多个寄存器存储到内存，`R2`基址递增 |
| `VPUSH.F32 {S3-S9, S11}` | 浮点寄存器压栈，双精度版本示例`VPUSH.F64 {D1, D3-D10}` |
| `VPOP.F32 {S3-S9, S11}` | 浮点寄存器出栈，双精度版本示例`VPOP.F64 {D1, D3-D10}` |

基本算术指令

| 指令示例 | 解释 | 异常 |
| :-: | :-: | :-: |
| `VABS.F32 S0, S1` | 求绝对值，`S0=Abs(S1)` |  |
| `VNEG.F32 S0, S1` | 浮点取相反数，`S0=-S1` |  |
| `VADD.F32 S0, S1, S2` | 加法，`S0=S1+S2` | `IDC IOC OFC UFC IXC` |
| `VSUB.F32 S0, S1, S2` | 减法，`S0=S1-S2` | `IDC IOC OFC UFC IXC` |
| `VCMP.F32 S0, S1` | 比较`S1`和`S0`，更新`FPSCR`，若一个数为sNaN那么抛出`IOC`。立即数版本`VCMP.F32 S0, #0.0`只能和0进行比较。带`E`后缀版本`VCMPE.F32 S0, S1`在遇到任意NaN都会抛出`IOC` | `IDC IOC` |
| `VMUL.F32 S0, S1, S2` | 浮点乘法，`S0=S1*S2` | `IDC IOC OFC UFC IXC` |
| `VNMUL.F32 S0, S1, S2` | 浮点乘法取反，`S0=-(S1*S2)` | `IDC IOC OFC UFC IXC` |
| `VDIV.F32 S0, S1, S2` | 浮点除法，`S0=S1/S2` | `IDC IOC OFC UFC IXC DZC` |
| `VSQRT.F32 S0, S1` | 均方根，`S0=sqrt(S1)` | `IOC IDC IXC` |
| `VFMA.F32 S0, S1, S2` | 融合乘加，`S0=S0+(S1*S2)` | `IDC IOC OFC UFC IXC` |
| `VFMS.F32 S0, S1, S2` | 融合乘减，`S0=S0-(S1*S2)` | `IDC IOC OFC UFC IXC` |
| `VFNMA.F32 S0, S1, S2` | 融合负乘加，`S0=-S0+(S1*S2)` | `IDC IOC OFC UFC IXC` |
| `VFNMS.F32 S0, S1, S2` | 融合负乘减，`S0=-S0-(S1*S2)` | `IDC IOC OFC UFC IXC` |
| `VMLA.F32 S0, S1, S2` | 浮点乘加，`S0=S0+(S1*S2)` | `IDC IOC OFC UFC IXC` |
| `VMLS.F32 S0, S1, S2` | 浮点乘减，`S0=S0-(S1*S2)` | `IDC IOC OFC UFC IXC` |
| `VNMLA.F32 S0, S1, S2` | 浮点乘加取反，`S0=-(S0+(S1*S2))` | `IDC IOC OFC UFC IXC` |
| `VNMLS.F32 S0, S1, S2` | 浮点乘减取反，`S0=-(S0-(S1*S2))` | `IDC IOC OFC UFC IXC` |

整数转换

| 指令示例 | 解释 | 异常 |
| :-: | :-: | :-: |
| `VCVT.S32.F32 S0, S1` | 32位有符号转浮点，向0舍入，`S0=(Float)S1`。带`R`后缀版本示例`VCVTR.S32.F32 S0, S1`，表示使用`FPSCR`指定的舍入方式 | `IDC IOC IXC` |
| `VCVT.U32.F32 S0, S1` | 32位无符号转浮点，向0舍入，`S0=(Float)S1`。带`R`后缀同理 | `IDC IOC IXC` |
| `VCVT.F32.S32 S0, S1` | 浮点转32位有符号，`S0=sInt32(S1)` | `IDC IOC IXC` |
| `VCVT.F32.U32 S0, S1` | 浮点转32位无符号，`S0=uInt32(S1)` | `IDC IOC IXC` |

定点数转换

| 指令示例 | 解释 | 异常 |
| :-: | :-: | :-: |
| `VCVT.S16.F32 S0, S0, #12` | 16位有符号定点数转浮点数，小数12位，向最近数舍入，操作数和结果只能使用同一个寄存器。16位无符号定点版示例`VCVT.U16.F32 S0, S0, #12`，另有32位有符号以及无符号版`VCVT.S32.F32`和`VCVT.U32.F32` | `IDC IOC IXC` |
| `VCVT.F32.S16 S0, S0, #5` | 浮点数转16位有符号定点数，小数5位。有`U16 S32 U32`版同上 | `IDC IOC IXC` |

16位半精度转换

| 指令示例 | 解释 | 异常 |
| :-: | :-: | :-: |
| `VCVTB.F32.F16 S0, S1` | 单精度转半精度，`S0[15:0]=(Half)S1` | `IDC IOC OFC UFC IXC` |
| `VCVTF.F32.F16 S0, S1` | 单精度转半精度，`S0[31:16]=(Half)S1` | `IDC IOC OFC UFC IXC` |
| `VCVTB.F16.F32 S0, S1` | 半精度转单精度，`S0=(Float)S1[15:0]` | `IDC IOC OFC UFC IXC` |
| `VCVTF.F16.F32 S0, S1` | 半精度转单精度，`S0=(Float)S1[31:16]` | `IDC IOC OFC UFC IXC` |

**SIMD指令**

Cortex-M4只支持在GPR上进行整数的SIMD计算，多用于DSP应用（ADC采样本质是整数，RGB图像也是整数），和Cortex-A核心支持的NEON高级SIMD扩展不是一回事

所有的SIMD指令和浮点指令都是32位长度

在SIMD中数据在GPR中可以有以下几种格式，可以是4个单字节数据或2个半字数据

![](images/201020a027.png)

SIMD数据格式不属于标准C，如果要使用C开发就只能通过CMSIS-DSP使用SIMD功能

| 指令示例 | 解释 |
| :-: | :-: |
| `SADD8 R0, R1, R3` | `R1`中4个有符号8位数和`R3`一一对应相加存入`R0`，`S`为前缀。其他可选前缀有`U`无符号数，`SH`有符号分半（结果除以2）和`UH`无符号分半，`Q`有符号饱和（上限127下限-128）以及`UQ`无符号饱和（上限255下限0）。饱和运算会更新`PSR`的`Q`标记位，`S`和`U`会更新`GE[3:0]` |
| `SSUB8 R0, R1, R3` | 4个字节对应相减。可用前缀同上 |
| `SADD16 R0, R1, R3` | 2个半字对应相加。可用前缀同上 |
| `SSUB16 R0, R1, R3` | 2个半字对应相减。可用前缀同上 |
| `SASX R0, R1, R3` | `R0[15:0]=R1[15:0]-R3[31:16], R0[31:16]=R1[31:16]+R3[15:0]`。可用前缀同上 |
| `SSAX R0, R1, R3` | `R0[15:0]=R1[15:0]+R3[31:16], R0[31:16]=R1[31:16]-R3[15:0]`。可用前缀同上 |
| `USAD8 R0, R1, R3` | 无符号绝对差之和，`R0=Abs(R1[7:0]-R3[7:0])+Abs(R1[15:8]-R3[15:8])+Abs(R1[23:16]-R3[23:16])+Abs(R1[31:24]-R3[31:24])` |
| `USADA8 R0, R1, R2, R3` | 无符号绝对差累加，`{USADA8 R0, R1, R2, R3}={USAD8 R0, R1, R2}+R3` |
| `USAT16 R0, #12, R1` | 无符号半字饱和，`R1`保留12位存到`R0` |
| `SSAT16 R0, #12, R1` | 有符号半字饱和，保留12位 |
| `SEL R0, R1, R2` | 根据`GE[3:0]`选择字节，`R0[7:0]=GE[0]?R1[7:0]:R2[7:0]` |

**饱和指令**

除Cortex-M3支持的[整数饱和指令](#164-算术饱和逻辑移位与数据转换)，M4支持更多的饱和指令

| 指令示例 | 解释 |
| :-: | :-: |
| `QADD R0, R1, R3` | 有符号32位数相加并饱和，会更新`Q`寄存器 |
| `QDADD R0, R1, R3` | 有符号32位数饱和运算`R0=R1*2+R3`，`R1*2`饱和或加法饱和都会更新`Q`寄存器 |
| `QSUB R0, R1, R3` | 有符号32位数相减并饱和，同`QADD` |
| `QDSUB R0, R1, R3` | 有符号32位数饱和运算`R0=R1*2-R3`，同`QDADD` |

**乘法与MAC指令**

除Cortex-M3支持的[乘除法指令](#164-算术饱和逻辑移位与数据转换)，M4也支持额外的乘法以及MAC指令

| 指令示例 | 解释 |
| :-: | :-: |
| `UMAAL R0, R1, R3, R4` | 无符号乘加，`[R1:R0]=R0+R1+R3*R4` |
| `SMULBT R0, R1, R2` | 有符号半字乘法，`BT`为后缀，`R0=R1[15:0]*R2[31:16]`。其他可用后缀`BB`，`TB`，`TT`，`B`表示使用低半字，`T`表示使用高半字 |
| `SMLABT R0, R1, R2, R3` | `SMULBT`累加版，`BT`为后缀，`R0=R1[15:0]*R2[31:16]+R3`。符号溢出会置位`Q`，后缀定义同上 |
| `SMULWB R0, R1, R2` | 有符号半字和字相乘取高32位，`B`为后缀，`R0={R1*R2[15:0]}[47:16]`。后缀定义如上 |
| `SMLAWB R0, R1, R2, R3` | `SMULWB`累加版，`B`为后缀，`R0={R1*R2[15:0]}[47:16]+R3`。符号溢出会置位`Q` |
| `SMMUL R0, R1, R2` | 相乘取高32位，`R0={R1*R2}[63:32]`。另有一个带舍入的`SMMULR R0, R1, R2`，其中`R0={R1*R2+0x80000000}[63:32]` |
| `SMMLA R0, R1, R2, R3` | `SMMUL`累加版，`R0={R3<<32+R1*R2}[63:32]`。带舍入版本`SMMLAR R0, R1, R2, R3`，其中`R0={R1*R2+R3<<32+0x80000000}[63:32]` |
| `SMMLS R0, R1, R2, R3` | `SMMUL`累减版，`R0={R3<<32-R1*R2}[63:32]`。带舍入版本`SMMLSR R0, R1, R2, R3`，其中`R0={R3<<32-R1*R2+0x80000000}[63:32]` |
| `SMLALBB R0, R1, R2, R3` | 有符号半字乘累加，`BB`为后缀，`[R1:R0]=[R1:R0]+R2[15:0]*R3[15:0]`，后缀定义同`SMUL` |
| `SMUAD R0, R1, R2` | 有符号半字乘和，`R0=R1[15:0]*R2[15:0]+R1[31:16]*R2[31:16]`，取低32位。有一个交换版`SMUADX R0, R1, R2`，`R0=R1[15:0]*R2[31:16]+R1[31:16]*R2[15:0]`。符号溢出更新`Q` |
| `SMUSD R0, R1, R2` | 有符号半字乘差，`R0=R1[15:0]*R2[15:0]-R1[31:16]*R2[31:16]`，取低32位。有一个交换版`SMUSDX R0, R1, R2`，`R0=R1[15:0]*R2[31:16]-R1[31:16]*R2[15:0]` |
| `SMLAD R0, R1, R2, R3` | `SMUAD`的32位累加版，`R0=R1[15:0]*R2[15:0]+R1[31:16]*R2[31:16]+R3`，交换版`SMLADX R0, R1, R2, R3`，符号溢出更新`Q` |
| `SMLSD R0, R1, R2, R3` | `SMUSD`的32位累加版，`R0=R1[15:0]*R2[15:0]-R1[31:16]*R2[31:16]+R3`，交换版`SMLSDX R0, R1, R2, R3`，符号溢出更新`Q` |
| `SMLALD R0, R1, R2, R3` | `SMLAD`的64位完整结果版，`[R1:R0]=[R1:R0]+R1[15:0]*R2[15:0]+R1[31:16]*R2[31:16]`，交换版`SMLALDX R0, R1, R2, R3` |
| `SMLSLD R0, R1, R2, R3` | `SMLSD`的64位完整结果版，`[R1:R0]=[R1:R0]+R1[15:0]*R2[15:0]-R1[31:16]*R2[31:16]`，交换版`SMLSLDX R0, R1, R2, R3` |

**数据打包**

除之前的[数据转换](#164-算术饱和逻辑移位与数据转换)指令，M4还支持以下指令

| 指令示例 | 解释 |
| :-: | :-: |
| `PKHBT R0, R1, R2, LSL #3` | 打包两个半字，`R0=[R1[15:0]:{R2[31:16]<<3}]` |
| `PKHTB R0, R1, R2, ASR #3` | 打包两个半字，`R0=[R1[31:16]:{R2[15:0]>>3}]` |
| `SXTB16 R0, R1` | 有符号字节扩展，`R0=[SExt16{R1[23:16]}:SExt16{R1[7:0]}]`，可加`ROR`移位，示例`SXTB16 R0, R1, ROR #3`，以下所有指令中寄存器移位同理 |
| `UXTB16 R0, R1` | 无符号字节扩展，同上 |
| `SXTAB R0, R1, R2` | 有符号字节扩展累加，`R0=R1+SExt32{R2[7:0]}` |
| `SXTAH R0, R1, R2` | 有符号半字扩展累加，`R0=R1+SExt32{R2[15:0]}` |
| `SXTAB16 R0, R1, R2` | 有符号双字节扩展累加，`R0[15:0]=R1[15:0]+SExt16{R2[7:0]}, R0[31:16]=R1[31:16]+SExt16{R[23:16]}` |
| `UXTAB R0, R1, R2` | `SXTAB`无符号扩展版 |
| `UXTAH R0, R1, R2` | `SXTAH`无符号扩展版 |
| `UXTAB16 R0, R1, R2` | `SXTAB16`无符号扩展版 |


## 1.7 低功耗应用


## 1.8 OS特性与MPU


## 1.9 Cortex-M0+指令子集


## 2 STM32F103C8T6/C6T6


## 3 STM32F401CCU6/411CEU6


## 4 STM32F407VET6


## 5 STM32L496VGT6