# Make原理和使用

基于GNU Make

http://www.gnu.org/software/make/

主要参考make官方文档，提取一些关键信息

## 1 简介

## 1.1 Make是什么

Make的思想起源于软件工程，随着编译技术的发展，以及软件本身的进化，一个软件的源文件结构不断变得复杂，程序员发现面对成千上万的源文件，手动编译一个程序变得不再现实，于是寻求一种可以根据规则自动进行文件处理与生成的工具。这就是**Make**

Make分为很多种，它们几乎应用在目前所有的开发环境中，已经成为目前计算机软件的重要基础设施。除目前最常用的**GNU Make**外，BSD也拥有遵循自己开源协议的**BSD Make**，常用的C++应用框架Qt拥有**QMake**，Ruby有自己的实现**Rake**，微软VS有自己集成的make，还有跨平台的**CMake**等。我们在一般的IDE中接触不到make，因为IDE往往会隐藏底层的构建过程

Make本质就是根据一系列规则判断文件依赖，之后通过一系列处理，生成或更新这些文件，并且一般支持自动推导依赖，以及可以根据文件的时间戳判断哪些文件需要更新（假设源文件时间戳比目标文件新，那么就代表这个目标文件需要更新）

Make几乎可以算作是通用的文件处理脚本工具，Makefile就是它的脚本。在Linux、BSD等类UNIX环境中各种强大工具的支撑下，它不仅可以用于各种语言编写的程序编译与构建，甚至可以用于图片和音频的批处理


## 1.2 GNU GCC工具链

GCC编译一个程序的过程分为**预处理、编译、汇编、链接**4大步骤

在我们日常编写一个单源码程序（比如一个控制台程序）时，我们只要在文件中包含我们需要的标准库头文件即可。执行`gcc test.c -o test`会自动完成这一系列所需过程

但是在实际情况中，尤其是在大型工程中，这种情况会变得异常复杂。一方面，一些公司出于商业保护、专利保护、copyright等原因，或者一些软件作者单纯不想开放他的源码（这是可以理解的，比如他们不想使自己的成果在未经允许的情况下被他人修改后利用），**他们往往只会提供一个闭源的二进制库以及一个头文件，而不是完整的源代码**。这些闭源代码只能通过**链接**应用到我们的程序中，反汇编是破译这些程序的唯一方法。另外，为了降低程序的重复度，很多程序会使用共享的动态链接库。并且在实际中头文件和源代码的关系也是错综复杂的，为方便大型工程的管理以及简化开发（使用一个库，直接引用一个头文件即可，无需再次逐个声明函数，这个头文件同时被库和应用程序使用），实际工程中都将头文件（声明）和源文件（实现）分开

比如，一个软件作者可以写一个库，文件为`test1.c`、`test2.c`以及头文件`test.h`，经过编译汇编得到可重定位文件`test1.o`和`test2.o`，再使用`ar`打包变成库文件`test.a`，发布时只提供`test.h`以及`test.a`，使用时在编译最后阶段链接即可

预处理使用`cpp`，编译使用`gcc`，汇编使用`as`，链接使用`ld`。实际使用中这些程序都可以统一通过`gcc`调用，并且`gcc`会自动产生一些参数，比如`ld`的参数可以在被`gcc`调用时自动生成


## 2 Make执行流程

一些基础概念

## 2.1 两个阶段

Make的主要任务，主要是文件依赖的推导，以及自动调用文件构建命令

GNU Make的执行过程大致分为两个阶段（Phase）。

**第一个阶段**make会首先预处理Makefile，将Makefile通过`include`包含的文件拷贝到此处，之后展开所有的变量，显式规则（explicit rules）以及隐式规则（implicit rules），并构建文件依赖树。

**第二个阶段**make会判断哪些文件需要更新，并运行相应的构建方法（recipes）

对于这两个阶段的理解非常重要，之后有关变量的展开和这两个过程息息相关


## 2.2 Makefile的解析过程

> 这里首先引入有关于变量展开的几个概念：
>
> **立即展开（immediate）** 指的是该变量在第1阶段就得到展开。此时只是进行文件依赖的推导，并未执行实际的操作
>
> **延迟展开（deferred）** 指的是该变量在第2阶段才被展开，或者在一个立即（immediate）的上下文中被引用而被强制展开

Makefile的解析流程如下

> 1. 读取Makefile一整行，去除注释
>
> 2. 如果行以recipe的前缀符号开头（一般是制表符），那么代表此时处在一个recipe的上下文，将该行加入当前的recipe并继续读取下一行
>
> 3. 将所有处于immediate的上下文变量展开
>
> 4. 扫描行中的`=`或`:`符，如果有就代表该行是变量规定（macro assignment）或规则（rule）
>
> 5. 进行相应操作，读取下一行


## 3 Makefile格式以及编写

## 3.1 Makefile变量

变量的引用通过形如`${var}`或`$(var)`

imm和def指变量的类型（immediate或deferred）

变量的赋值有以下几种

| 形式 | 解释 |
| :-: | :-: |
| imm = def |  |
| imm := imm |  |
| imm ::= imm |  |
| imm ?= def |  |
| imm += def/imm |  |
| imm != imm |  |


## 3.2 规则（Rule）

规则（rule）的定义格式大致如下

```makefile
targets : prerequisites ; recipe
    recipe
```

**recipe行开头需要使用制表符作为前缀标记该行为recipe**，变量类型

```makefile
imm : imm ; def
    def
```


## 3.3 隐式规则（Implicit rules）


## 3.4 构建操作（Recipes）


## 3.5 条件判断


## 3.6 使用自带函数


## 3. 示例

## 4 用于生成Makefile的工具之：CMake

## 5 用于生成Makefile的工具之：automake和autoconf

## 6 BSD Make

FreeBSD拥有自己的一套完整的工具链。它使用BSD Make作为默认make工具，GNU Make在FreeBSD仓库中被称为gmake