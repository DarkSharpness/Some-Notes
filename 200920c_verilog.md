# 数字电路基础 Verilog FPGA 开发入门笔记

有关数字电路的一些理论知识以及基于Verilog的FPGA开发入门

## 参考书籍

*Fundamentals of Digital Logic with Verilog Design (Second Edition), Stephen Brown, Zvonko Vranesic, Canada, 2007, ISBN 978-7-111-22182-1*


## 1 数字电路基础

*记录比较常用的一些理论以及解决问题的方法*


### 1.1 布尔（逻辑）代数公理

用于基本与或非电路的设计

*（离散数学学过了）*

| 名称 | 公式 |
| :--: | :--: |
| 双否律 | ~~A = A |
| 交换律 | A·B = B·A, A+B = B+A |
| 结合律 | (A·B)·C = A·(B·C), (A+B)+C = A+(B+C) |
| 分配律 | (A·B)+C = (A+C)·(B+C), (A+B)·C = (A·C)+(B·C) |
| 德摩根律 | ~(A+B) = (~A)·(~B), ~(A·B) = (~A)+(~B) |
| 吸收律 | A·(A+B) = A, A+(A·B) = A |
| 幂等律 | A+A = A, A·A = A |
| 同一律 | A+0 = A, A·1 = A |
| 零一律 | A·0 = 0, A+1 = 1 |
| 排中律 | (~A)+A = 1 |
| 矛盾律 | (~A)·A = 0 |
| 异或等价公式 | A⊕B = (B·~A)+(A·~B) | 


### 1.2 触发器，寄存器，计数器

逻辑电路中，触发器为重要组成部分，带入了时序，将逻辑电路的行为从空间扩展到了时间，从组合逻辑到时序逻辑


#### 1.2.1 SR锁存器

#### 1.2.2 D锁存器

#### 1.2.3 T触发器

#### 1.2.4 JK触发器

#### 1.2.5 寄存器

#### 1.2.6 计数器


### 1.3 根据真值表反推逻辑表达式

有两种方法，所有真值为1的项的主析取范式，或所有真值为0的项的主合取范式，具体视情况而定，尽量使用较简单的方法

**示例**

有如下真值表，ABC为输入，X为输出

| A | B | C | X |
| :-: | :-: | :-: | :-: |
| 0 | 0 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 1 |
| 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 0 |

**取1项作主析取范式（正则积之和形式，每一个积都是最小项）**

> X = (~A)·(~B)·(~C) + A·(~B)·(~C) + A·B·(~C) + A·(~B)·C

**取0项作主合取范式（正则和之积形式，每一个和都是最大项）**

> X = (A+(~B)+C) · (A+B+(~C)) · (A+(~B)+(~C)) · ((~A)+(~B)+(~C))

**主析取范式/主合取范式互相转换**

以上为例，主析取范式为

> X = (~A)·(~B)·(~C) + A·(~B)·(~C) + A·B·(~C) + A·(~B)·C

没有出现的项为

> A·B·C, (~A)·B·C, (~A)·(~B)·C, (~A)·B·(~C)

那么

> ~X = A·B·C + (~A)·B·C + (~A)·(~B)·C + (~A)·B·(~C)

由双否律以及德摩根律又可以推出

> X = ~~X = ~(A·B·C + (~A)·B·C + (~A)·(~B)·C + (~A)·B·(~C))
> 
> X = ((~A)+(~B)+(~C)) · (A+(~B)+(~C)) · (A+B+(~C)) · (A+(~B)+C)

*反之求主合取范式的等价主析取范式同理*

**补充：积之和/和之积一般表示方式**

积之和

> X = m0 + m1 + m3 + m5 = ∑m(0, 1, 3, 5)

和之积

> X = M2 · M4 · M6 · M7 = ∏M(2, 4, 6, 7)

*最小项与其对应的最大项关系 m2 = ~M2*


### 1.4 逻辑电路的优化

在逻辑电路的设计中，同一个电路一般有多种具体实现，考虑到成本，设计复杂度以及功耗，需要对电路进行化简

门电路数以及门电路输入端数量之和为衡量电路成本的重要因素


#### 1.4.1 一般化简

简单情况下，逻辑电路的化简，就是使用布尔代数公理，化简主析取/主合取范式的过程

在之前的示例中，可以化简主范式如下

> X = (~B)·(~C) + (~B)·A + (~C)·A


#### 1.4.2 优化理论

在大规模电路中，一般的根据布尔代数公理推导会非常复杂，因此引入一套完整的理论用于逻辑代数的优化，也可以看作是通用的高级优化方法。这些方法被广泛应用于集成电路设计以及FPGA的EDA中。

+ **图表法（卡诺图法，适用于人工作业）**

    *可以使用积之和，也可以和之积，原理相同*

    **二变量卡诺图**

    真值表

    | X1 | X2 | X |
    | :-: | :-: | :-: |
    | 0 | 0 | m0 |
    | 0 | 1 | m1 |
    | 1 | 0 | m2 |
    | 1 | 1 | m3 |

    卡诺图

    | X2 \ X1 | 0 | 1 |
    | :-: | :-: | :-: |
    | 0 | m0 | m2 |
    | 1 | m1 | m3 |

    这里设 m0=1, m1=1, m2=0, m3=1 
    
    | X2 \ X1 | 0 | 1 |
    | :-: | :-: | :-: |
    | 0 | 1 | 0 |
    | 1 | 1 | 1 |

    **分析**：由上图可以发现，X1=0 对应的列为1，X2=1 对应的行为1，直接可以得出

    > X = (~X1) + X2

    **三变量卡诺图**

    真值表

    | X1 | X2 | X3 | X |
    | :-: | :-: | :-: | :-: |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 1 |
    | 0 | 1 | 0 | 0 |
    | 0 | 1 | 1 | 0 |
    | 1 | 0 | 0 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 0 |

    卡诺图，三维表格

    | X3 \ X1X2 | 00 | 01 | 11 | 10 |
    | :-: | :-: | :-: | :-: | :-: |
    | 0 | 0 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 0 | 1 |

    这里X1X2行需要使用格雷码，有关格雷码这里写了一个生成器，[查看源码](src/200920c01/graycode/gray.c)

    **分析**：由上图，可以把表想象成可以卷起来的圆筒，X1X2行构成循环，所以X1X2=00 X3=1以及X1X2=10 X3=1也要考虑 

    > X = X1(~X3) + (~X2)X3

    **卡诺图优化一般规律总结**

    找到卡诺图里面相邻2^n(2, 4, 8, 16...)个都是1的格子，可以合并成一个项，在拐角处相交重合的也可以优化，正方形的也可以优化成一个项，总之基本原则就是使用尽量少的优化次数优化尽量多的项，并且一次优化的数量在允许范围内要尽可能多，以减少单个项的元素数，例如在有正方形存在情况下就不要使用相邻两个优化了

    **再举例：四变量卡诺图**

    四维表格

    | X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
    | :-: | :-: | :-: | :-: | :-: |
    | 00 | 1 | 0 | 0 | 1 |
    | 01 | 0 | 0 | 0 | 0 |
    | 11 | 1 | 1 | 1 | 0 | 
    | 10 | 1 | 1 | 0 | 1 |

    通过观察

    > X = (~X1)X3 + (~X2)(~X4) + X2X3X4

    **扩展：五变量卡诺图**

    五维表格，可以使用两张四维表格表示

    X5 = 0

    | X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
    | :-: | :-: | :-: | :-: | :-: |
    | 00 |  |  |  |  |
    | 01 |  |  | 1 | 1 |
    | 11 | 1 | 1 |  |  | 
    | 10 | 1 | 1 |  |  |

    X5 = 1

    | X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
    | :-: | :-: | :-: | :-: | :-: |
    | 00 |  |  |  | 1 |
    | 01 |  |  | 1 | 1 |
    | 11 | 1 | 1 |  |  | 
    | 10 | 1 | 1 |  |  |

    > X = (~X1)X3 + X1(~X3)X4 + X1(~X2)(~X3)X5

    **卡诺图法小记**

    卡诺图法只适用于少量变量的情况

    介绍几个概念：

    > 蕴含项：可以使f=1的项
    >
    > 质蕴含项：不可再次合并为项数更少的项
    > 
    > 本质蕴含项：不可缺少，必须包含的质蕴含项，其他可有可无的为非本质蕴含项
    >
    > 覆盖：一个蕴含项的集合可以说明函数值为1的所有情况
    > 
    > 成本：假设求反成本为零，门电路数与输入端数之和

    在优化中，要在可能的蕴含项集合中凑出相比其他大部分方案更节约成本的方案，因为可能的解法一般远远不止一种，而且这些方案成本一般会不同

    有时候会碰到根本不存在本质蕴含项的情况，这种情况只能逐个凑

    **非完全指定函数**

    有时候一个逻辑电路的所有输入情况并不会全部出现，这种情况下就会形成非完全指定函数，如下例

    | X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
    | :-: | :-: | :-: | :-: | :-: |
    | 00 | 0 | 1 | d | 0 |
    | 01 | 0 | 1 | d | 0 |
    | 11 | 0 | 0 | d | 0 | 
    | 10 | 1 | 1 | d | 1 |

    其中，d代表的输入永远不会出现

    这样，可以把部分d补为1，以实现最简电路

    | X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
    | :-: | :-: | :-: | :-: | :-: |
    | 00 | 0 | 1 | 1 | 0 |
    | 01 | 0 | 1 | 1 | 0 |
    | 11 | 0 | 0 | d | 0 | 
    | 10 | 1 | 1 | 1 | 1 |

    > X = X2(~X3) + X3(~X4)

    **多输出电路**

    很多时候要求一个电路输出端不止一个，这时候就要求设计共用尽量多的电路，以下为一般方法

    f1定义

    | X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
    | :-: | :-: | :-: | :-: | :-: |
    | 00 |  |  |  |  |
    | 01 | 1 | 1 | 1 |  |
    | 11 | 1 | 1 | 1 |  | 
    | 10 |  | 1 |  |  |

    f2定义

    | X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
    | :-: | :-: | :-: | :-: | :-: |
    | 00 |  |  |  |  |
    | 01 | 1 |  | 1 | 1 |
    | 11 | 1 |  | 1 | 1 | 
    | 10 |  | 1 |  |  |

    > f1 = X1X2X4 + (~X1)X2X3(~X4) + (~X1)X4
    >
    > f2 = X1X2X4 + (~X1)X2X3(~X4) + (~X2)X4

    可以达到共用的目的

    **多级综合问题**

    有时候当一个电路的输入端过多时，需要解决电路的扇入问题

    在一般的逻辑电路中，与门输入端一般不超过8个，FPGA中单个查找表的输入也是相当有限的，所以要将多输入的逻辑函数分解成多级以适应具体的电路限制

    示例：

    > f = X1X3(~X6) + X1X4X5(~X6) + X2X3X7 + X2X4X5X7

    提取公因式

    > f = X1(~X6)(X3 + X4X5) + X2X7(X3 + X4X5)

    可以用于2输入端逻辑单元的FPGA

    补充：子函数分解

    有时候可以将某些部分看作一个完整的子函数，可以大大降低电路成本

    示例：

    > f = ((~X1)X2 + X1(~X2))X3 + (X1X2 + (~X1)(~X2))X4

    推导可知

    > (~X1)X2 + X1(~X2) = ~(X1X2 + (~X1)(~X2))

    可以将(~X1)X2 + X1(~X2)看作一个子函数g(X1, X2)

    那么

    > f = g(X1, X2)·X3 + ~g(X1, X2)·X4

+ **立方体表示法（适用于计算机作业）**

    


### 1.5 常用的算术硬件以及计算方法

算术电路是CPU的核心部分，常见的一般有加法器，乘法器，除法器，以及针对定点浮点运算的算术逻辑电路

本小节也会记录各种算法原理，如二进制乘法除法，浮点算法，以及其他常用加密/校验算法，如AES，DES，CRC，MD5等

#### 1.5.1 加法器

#### 1.5.2 


## 2 Verilog HDL入门

*Verilog HDL 和 VHDL 是两种不同的硬件描述语言*

### 2.1






