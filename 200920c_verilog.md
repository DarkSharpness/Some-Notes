# 数字电路基础 Verilog FPGA 开发入门笔记

有关数字电路的一些理论知识以及基于Verilog的FPGA开发入门

## 参考书籍

*Fundamentals of Digital Logic with Verilog Design (Second Edition), Stephen Brown, Zvonko Vranesic, Canada, 2007, ISBN 978-7-111-22182-1*


## 1 数字电路基础

*记录比较常用的一些理论以及解决问题的方法*


### 1.1 布尔（逻辑）代数公理

用于基本与或非电路的设计

*（离散数学学过了）*

| 名称 | 公式 |
| :--: | :--: |
| 双否律 | ~~A = A |
| 交换律 | A·B = B·A, A+B = B+A |
| 结合律 | (A·B)·C = A·(B·C), (A+B)+C = A+(B+C) |
| 分配律 | (A·B)+C = (A+C)·(B+C), (A+B)·C = (A·C)+(B·C) |
| 德摩根律 | ~(A+B) = (~A)·(~B), ~(A·B) = (~A)+(~B) |
| 吸收律 | A·(A+B) = A, A+(A·B) = A |
| 幂等律 | A+A = A, A·A = A |
| 同一律 | A+0 = A, A·1 = A |
| 零一律 | A·0 = 0, A+1 = 1 |
| 排中律 | (~A)+A = 1 |
| 矛盾律 | (~A)·A = 0 |
| 异或等价公式 | A⊕B = (B·~A)+(A·~B) | 


### 1.2 触发器，寄存器，计数器

逻辑电路中，触发器为重要组成部分，带入了时序，将逻辑电路的行为从空间扩展到了时间，从组合逻辑到时序逻辑


#### 1.2.1 SR锁存器

#### 1.2.2 D锁存器

#### 1.2.3 T触发器

#### 1.2.4 JK触发器

#### 1.2.5 寄存器

#### 1.2.6 计数器


### 1.3 根据真值表反推逻辑表达式

有两种方法，所有真值为1的项的主析取范式，或所有真值为0的项的主合取范式，具体视情况而定，尽量使用较简单的方法

**示例**

有如下真值表，ABC为输入，X为输出

| A | B | C | X |
| :-: | :-: | :-: | :-: |
| 0 | 0 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 1 |
| 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 0 |

**取1项作主析取范式（正则积之和形式，每一个积都是最小项）**

> X = (~A)·(~B)·(~C) + A·(~B)·(~C) + A·B·(~C) + A·(~B)·C

**取0项作主合取范式（正则和之积形式，每一个和都是最大项）**

> X = (A+(~B)+C) · (A+B+(~C)) · (A+(~B)+(~C)) · ((~A)+(~B)+(~C))

**主析取范式/主合取范式互相转换**

以上为例，主析取范式为

> X = (~A)·(~B)·(~C) + A·(~B)·(~C) + A·B·(~C) + A·(~B)·C

没有出现的项为

> A·B·C, (~A)·B·C, (~A)·(~B)·C, (~A)·B·(~C)

那么

> ~X = A·B·C + (~A)·B·C + (~A)·(~B)·C + (~A)·B·(~C)

由双否律以及德摩根律又可以推出

> X = ~~X = ~(A·B·C + (~A)·B·C + (~A)·(~B)·C + (~A)·B·(~C))
> 
> X = ((~A)+(~B)+(~C)) · (A+(~B)+(~C)) · (A+B+(~C)) · (A+(~B)+C)

*反之求主合取范式的等价主析取范式同理*

**补充：积之和/和之积一般表示方式**

积之和

> X = m0 + m1 + m3 + m5 = ∑m(0, 1, 3, 5)

和之积

> X = M2 · M4 · M6 · M7 = ∏M(2, 4, 6, 7)

*最小项与其对应的最大项关系 m2 = ~M2*


### 1.4 逻辑电路的优化

在逻辑电路的设计中，同一个电路一般有多种具体实现，考虑到成本，设计复杂度以及功耗，需要对电路进行化简

门电路数以及门电路输入端数量之和为衡量电路成本的重要因素


#### 1.4.1 一般化简

简单情况下，逻辑电路的化简，就是使用布尔代数公理，化简主析取/主合取范式的过程

在之前的示例中，可以化简主范式如下

> X = (~B)·(~C) + (~B)·A + (~C)·A


#### 1.4.2 优化理论

在大规模电路中，一般的根据布尔代数公理推导会非常复杂，因此引入一套完整的理论用于逻辑代数的优化，也可以看作是通用的高级优化方法。这些方法被广泛应用于集成电路设计以及FPGA的EDA中。

##### 1.4.2.1 图表法（卡诺图法，适用于人工作业）

*可以使用积之和，也可以和之积，原理相同*

**二变量卡诺图**

真值表

| X1 | X2 | X |
| :-: | :-: | :-: |
| 0 | 0 | m0 |
| 0 | 1 | m1 |
| 1 | 0 | m2 |
| 1 | 1 | m3 |

卡诺图

| X2 \ X1 | 0 | 1 |
| :-: | :-: | :-: |
| 0 | m0 | m2 |
| 1 | m1 | m3 |

这里设 m0=1, m1=1, m2=0, m3=1 

| X2 \ X1 | 0 | 1 |
| :-: | :-: | :-: |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

**分析**：由上图可以发现，X1=0 对应的列为1，X2=1 对应的行为1，直接可以得出

> X = (~X1) + X2

**三变量卡诺图**

真值表

| X1 | X2 | X3 | X |
| :-: | :-: | :-: | :-: |
| 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 0 |

卡诺图，三维表格

| X3 \ X1X2 | 00 | 01 | 11 | 10 |
| :-: | :-: | :-: | :-: | :-: |
| 0 | 0 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 | 1 |

这里X1X2行需要使用格雷码，有关格雷码这里写了一个生成器，[查看源码](src/200920c01/graycode/gray.c)

**分析**：由上图，可以把表想象成可以卷起来的圆筒，X1X2行构成循环，所以X1X2=00 X3=1以及X1X2=10 X3=1也要考虑 

> X = X1(~X3) + (~X2)X3

**卡诺图优化一般规律总结**

找到卡诺图里面相邻2^n(2, 4, 8, 16...)个都是1的格子，可以合并成一个项，在拐角处相交重合的也可以优化，正方形的也可以优化成一个项，总之基本原则就是使用尽量少的优化次数优化尽量多的项，并且一次优化的数量在允许范围内要尽可能多，以减少单个项的元素数，例如在有正方形存在情况下就不要使用相邻两个优化了

**再举例：四变量卡诺图**

四维表格

| X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
| :-: | :-: | :-: | :-: | :-: |
| 00 | 1 | 0 | 0 | 1 |
| 01 | 0 | 0 | 0 | 0 |
| 11 | 1 | 1 | 1 | 0 | 
| 10 | 1 | 1 | 0 | 1 |

通过观察

> X = (~X1)X3 + (~X2)(~X4) + X2X3X4

**扩展：五变量卡诺图**

五维表格，可以使用两张四维表格表示

X5 = 0

| X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
| :-: | :-: | :-: | :-: | :-: |
| 00 |  |  |  |  |
| 01 |  |  | 1 | 1 |
| 11 | 1 | 1 |  |  | 
| 10 | 1 | 1 |  |  |

X5 = 1

| X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
| :-: | :-: | :-: | :-: | :-: |
| 00 |  |  |  | 1 |
| 01 |  |  | 1 | 1 |
| 11 | 1 | 1 |  |  | 
| 10 | 1 | 1 |  |  |

> X = (~X1)X3 + X1(~X3)X4 + X1(~X2)(~X3)X5

**卡诺图法小记**

卡诺图法只适用于少量变量的情况

介绍几个概念：

> 蕴含项：可以使f=1的项
>
> 质蕴含项：不可再次合并为项数更少的项
> 
> 本质蕴含项：不可缺少，必须包含的质蕴含项，其他可有可无的为非本质蕴含项
>
> 覆盖：一个蕴含项的集合可以说明函数值为1的所有情况
> 
> 成本：假设求反成本为零，门电路数与输入端数之和

在优化中，要在可能的蕴含项集合中凑出相比其他大部分方案更节约成本的方案，因为可能的解法一般远远不止一种，而且这些方案成本一般会不同

有时候会碰到根本不存在本质蕴含项的情况，这种情况只能逐个凑

**非完全指定函数**

有时候一个逻辑电路的所有输入情况并不会全部出现，这种情况下就会形成非完全指定函数，如下例

| X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
| :-: | :-: | :-: | :-: | :-: |
| 00 | 0 | 1 | d | 0 |
| 01 | 0 | 1 | d | 0 |
| 11 | 0 | 0 | d | 0 | 
| 10 | 1 | 1 | d | 1 |

其中，d代表的输入永远不会出现

这样，可以把部分d补为1，以实现最简电路

| X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
| :-: | :-: | :-: | :-: | :-: |
| 00 | 0 | 1 | 1 | 0 |
| 01 | 0 | 1 | 1 | 0 |
| 11 | 0 | 0 | d | 0 | 
| 10 | 1 | 1 | 1 | 1 |

> X = X2(~X3) + X3(~X4)

**多输出电路**

很多时候要求一个电路输出端不止一个，这时候就要求设计共用尽量多的电路，以下为一般方法

f1定义

| X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
| :-: | :-: | :-: | :-: | :-: |
| 00 |  |  |  |  |
| 01 | 1 | 1 | 1 |  |
| 11 | 1 | 1 | 1 |  | 
| 10 |  | 1 |  |  |

f2定义

| X3X4 \ X1X2 | 00 | 01 | 11 | 10 |
| :-: | :-: | :-: | :-: | :-: |
| 00 |  |  |  |  |
| 01 | 1 |  | 1 | 1 |
| 11 | 1 |  | 1 | 1 | 
| 10 |  | 1 |  |  |

> f1 = X1X2X4 + (~X1)X2X3(~X4) + (~X1)X4
>
> f2 = X1X2X4 + (~X1)X2X3(~X4) + (~X2)X4

可以达到共用的目的

**多级综合问题**

有时候当一个电路的输入端过多时，需要解决电路的扇入问题

在一般的逻辑电路中，与门输入端一般不超过8个，FPGA中单个查找表的输入也是相当有限的，所以要将多输入的逻辑函数分解成多级以适应具体的电路限制

示例：

> f = X1X3(~X6) + X1X4X5(~X6) + X2X3X7 + X2X4X5X7

提取公因式

> f = X1(~X6)(X3 + X4X5) + X2X7(X3 + X4X5)

可以用于2输入端逻辑单元的FPGA

补充：子函数分解

有时候可以将某些部分看作一个完整的子函数，可以大大降低电路成本

示例：

> f = ((~X1)X2 + X1(~X2))X3 + (X1X2 + (~X1)(~X2))X4

推导可知

> (~X1)X2 + X1(~X2) = ~(X1X2 + (~X1)(~X2))

可以将(~X1)X2 + X1(~X2)看作一个子函数g(X1, X2)

那么

> f = g(X1, X2)·X3 + ~g(X1, X2)·X4

##### 1.4.2.2 列表法/立方体表示法（适用于计算机算法）

所谓立方体实际是一个抽象概念

设想这样一个由3位格雷码生成的立方体

![图片取自网络](images/200920c001.png "格雷码立方体")

所有边连接的两个顶点都只有一个比特不同，一条边代表有两个比特相同的项，比如连接 000 010 的边代表项 (~X1)(~X3)，可以表示为 0x0。相似的，一个面 000 100 010 110 代表项 (~X3)，可以表示为 xx0。立方体中每个顶点都和另外3个顶点相连，这另外3个顶点正好就只差一个比特。所谓立方体就是指的这种互联结构。这种互联结构可以看作多维立方体（2^n个顶点），内部包含低于其维度的子立方体。

要找出一个电路的优化，首先就要找出所有f=1的边。

立方体的合并：两个小立方体可以合并成为一个大立方体。例如：0xx1x 和 0xx0x 可以合并为 0xxxx

**列表法化简**

设 f = ∑m(0, 4, 8, 10, 11, 12, 13, 15)

可以列表如下

| m | x x x x |
| :-: | :-: |
| 0 | 0 0 0 0 |
| 4 | 0 1 0 0 |
| 8 | 1 0 0 0 |
| 10 | 1 0 1 0 |
| 12 | 1 1 0 0 |
| 11 | 1 0 1 1 |
| 13 | 1 1 0 1 |
| 15 | 1 1 1 1 |

最终合并如下

| m | x x x x |
| :-: | :-: |
| 8,10 | 1 0 x 0 |
| 10,11 | 1 0 1 x |
| 12,13 | 1 1 0 x |
| 11,15 | 1 x 1 1 |
| 13,15 | 1 1 x 1 |

| m | x x x x |
| :-: | :-: |
| 0,4,8,12 | x x 0 0 |

设P={10x0, 101x, 110x, 1x11, 11x1, xx00}={p1, p2, p3, p4, p5, p6}，可以列表如下

| P | 0 | 4 | 8 | 10 | 11 | 12 | 13 | 15 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| p1 |  |  | √ | √ |  |  |  |  |
| p2 |  |  |  | √ | √ |  |  |  |
| p3 |  |  |  |  |  | √ | √ |  |
| p4 |  |  |  |  | √ |  |  | √ |
| p5 |  |  |  |  |  |  | √ | √ |
| p6 | √ | √ | √ |  |  | √ |  |  |

由上表，p6唯一覆盖了0 4，必须包含

去掉p6行以及对应的0,4,8,12列，得到下表

| P | 10 | 11 | 13 | 15 |
| :-: | :-: | :-: | :-: | :-: |
| p1 | √ |  |  |  |
| p2 | √ | √ |  |  |
| p3 |  |  | √ |  |
| p4 |  | √ |  | √ |
| p5 |  |  | √ | √ |

**支配行**：由上表可以看到p2包含了p1的情况，称为p2支配p1，并且p2和p1实现成本相同，因此可以去掉p1（如果p2实现成本高于p1则不可删除），同理可以去掉p3得到下表

另外还有**支配列**的概念，和支配行类似，不同的是支配列去掉的是支配列而不是被支配列，好理解

| P | 10 | 11 | 13 | 15 |
| :-: | :-: | :-: | :-: | :-: |
| p2 | √ | √ |  |  |
| p4 |  | √ |  | √ |
| p5 |  |  | √ | √ |

发现p2和p5不可删除，p4包含在p2和p5里面

所以最终覆盖C={p2, p5, p6}={101x, 11x1, xx00}

**列表法算法小结**

    1. 首先根据真值表列出所有f=1的最小项，使用立方体比较产生f的所有质蕴含项
    2. 列出质蕴涵项覆盖表
    3. 将当前已经发现的本质蕴含项包含到最终覆盖表并去除对应行和列
    4. 使用行支配以及列支配进一步化简，注意先比较成本再决定是否删去
    5. 重复3至4，直到覆盖表变空或不可化简
    6. 若化简后不为空，用分支法确定哪些项应该包含在最终覆盖表中

*列表法局限性：一般逻辑函数很少以最小项形式给出，而是以代数表达式或立方体集合给出。这样就需要先将代数表达式和立方体集合扩展成为最小项形式。这样的覆盖表会变得非常大，立方体简化也会异常复杂，算法速度很慢*

**立方体表示法化简**

这些算法一般会在EDA里面集成用于电路的优化，一般用户不用考虑这些算法，了解一下就行

实际应用中（比如开发一个EDA），一般得到的用户输入都是蕴含项之和的形式，这些蕴含项不一定是最小项或者质蕴含项。

这里定义 **星积（*）** 运算：

*运算一般用于寻找质蕴涵项，运算结果如果是维数大的立方体则应该保留，维数相同看包含关系决定是否删除（其实就是看生成的C立方体是否被原来的包含）

设A,B为n变量函数中的两个蕴含项

> A = A1A2...An
> 
> B = B1B2...Bn
> 
> Ai或Bi可以为0,1,x

设C = A * B

*运算规律如下

| Ai\Bi | 0 | 1 | x |
| :-: | :-: | :-: | :-: |
| 0 | 0 | 空 | 0 |
| 1 | 空 | 1 | 1 |
| x | 0 | 1 | x |

生成C规则：

    1. 若多于一个Ai*Bi=空，则C=空
    2. 以上条件不满足，则当Ai*Bi=空时Ci=x；Ai*Bi≠空时Ci=Ai*Bi

计算f质蕴涵项步骤

    1. 设Ck为f的一个覆盖，对Ck中所有项两两配对进行*运算后生成Gk+1
    2. 设Ck+1 = Ck ∪ Gk+1 - 冗余立方体（冗余立方体：若A被B所包含，则去掉A）
    3. 重复以上运算直到Ck+1 = Ck
    4. 最终的C就是质蕴含项集合

再定义一个 **飒（#）** 运算：

\#运算用于确定本质蕴含项，判断一个立方体是否包含另一个立方体

\#运算规律如下，\#运算具有反对称性，不支持交换律

| Ai\Bi | 0 | 1 | x |
| :-: | :-: | :-: | :-: |
| 0 | ε | 空 | ε |
| 1 | 空 | ε | ε |
| x | 1 | 0 | ε |

生成C规则：

    1. 若存在Ai # Bi = 空，则C = A （不相交）
    2. 若所有Ai # Bi = ε，则C = 空 （B覆盖A）
    3. 除以上情况，此情况可能生成多个立方体，Ai = x，Bi ≠ x，C = ∪i(A1, A2,...(~Bi)...,An) （B部分覆盖A）

获取本质蕴含项步骤：

    1. 直接套公式：pi # (P - pi) # DC ≠ 空 成立，那么pi就是本质蕴含项

其中，P为质蕴含项总集合，DC为无关项总集合


### 1.5 常用的算术硬件以及计算方法

算术电路是CPU的核心部分，常见的一般有加法器，乘法器，除法器，以及针对定点浮点运算的算术逻辑电路

本小节也会记录各种算法原理，如二进制乘法除法，浮点算法，SIMD机制，以及其他常用加密/校验算法，如AES，DES，CRC，MD5，SHA等（现代CPU很多都带有加解密硬件）

#### 1.5.1 加法器

#### 1.5.2 


## 2 Verilog HDL入门

*注意Verilog HDL 和 VHDL 是两种不同的硬件描述语言*

### 2.1






