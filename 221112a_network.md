# 计算机网络

## 目录

+ [**1**](#1-协议栈分层模型) 协议栈分层模型
+ [**2**](#2-常用评估指标) 常用评估指标
    + [**2.1**](#21-带宽bandwidth) 带宽（Bandwidth）
    + [**2.2**](#22-延迟latency) 延迟（Latency）
    + [**2.3**](#23-错误率error-rate) 错误率（Error Rate）
+ [**3**](#3-数据链路层) 数据链路层
    + [**3.1**](#31-ethernet以太网) Ethernet以太网
        + [**3.1.1**](#311-物理介质) 物理介质
        + [**3.1.2**](#312-以太网帧格式) 以太网帧格式
        + [**3.1.3**](#313-以太网设施repeater和bridge) 以太网设施：Repeater和Bridge
        + [**3.1.4**](#314-以太网设施二层交换机switch) 以太网设施：二层交换机Switch
        + [**3.1.5**](#315-csmacd) CSMA/CD
    + [**3.2**](#32-atm-asynchronous-transfer-mode) ATM Asynchronous-Transfer-Mode
+ [**4**](#4-网络层) 网络层
    + [**4.1**](#41-ipv4) IPv4
        + [**4.1.1**](#411-格式) 格式
        + [**4.1.2**](#412-ipv4地址类型与保留地址) IPv4地址类型与保留地址
        + [**4.1.3**](#413-子网划分和广播) 子网划分和广播
        + [**4.1.4**](#414-ipv4的问题和cidr) IPv4的问题和CIDR
    + [**4.2**](#42-ipv6) IPv6
        + [**4.2.1**](#421-格式) 格式
        + [**4.2.2**](#422-ipv6的地址分配机制) IPv6的地址分配机制
        + [**4.2.3**](#423-保留地址) 保留地址
        + [**4.2.4**](#424-ipv6多播地址) IPv6多播地址
    + [**4.3**](#43-路由原理) 路由原理
        + [**4.3.1**](#431-路由表) 路由表
        + [**4.3.2**](#432-路由协议) 路由协议
    + [**4.4**](#44-arp协议) ARP协议
    + [**4.5**](#45-ndp协议) NDP协议
    + [**4.6**](#46-nat) NAT
+ [**5**](#5-传输层) 传输层
    + [**5.1**](#51-tcp) TCP
        + [**5.1.1**](#511-tcp通信原理) TCP通信原理
        + [**5.1.2**](#512-tcp数据包) TCP数据包
        + [**5.1.3**](#513-tcp实验) TCP实验
        + [**5.1.4**](#514-tcp附加说明) TCP附加说明
    + [**5.2**](#52-udp) UDP
        + [**5.2.1**](#521-udp通信原理) UDP通信原理
        + [**5.2.2**](#522-udp数据包) UDP数据包
    + [**5.3**](#53-icmp) ICMP
        + [**5.3.1**](#531-目标不可达) 目标不可达
        + [**5.3.2**](#532-超时) 超时
        + [**5.3.3**](#533-参数错误) 参数错误
        + [**5.3.4**](#534-重定向) 重定向
        + [**5.3.5**](#535-echo和回复) Echo和回复
        + [**5.3.6**](#536-时间戳) 时间戳
    + [**5.4**](#54-icmpv6) ICMPv6
        + [**5.4.1**](#541-目标不可达) 目标不可达
        + [**5.4.2**](#542-超时) 超时
        + [**5.4.3**](#543-数据包过大) 数据包过大
        + [**5.4.4**](#544-参数错误) 参数错误
        + [**5.4.5**](#545-echo和回复) Echo和回复
        + [**5.4.6**](#546-ndp) NDP
    + [**5.5**](#55-tls) TLS
        + [**5.5.1**](#551-tls基本概念) TLS基本概念
        + [**5.5.2**](#552-tls-handshake) TLS handshake
        + [**5.5.3**](#553-tls-data) TLS data
        + [**5.5.4**](#554-tls-alert) TLS alert
        + [**5.5.5**](#555-tls-change-cipher-spec) TLS change cipher spec
        + [**5.5.6**](#556-附加说明openssl) 附加说明：OpenSSL
    + [**5.6**](#56-quic) QUIC
+ [**6**](#6-应用层) 应用层
    + [**6.1**](#61-http) HTTP
    + [**6.2**](#62-https) HTTPS
    + [**6.3**](#63-dns) DNS
        + [**6.3.1**](#631-dns域名基本概念) DNS域名基本概念
        + [**6.3.2**](#632-dns系统组成) DNS系统组成
        + [**6.3.3**](#633-resource-records) Resource Records
        + [**6.3.4**](#634-dns数据包格式) DNS数据包格式
        + [**6.3.5**](#635-question数据格式) Question数据格式
        + [**6.3.6**](#636-rr数据格式) RR数据格式
        + [**6.3.7**](#637-dns抓包) DNS抓包
    + [**6.4**](#64-dhcp和dhcpv6) DHCP和DHCPv6
        + [**6.4.1**](#641-slaac) SLAAC
    + [**6.5**](#65-telnet) Telnet
    + [**6.6**](#66-ftp和sftp) FTP和SFTP
    + [**6.7**](#67-smtp) SMTP
    + [**6.8**](#68-snmp) SNMP
+ [**7**](#7-附录) 附录
    + [**7.1**](#71-wireshark中部分tcp分析的定义) Wireshark中部分TCP分析的定义
        + [**7.1.1**](#711-tcp-acked-unseen-segment) TCP ACKed unseen segment
        + [**7.1.2**](#712-tcp-dup-ack) TCP Dup ACK
        + [**7.1.3**](#713-tcp-fast-retransmission) TCP Fast Retransmission
        + [**7.1.4**](#714-tcp-keep-alive) TCP Keep-Alive
        + [**7.1.5**](#715-tcp-keep-alive-ack) TCP Keep-Alive ACK
        + [**7.1.6**](#716-tcp-out-of-order) TCP Out-Of-Order
        + [**7.1.7**](#717-tcp-port-numbers-reused) TCP Port numbers reused
        + [**7.1.8**](#718-tcp-previous-segment-not-captured) TCP Previous segment not captured
        + [**7.1.9**](#719-tcp-spurious-retransmission) TCP Spurious Retransmission
        + [**7.1.10**](#7110-tcp-retransmission) TCP Retransmission
        + [**7.1.11**](#7111-tcp-window-full) TCP Window Full
        + [**7.1.12**](#7112-tcp-window-update) TCP Window Update
        + [**7.1.13**](#7113-tcp-zerowindow) TCP ZeroWindow
        + [**7.1.14**](#7114-tcp-zerowindowprobe) TCP ZeroWindowProbe
        + [**7.1.15**](#7115-tcp-zerowindowprobeack) TCP ZeroWindowProbeAck
        + [**7.1.16**](#7116-tcp-ambiguous-interpretations) TCP Ambiguous Interpretations
        + [**7.1.17**](#7117-tcp-conversation-completeness) TCP Conversation Completeness
    + [**7.2**](#72-bgp) BGP
    + [**7.3**](#73-cdn) CDN


## 1 协议栈分层模型

OSI分为7层，定义如下

| 层 | 名称 |
| :-: | :-: |
| `7` | Application 应用层 |
| `6` | Presentation 表示层 |
| `5` | Session 会话层 |
| `4` | Transport 传输层 |
| `3` | Network 网络层 |
| `2` | Datalink 数据链路层 |
| `1` | Physical 物理层 |

TCP/IP(DoD/ARPANet)是事实上的网络分层标准，分为5层（一说4层，无物理层），定义如下

| 层 | 名称 |
| :-: | :-: |
| `5` | Application 应用层 |
| `4` | Transport 传输层 |
| `3` | Network 网络层 |
| `2` | Datalink 数据链路层 |
| `1` | Physical 物理层 |

> `Physical`**物理层**定义了网络传输的物理媒介与连接，如同轴电缆，双绞线，光纤，无线电信号等，定义了实际的编码方式以及信号类型（例如互联方式，无线信号还是电信号或光信号，全双工还是半双工，差分信号还是非差分信号，以及这些信号的调制解调方法）。由于物理层类型繁多，且物理层中数据链路层数据可以和其他许多专有协议数据共存，如果不研究硬件，在4层模型中我们可以不用关注该层
>
> `Datalink`**数据链路层**定义了同一个网络中各元素之间的数据传递，常见的协议有Ethernet（IEEE802.3），在Ethernet中每台设备使用MAC地址作为唯一标识。最传统的**二层交换机**工作于该层，它不需要MAC地址，只需学习、检查各个端口发来的数据包的MAC并查表发送到对应端口即可
>
> `Network`**网络层**定义了网络中终端设备之间的数据传递，该层不提供可靠传输。IPv4以及IPv6是该层事实上的标准协议。**路由器**以及**三层交换机**工作于该层，这些网络设备每一个端口都需要有单独的MAC地址对应。通常所说的默认网关指的就是路由器
>
> `Transport`**传输层**定义了终端设备上**应用实体**之间的数据传输，该层通常需要为数据传输的可靠性提供支持，提供例如数据纠错，缓冲，传输控制等功能，常见的协议有`TCP`，`UDP`。`TCP`和`UDP`都使用端口机制。其中`UDP`由于其不可靠性，在实际中少有单独应用，通常都需要加上额外的包装才能为上层应用提供高效可靠的通信
>
> `Application`**应用层**常见的协议有`HTTP`，`HTTPS`，`SMTP`，`IMAP`，`SSH`等。这些应用层协议会调用特定的`Transport`传输层协议来实现自己的功能

> 之所以叫协议栈，是因为上层需要依赖于下层提供的服务才能运行。从二层交换机到路由器再到主机，这些设备可以处理的网络层级也越高。数据包装是层层嵌套的

![](images/221112a001.png)


## 2 常用评估指标

## 2.1 带宽（Bandwidth）

用于衡量单位时间内传输的数据量，也即容量Volume。单位`kbit/s` `Mbit/s`。在通信中使用**十进制**，以`bit`为基本计量单位，`1kb=1000b`，`1Mb=1000kb`

## 2.2 延迟（Latency）

数据从一个地方传送到另一个地方花费的时间，通常为`ms`级别。许多网络应用受延迟影响较大

## 2.3 错误率（Error Rate）

传输的误码率，如果网络通路良好，这个数值通常非常小，常见的计量单位有`bit/Gb`等。在实际应用中路由器和交换机等基础设施引入的处理延迟以及丢包才是影响普通用户使用体验的关键因素

## 3 数据链路层

## 3.1 Ethernet以太网

参考IEEE802.3

以太网是目前最为主流的链路层协议之一，数据使用以太网数据帧（数据包）的方式进行组织与传输

### 3.1.1 物理介质

以太网最早在1983年以IEEE802.3标准化。最早的以太网使用同轴电缆（coaxial）作为传输介质；后来发展出了如今最为常见的8芯双绞线，使用RJ45接口；以及光纤，常见光纤接口有SC，LC，ST等。以太网的基础设施主要有以太网交换机等。如果物理层使用了光纤，在交换机、路由器、网卡会添加额外的光接口，这些设备经常会使用可拆卸的光模块（SFP）

> 国内运营商光纤入户最常用EPON以及GPON，这些光网络除上网数据外还需要搭载IPTV，语音（座机）以及运营商管理等服务，普通的上网数据在PON网络上走以太网协议。此外连接运营商网络需要验证，只有运营商的光猫才能通过验证并成功联网。在GPON网络中，语音等服务会使用其他一些协议如ATM搭载。而EPON网络中语音也使用以太网数据帧搭载
>
> 多个邻近家庭/用户的网络一般通过分光器共享，分光器再向上连接运营商的OLT设备，这样就形成了多个ONT终端连接一个OLT的PON网络结构。这导致了上下行通信的不对称，从用户角度看下行使用广播的方式，而上行为了解决冲突问题使用TDMA时分复用
>
> 光纤的主要优点是材料成本低，抗干扰能力强，距离远。事实上光信号在光纤中的传导速度要慢于电信号在铜丝中的传导速度，而实际应用中各级路由器以及交换机带来的处理延迟才是更主要的影响因素

### 3.1.2 以太网帧格式

| 名称 | 长度（Byte） | 注解 |
| :-: | :-: | :-: |
| `Preamble` 前导 | `7` | 全`0x55`，用于双方同步时钟 |
| `SFD` 帧起始分隔符 | `1` | `0xD5`，标志以太网帧的起始 |
| `Destination MAC` 目标MAC | `6` | 接收端的MAC地址。`FF:FF:FF:FF:FF:FF`为广播地址（**此外还有组播MAC，这里省略**），数据包会传输到网络上所有的机器并被接受 |
| `Source MAC` 源MAC | `6` | 发送端的MAC地址 |
| `802.1Q` VLAN标签 | `4` | **可选**，前2字节为`TPID`，通常为`0x8100`表示`802.1Q`，后2字节为`TCI`。`TCI[15:13]`为`PCP`用于规定优先级，`TCI[12]`为`DEI`表示数据包在拥塞时可以丢弃，`TCI[11:0]`为`VID`表示VLAN ID，可取范围`[1,4094]`。VLAN用于在一个物理以太网络中虚拟出多个网络，这些网络互不干涉 |
| `EtherType/Size` 上层协议/包大小 | `2` | 值取`[42,1500]`表示Payload的长度（单位Byte），值取`1536`及以上表示上层协议的类型 |
| `Payload` 数据载荷 |  | 长度可变，保证从目标MAC到`FCS`长度不小于`64`（CSMA/CD规定的最小长度）。有VLAN标签时`Payload`最短需要42字节 |
| `FCS` CRC校验码 | `4` | 使用CRC32，多项式`0x04C11DB7` |
| `Inter Frame Gap` 帧间隔 | `12` | 必须有的间隔，标志着数据帧的结束 |

![](images/221112a002.png)

> 以太网数据使用**大端传输**，但是单个Byte使用**LSB在前**的传输方法。例如上表中的`0x55`使用LSB在前的方式传输就会变成`0xAA`，分隔符`0xD5`会变成`0xAB`。只有`FCS`校验码使用**MSB在前**的传输方法

**MAC地址**

MAC地址由硬件厂商向IEEE申请后分配，在一个网络中用于标记一个唯一的接口。例如网卡，笔记本的有线和无线网卡拥有不同的MAC。有些网卡的MAC可以更改，如果一张网卡集成了多个网口，这些网口也会拥有不同的MAC。**网络和网络之间可以使用路由器进行分隔**，正常情况下一个网络内出现MAC冲突的几率非常小

MAC地址最高1字节的LSB（`I/G`）用于区分**单播**`0`或**多播**`1`（传输时该位首先传输），而最高1字节的倒数第2位（`U/L`）用于区分该地址是**全球唯一**`0`还是**本地唯一**`1`，所以我们平常看到的网卡MAC地址最高1字节都是4的倍数。如果用户明确指定，`U/L`可以会被设为`1`，例如在iPhone上开启*私有无线局域网地址*，就会使用这样的一个MAC地址

在实际应用中，如果不信任网络内的交换机/路由器，可以使用随机MAC防止恶意跟踪

日常生活中，在一个局域网内，我们访问外网只能通过默认的路由器（默认网关）。路由器是第三层网络设备，我们通过抓取网页浏览产生的数据流量，可以发现无论访问的IP地址如何变化，数据包的MAC地址永远都是默认网关端口的MAC和我们的网口MAC。以太网数据包从一个网络到另一个网络**需要路由器对MAC地址进行转换**。而二层交换机只负责单个网络内的数据流通（启用VLAN时除外），交换机本身不需要MAC地址，只需根据学习到的MAC将数据发送到对应的端口就可以了

在一个网络中，如果需要嗅探所有主机间的数据包，就需要开启网卡的**混杂模式**，否则网卡只会将符合自己MAC或广播MAC的数据包提交给上层。但是这种数据包嗅探方式对于使用二层交换机的网络而言是无效的，在使用网桥或以太网HUB的网络中才可用。类似地，`FCS`域的CRC校验码也由网卡自行处理，发生错误的直接将数据包丢弃。区别是数据包的`FCS`域**不会递交给上层**

**CRC校验**

IEEE802.3规定以太网的CRC32计算方法如下：

多项式`0x04C11DB7`，省略最高位实际33位`0x104C11DB7`

![](images/221112a003.png)

> 计算CRC的关键点如下：
>
> CRC校验的区域包括2个MAC地址域，可选的VLAN标签域，`EtherType/Size`域，数据域以及数据域的占位符
>
> 校验区域的开头32位取补，数据左移32bit，进行计算
>
> CRC结果取补码，并且传输时同样使用大端，**但是MSB在前**

实际应用中网卡固件通常使用查表的优化算法，或直接硬件实现

**802.1Q优先级**

`802.1Q`定义`PCP`优先级以及对应关系如下

| 值 | 优先级 | 数据类型 |
| :-: | :-: | :-: |
| `1` | `0` | `BK` Background，最低优先级 |
| `0` | `1` | `BE` Best Effort |
| `2` | `2` | `EE` Excellent Effort |
| `3` | `3` | `CA` Critical Applications |
| `4` | `4` | `VI` Video，要求小于100ms延迟 |
| `5` | `5` | `VO` Voice，要求小于10ms延迟 |
| `6` | `6` | `IC` Internetwork Control |
| `7` | `7` | `NC` Network Control |

**常用EtherType上层协议类型**

| 值 | 协议 | 注释 |
| :-: | :-: | :-: |
| `0x0800` | `IPv4` |  |
| `0x0806` | `ARP`  | MAC地址解析 |
| `0x0842` | `Wake-on-LAN` | 网络唤醒 |
| `0x8100` | `IEEE802.1Q` | VLAN |
| `0x86DD` | `IPv6` |  |
| `0x8808` | `Ethernet flow control` | 流控制 |
| `0x8863` | `PPPoE Discovery Stage` |  |
| `0x8864` | `PPPoE Session Stage` |  |
| `0x88CC` | `LLDP` | Link Layer Discovery Protocol |

### 3.1.3 以太网设施：Repeater和Bridge

Repeater相当于一个没有数据缓冲的模拟放大器，它只是将每个端口发来的信号再发送到其他所有端口。以太网HUB就是相当于Repeater，同时有两个主机发送数据会发生冲突

Bridge网桥有数据缓冲，它会将所有端口发来的数据进行缓存，之后再依次从所有网口发出。Bridge大大减小了冲突带来的影响

### 3.1.4 以太网设施：二层交换机Switch

二层交换机Switch是最常用的以太网设施。它本质是一种特殊的网桥，交换机可以理解以太网帧的MAC地址。它会学习各个端口发来的数据包的`Source MAC`源MAC并把对应关系记录到一张表中。如果端口发来数据包的`Destination MAC`存在于表中，那么交换机就会将这个数据包发往对应的端口。如果`Destination MAC`不在表中，这个数据包可能会从所有端口发出

算法较为保守的交换机会缓存整个数据包，进行`CRC`检错后才会将数据包发送往对应端口

算法较为激进的交换机会在收到目标MAC后立即开始数据包的转发（这也是将目标MAC放在开头的原因），此时由于发送方还未传输完毕所以无法进行`CRC`校验。这种交换机更为常用，需要更少的计算资源，包括缓存等，且拥有较小的延迟。但是纠错需要主机端来执行，且一次传输错误容易导致更多网络资源的浪费

### 3.1.5 CSMA/CD

CSMA/CD由网卡实现，全称**载波侦听多路访问/冲突检测**，这个协议广泛应用于通信领域，用于解决物理层面的冲突，尤其是半双工物理信道，比如同轴电缆。但是由于支持物理全双工RJ45接口的交换机的流行，信道争用少了许多，这个算法的作用已经弱化了。而在使用了无缓冲以太网HUB（Repeater）的网络中，这种算法依旧发挥重要作用

> 关于CSMA/CD，需要记住2个点：一个是**载波监听**，也就是一个设备发送前对信道进行监听，发现没有其他设备在发送时才会发送数据。而由于数据在信道上传播时延的存在，单独的监听无法完全避免冲突，**冲突检测**就是边发送边检测冲突。假设一个数据信号从信道一端到另一端的时间为 $\tau$ ，那么争用期长度为 $2\tau$
>
> 假设A和B使用一根长铜线进行通信，A发送了一个数据，这个数据在到达B之前B恰好也发送了一个数据（B在此之前未监听到A发送消息），那么两个信号在铜线上将会发生冲突。假设AB支持发送时**冲突检测**，B在发现自己发送的数据和监测到的铜线的电平不一致，立刻判定冲突停止发送。而A需要在B发送的电信号到达自己这一端时才能检测到电平的不一致问题。所以争用期长度为 $2\tau$。A需要至少等到 $2\tau$ 以后才能判定数据未发生冲突。如果长铜线还连接了其他设备，那么发生冲突的几率会更高
>
> 在检测到冲突以后，发送方需要首先发送一串干扰信号，以便让网络内设备知道发生了冲突
>
> 从冲突中恢复时，需要等待一段随机长度的时间，防止再次发生冲突

常用的8芯双绞线支持物理全双工通信，收发线路分开。一条线缆只能将2个端口连接，收发可以并行。而网络的组建依赖于交换机、网桥或HUB。在这种以太网环境下，只有在多个设备向同一个设备发送数据时才会产生冲突的问题

交换机以及网桥由于拥有数据缓冲，基本解决了物理通信冲突的问题（缓冲溢出除外）。如果一个发往目标MAC地址A的数据包还未发送完，此时其他目标地址为A的数据包就只能在缓冲区等待

无缓冲的HUB中如果多个设备同时发送数据就会导致冲突，设备主要通过**载波监听**（监听RJ45接收端）规避冲突

## 3.2 ATM Asynchronous-Transfer-Mode

目前普通消费级设备中已经很难再接触到ATM，原有的ATM应用领域大部分已经被Ethernet取代。ATM现今应用于一些有特殊要求的领域，在运营商的光网络中可以见到ATM，在GPON光网络中它用于搭载语音服务（从光猫连接出来的座机）

ATM的初衷就是降低通信的延迟，同时避免类似以太网中数据包乱序的问题。ATM基于虚拟线路`Virtual Circuit`设计，两个设备**在通信之前需要网络建立一条虚拟通路**。ATM使用`48`字节的定长数据包（这里称为Cell），Header长`5`字节，共`53`字节。之所以定为48字节是设计之初法国和美国的需求不同，最终在32字节和64字节取了中间数（~~结果谁也没得到好处~~）

ATM数据包格式如下

![](images/221112a004.png)

> ATM网络中用户到网络以及网络和网络之间使用的数据包是不相同的。用户到网络`UNI`数据包中`GFC`表示`Generic Flow Control`，没有实际作用永远为`0`。`VPI`为`Virtual Path ID`，长度1或1.5字节，`VCI`为`Virtual Channel ID`，长度2字节，这2个数据域表示该数据包下一个目的地。`PT`表示数据包类型，`0b1XX`表示数据包用于网络管理，`0b0XX`表示用户数据包，`0b01X`表示网络拥塞。`CLP`为丢包优先级，只有2级。`HEC`为`CRC`，使用多项式`0x107`进行校验

ATM基于虚拟线路的设计导致其较为混乱，资源分配效率低，且带宽分配缺乏灵活性。最终其大部分普通应用被以太网替代

## 4 网络层

网络层用于站点到站点之间的数据传输。目前几乎全部的设备在网络层都使用IPv4以及IPv6

IP协议工作于以太网更上一层。和MAC地址不同，一个数据包在不同网络之间传输，它的源IP和目标IP是不会改变的。**经过NAT路由时除外**

参考RFC791以及RFC1122

## 4.1 IPv4

IPv4数据包的以太网帧`EtherType`为`0x0800`，使用32位表示一个站点，格式`XXX.XXX.XXX.XXX`

### 4.1.1 格式

在RFC791中定义如下

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Example Internet Datagram Header
```

**Word 1**

| 名称 | 长度（bit） | 注解 |
| :-: | :-: | :-: |
| `Version` | `4` | IP版本，这里是`0x4` |
| `IHL`  | `4` | IP Header长度，使用4Byte为单位计数。如果IP Header没有`Options`那么这里为`0x5`，长20字节 |
| `ToS`  | `8` | 服务类型。由于没有明确标准，不常用，为`0x00`。高3位表示数据包的传输优先级，接下来3位依次表示延迟、吞吐、可靠性要求 |
| `Total Length`  | `16` | 总长度，使用字节计数，是包含IP Header的总长度（最长65535字节，64kB） |

**Word 2**

| 名称 | 长度（bit） | 注解 |
| :-: | :-: | :-: |
| `Identification` | `16` | 在分包时常用。一个数据包可以拆分成多个Fragment再传输，这个区域表示当前Fragment所属组（通常是同一个数据包）。大数据包传送到仅支持小数据包的网络中，如果网关（路由器）支持拆包就会分拆后传输 |
| `Flags` | `3` | `0b010`表示禁止拆分，`0b000`表示最后一个Fragment，`0b001`表示还有后续Fragment。如果接收方不支持Fragment拼接，可以规定数据包不允许拆分 |
| `Fragment Offset` | `13` | 表示Fragment在数据包中的偏移（起始地址），以8Byte为单位计数 |

**Word 3**

| 名称 | 长度（bit） | 注解 |
| :-: | :-: | :-: |
| `Time to Live` | `8` | `TTL`，数据包每经过一个路由器都会减1。目前大部分操作系统默认使用`64`作为初始值。如果一个数据包在传输过程中`TTL`减小到`0`，说明经过了太多的路由器，路由器会直接丢弃该包并向发送方发送一个`ICMP Time Exceeded`报文。Linux下常用的`tracepath`就应用了`TTL`（逐次递增）来计算大致的路由路径 |
| `Protocol` | `8` | 数据包搭载的传输层协议。`1`为`ICMP`，`6`为`TCP`，`17`为`UDP` |
| `Header Checksum` | `16` | Header的校验码，不包括之后的数据。这里的校验码计算非常简单（RFC1701），将原先的Checksum置0，Header以2Byte为单位分割后相加，单次加法后进位再加到最低位。最终结果取反码就是校验码。由于路由器需要更改`TTL`，所以路由器每次都要重新计算校验码 |

**Word 4 & 5**

| 名称 | 长度（bit） | 注解 |
| :-: | :-: | :-: |
| `Source Address` | `32` | 源地址 |
| `Destination Address` | `32` | 目标地址 |

**Word 5+**

| 名称 | 长度（bit） | 注解 |
| :-: | :-: | :-: |
| `Options` | 不定 | 基本不使用，会被一些路由器直接丢弃 |

> 在实际的应用中，分包不是很常用。一旦有一个Fragment出现错误整个数据包就不得不重新传输，IPv6废除了分包功能。且分包对于部分传输层的设备来说不友好。`MTU`表示`Media Transmission Unit`或`Maximum Transmission Unit`，最大的传输单元
>
> `TTL`的主要作用就是为网络中的数据包规定一个有限的生命周期，数据包如果在限定时间内未到达目的地会被丢弃而不是无限转发。没有`TTL`数据包就会永远留存在网络中

### 4.1.2 IPv4地址类型与保留地址

世界最大的网络是Internet。IPv4地址分为ABCDE共5大Class，其中有许多IP地址保留，不可分配用于公网IP

IPv4本没有Class之分，后来为满足不同机构、企业的需求才进行了5种Class的划分，且这种划分是针对于Internet而言的。离开了Internet谈Class也就没有意义了

**Class A**

A类地址二进制以`0`开头，第1字节表示网络，后3字节表示主机。理论上可以提供128个`Class A`网络`0.0.0.0/8`到`127.0.0.0/8`，每个网络2^24台主机

实际上`0.0.0.0/8`保留表示当前网络，`127.0.0.0/8`保留用于回环`loopback`（通常使用地址`127.0.0.1`），`10.0.0.0/8`保留用于**私有网络**（和局域网不是一个概念）。`100.0.0.0/8`的子网络地址`100.64.0.0/10`保留用于运营商私有网络

**Class B**

B类地址二进制以`10`开头，前2字节表示网络，后2字节表示主机。理论上可以提供16384个`Class B`网络`128.0.0.0/16`到`191.255.0.0/16`，每个网络2^16台主机

实际上`172.16.0.0/12`（网络`172.16.0.0/16`到网络`172.31.0.0/16`）保留用于**私有网络**，`169.254.0.0/16`保留用于`link-local address`（典型例子是没有手动配置IP且DHCP失败，此时主机会默认给自己指定的IP。在网络故障时经常可以见到这个IP）

**Class C**

C类地址二进制以`110`开头，前3字节表示网络，后1字节表示主机。理论上可以提供2^21个`Class C`网络`192.0.0.0/24`到`223.255.255.0/24`，每个网络2^8台主机

实际上`192.0.2.0/24` `198.51.100.0/24` `203.0.113.0/24`保留用于特殊用途（TEST-NET），`192.88.99.0/24`保留用于IPv6到IPv4中继，`192.168.0.0/16`（网络`192.168.0.0/24`到网络`192.168.255.0/24`）和`192.0.0.0/24`保留用于**私有网络**，`198.18.0.0/15`（网络`198.18.0.0/24`到网络`198.19.255.0/24`）保留用于测试

**Class D**

D类地址二进制以`1110`开头，用于多播。地址范围`224.0.0.0`到`239.255.255.255`

其中`233.252.0.0/24`用于特殊用途（MCAST-TEST-NET）

**Class E**

E类地址二进制以`1111`开头，保留用途。地址范围`240.0.0.0`到`255.255.255.255`

其中地址`255.255.255.255`用于limited broadcast

### 4.1.3 子网划分和广播

在一个网络中，路由器和每台主机都会有自己的子网掩码，形式类似于`255.255.240.0`，前段全为二进制`1`表示IP地址网络字段域，后段全为二进制`0`表示IP地址主机字段域

在每一个子网中，主机地址全`0`表示网络地址，全`1`表示广播地址，这两个地址**不可以分配给主机或路由器端口**。例如私有网络`192.168.0.0/16`配置子网掩码`255.255.240.0`，那么一共划分为子网`192.168.0.0/20`到`192.168.240.0/20`，这些子网络拥有各自的广播IP和网络IP。注意IP广播数据包需要将目标MAC地址域也设为`FF:FF:FF:FF:FF:FF`广播地址，IP组播数据包需要将目标MAC地址设为对应的组播MAC地址

所谓广播就是一个网络中的所有设备都会接受的网络层广播数据包。过多的设备使用同一个广播地址容易引发**广播风暴**，此时可以使用三层交换机并进行子网划分，配合802.11Q VLAN使用

实际在同一个网络中，路由器端口以及各主机端口的子网掩码习惯上配置一致，否则会引发一些奇怪的问题。使用`DHCP`时会指定所有主机使用相同的子网掩码配置

> 子网掩码不是IP数据包的组成部分，它不会在设备之间传输。在一个网络中，主机和路由器还是有可能配置不同的子网掩码的，但是会出现很多问题

> 假设这样一个典型的网络，网络通过交换机构建。有一台路由器的一个端口连接到了这个网络，此外还有主机A以及主机B连接到了这个网络
>
> 路由器设定自己的端口IP为`192.168.1.1`，子网掩码`255.255.255.0`。而A设定自己的端口IP为`192.168.1.243`，子网掩码`255.255.240.0`。B设定自己的端口IP为`192.168.1.192`，子网掩码`255.255.255.240`
>
> 首先，此时路由器广播地址`192.168.1.255`，A广播地址`192.168.15.255`，B广播地址`192.168.1.207`。此时任意两者之间无法接收对方发送的IP广播
>
> 此外，如果想要通过A访问B，A将B的地址和自己的子网掩码进行与运算后发现B和自己处于同一网段。于是A不再将数据发往自己的默认网关，而根据`ARP`协议发送一个数据链路层广播，要求询问`192.168.1.192`的MAC地址并告诉`192.168.1.243`，同时给出自己的MAC地址。此时B收到了这个广播，并将`192.168.1.243`和自己的子网掩码进行与运算，发现和自己不是同一个网段，于是B将`ARP`数据包丢弃。因此A是无法访问B的
>
> 反过来如果不为B配置默认网关，通过B也无法访问A。此时B认为A和自己不在一个网段，于是决定将数据包直接发送给路由器，但是当前B所属的子网中没有可用的路由

> 同一个交换机连接的设备可以属于不同的IP子网，但是没有路由器的情况下不同子网之间通常是无法通信的（除非子网掩码配置不同，导致不同大小的子网出现重叠。特定的地址之间可以进行单向或双向通信，只要双方发现对方和自己同一个网段）。`ARP`协议中主机会丢弃不属于自己网段的`ARP`广播数据包

> 在路由器的同一个端口是有可能绑定多个IP的，只要路由器支持，可以为不同的子网分别提供默认网关（和单臂路由工作原理类似），当然路由器中端口的IP也必须要有正确的子网掩码配置，否则主机`ARP`请求默认网关会失败
>
> 通常子网划分会和VLAN一起使用。单臂路由就使用VLAN分隔WAN和LAN的数据流

### 4.1.4 IPv4的问题和CIDR

历史原因，`IPv4`的地址没有得到高效的分配。许多A类B类网络地址被分配给了单个机构，如MIT，Stanford，惠普等，而这些机构通常没有能力消耗如此多的IP地址

`IPv4`诞生于1980年代，受冷战影响，Internet发展起来以后北美、西欧以外的地区普遍面临IP短缺的问题，在亚洲地区尤为严重。大部分国家如中国只能通过组建大型NAT局域网来缓解（这也是我们查看家庭光猫后台时发现IP地址为运营商局域网地址`10.X.X.X`或`100.X.X.X`的原因，真正的公网IP分配给了运营商的上游网关）。家庭网无法搭建网站，而访问家庭网内的设备需要一对公网、内网设备进行内网穿透，通过公网设备的代理服务才能访问

为解决ABC类网络主机数量过于悬殊无法充分分配的问题，以及路由表过大的问题，实际上现在Internet已经不再遵循ABC类网络的划分了，转而使用了类似于`IPv6`思路的`CIDR`（Classless Inter-Domain Routing）无Class划分，见RFC4632。为方便理解，本文依然遵照旧有的Classful网络讲述，这里只简单对`CIDR`进行一些说明

`CIDR`规定了IP地址由可变长度的网络地址以及随后的主机地址构成。例如`122.23.4.252/12`的网络前缀长`12`，对应的主机地址长`20`。由于使用`CIDR`后公网路由器无法确定一个IP的网络地址，所以要求在路由器协议中都要包含网络地址长度（或掩码），现在OSPF，IS-IS，RIPv2，EIGRP，BGP4路由协议都提供了`CIDR`技术支持。**旧有的路由设备除非进行固件的升级，否则不能再用于Internet**

现在公网`IPv4`地址由IANA统一分配给RIR后再分配到用户。最小的多主机网络需要`/29`，`/28`到`/26`是小型局域网，`/25`和`/24`是大型局域网，`/22`为小型单位，`/21`和`/20`给大型单位和小型运营商，`/8`是最大的可分配网络

## 4.2 IPv6

IPv6的出现主要是为了解决IPv4的枯竭问题，它的应用对于IP地址紧张的地区来说意义重大。IPv6使得网络中每一个设备都可以拥有公网IP。然而IPv6是面向未来设计的，它的工作机制和IPv4不相容；也由于网络基础设施的更新换代问题，在未来很长一段时间内IPv4将会和IPv6共存。兼容两种网络的工作量是巨大的

IPv6数据包的以太网帧`EtherType`为`0x86DD`，使用128位表示一个站点。格式为16进制`XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX`省略前导0。如果有多个16位`0`，这片区域使用`::`代替，例如`fe43:15dd:2e3f:32a:5c66::43eb`中间`::`处省略了`0000:0000`

和IPv4将地址分配给网络中的节点略有不同，IPv6地址的分配对象是网络中的（逻辑上的）接口。也就是说，理论上可以给主机上的每一个进程分配一个IPv6地址。具体内容见[4.2.2](#422-ipv6的地址分配)以及RFC4291

### 4.2.1 格式

在RFC2460中定义如下

```
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version| Traffic Class |           Flow Label                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Payload Length        |  Next Header  |   Hop Limit   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                         Source Address                        +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                      Destination Address                      +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

| 名称 | 长度（bit） | 注解 |
| :-: | :-: | :-: |
| `Version`  | `4` | IP版本，固定值`6` |
| `Traffic Class`  | `8` | 数据包等级，相当于`ToS`，没有权威定义不常使用。默认全`0` |
| `Flow Label`  | `20` | 数据流标签，标记相关的数据，路由器以此可以保证固定的传输路径，没有权威定义不常使用。默认全`0` |
| `Payload Length` | `16` | 搭载的数据的长度，单位Byte，即目标地址后的数据长度 |
| `Next Header` | `8` | 搭载协议，同IPv4的`Protocol`，表示搭载的传输层协议。此外IPv6中还可以表示`Routing header`等非传输层相关数据 |
| `Hop Limit` | `8` | 同IPv4的`TTL` |
| `Source Address` | `128` | 源地址 |
| `Destination Address` | `128` | 目标地址 |

> 相对IPv4来说，IPv6的数据帧结构简单了许多，且没有校验码。在IPv6网络中要求UDP数据包必须要有校验码
>
> IPv6通常要求网络的`MTU`在`1280`或以上

### 4.2.2 IPv6的地址分配机制

> 最早的IPv4本是没有NAT和私有网络的概念的，这些功能主要是为应对IPv4地址紧缺问题而扩展出来的（本质就是用传输层`TCP`或`UDP`的端口号来扩展IP）。不要认为局域网一定要使用私有网络地址（如`192.168.0.0`），局域网和公网连通，就可以使用公网唯一的IP

IPv6地址多达128位，如此多的地址是严重过剩的。为了充分利用，IPv6规定其地址分配的最小细粒度是**网络接口**（`interface`）而非**节点**（`node`）。前64位`/64`为**节点地址**，后64位为节点的**网络接口地址**。这里的接口同样是逻辑上的接口，不是物理上的接口

由于以上原因，IPv6事实上是`64`位地址协议

主机在分配到一个IPv6节点地址以后，可以使用任意的网络接口地址表示自己这台设备本身，从而自行填充剩余64位网络接口地址。例如直接使用网卡MAC填充，或对MAC进行哈希后填充。而主机上的每一个进程也可以拥有一个相同节点地址下的网络接口地址，但是这和`TCP`、`UDP`的接口机制有部分功能上的重合

IPv6也支持类似IPv4的子网划分（prefix）。现在通常家庭网会分配prefix为`/56`或`/48`的网络，分别允许`256`或`65536`台主机，而企业会分配`/48`或`/44`或`/40`。IPv6下不需要私有网络以及NAT来解决公网地址不够的问题，每一台主机都可以拥有公网IP

### 4.2.3 保留地址

| 保留地址 | 用途 |
| :-: | :-: |
| `::/0` | 未指定时使用的默认网关配置 |
| `::/128` | 未初始化 |
| `::1/128` | 回环地址 |
| `::ffff:0:0/96` | 最后4字节网络接口地址，用于映射32位IPv4地址 |
| `::ffff:0:0:0/96` | 最后4字节网络接口地址，用于32位IPv4地址转译（转译算法有多种，各不相同） |
| `fc00::/7` | 私有网络地址，其中`fc00::/8`保留，`fd00::/8`中prefix长`/48`，子网长`/16` |
| `ff00::/8` | 多播地址 |
| `fe80::/10` | Link-local address。这种地址用于单个网络中，路由器分隔的两个网络无法通过该类型地址通信，`NDP`以及`DHCPv6`协议都会使用到它。通常IPv6设备都会配置这样的一个地址，也是因此我们经常发现IPv6设备有2个地址 |
| `64:ff9b::/96` | 公网中用于IPv4IPv6互转 |
| `64:ff9b:1::/48` | 局域网中用于IPv4IPv6互转 |
| `100::/64` | Discard |
| `2001:0000::/32` | Teredo tunneling |
| `2001:20::/28` | ORCHIDv2 |
| `2001:db8::/32` | 文档保留 |
| `2002::/16` | 弃用 |

### 4.2.4 IPv6多播地址

IPv6中只有多播以及任播（`Anycast`，传输到最近的1台设备），而没有广播。多播涵盖了广播的功能，**IPv6组播时需要使用组播MAC地址而不是广播MAC地址**

IPv6多播地址历史上经历过多次演变。定义如下，多播地址第一字节永远为`ff`

```
RFC4291

   |   8    |  4 |  4 |                  112 bits                   |
   +------ -+----+----+---------------------------------------------+
   |11111111|flgs|scop|                  group ID                   |
   +--------+----+----+---------------------------------------------+

Flags

   +-+-+-+-+
   |0|R|P|T|
   +-+-+-+-+
```

`flags`最高1位保留为`0`，后3位依次为`R P T`。其中`R`表示`Rendezvous`，Rendezvous Point字面意义**汇合点**简称`RP`，`R`为`1`时表示当前地址集成了`RP`地址（见下）；`P`表示`Prefix`，为`1`表示由`network prefix`定义多播地址（同样见下）；`T`表示`Transient(Non-permanent)`，为`1`时表示不是由国际组织分配的多播地址。`P`为`1`时`T`也一定为`1`（固定的多播地址可以由IANA分配）

`scope`表示多播组的规模，`group ID`指定了`scope`网络范围内的组ID。`scope`定义如下

```
0  reserved
1  Interface-Local scope
2  Link-Local scope
3  reserved
4  Admin-Local scope
5  Site-Local scope
6  (unassigned)
7  (unassigned)
8  Organization-Local scope
9  (unassigned)
A  (unassigned)
B  (unassigned)
C  (unassigned)
D  (unassigned)
E  Global scope
F  reserved
```

常用IPv6组播地址如下

```
ff02::1 本网络内所有设备（节点）
ff02::2 本网络内所有路由
ff02::1:ffXX:XXXX 本网络内被请求对象的组播地址
```

> 组播地址`ff02::1:ffXX:XXXX`中最后3字节（24bit）取当前端口IP的后24位
>
> 需要首先计算出组播IP地址才能确定组播MAC地址。组播MAC地址格式为`33:33:XX:XX:XX:XX`，后4字节和组播IP地址的后4字节相同

`RP`地址计算方法如下

```
   |   8    |  4 |  4 |  4 |  4 | 8  |       64       |    32    |
   +--------+----+----+----+----+----+----------------+----------+
   |11111111|flgs|scop|rsvd|RIID|plen| network prefix | group ID |
   +--------+----+----+----+----+----+----------------+----------+

RP address

   +------------+---------------------+----+
   | network pre| 0000000000000000000 |RIID|
   +------------+---------------------+----+
```

> 在`R`为`1`时`P`和`T`也需要为`1`（`0xff7x`）。`RP`地址通常是一个IPv6路由器的地址，这个路由器负责数据源发来的多播数据包的分流转发。例如距离网络电视服务器最近的路由器就需要具备这种功能，而途径的路由器也需要支持这些功能。`RP`地址的构建需要`plen` `network prefix` `RIID`共三个部分，其中`RIID`放在128位IPv6的最后表示`RP`的`interface`，而`plen`指定`network prefix`的长度，截取后放在最前面。`plen`不大于64

## 4.3 路由原理

路由器是第三层网络设备，它的本质就是一种只能理解到网络层的特殊的主机（现在的路由器也可以理解更高层）。它和主机的不同点是它通常至少拥有2个网络接口，需要连接到不同的网络进行网络之间的数据转发，而主机只需要1个接口连接到网络就可以（家用路由器通常集成交换机，引出多个LAN接口，通常只能算路由器的一个接口）。路由器连接不同网络的每一个端口都拥有独立的MAC地址，数据包通过路由器转发时需要更改MAC地址为路由器转发接口的MAC。防火墙可以算一种特殊的路由器，具备更多的安全功能

在[本章开头](#4-网络层)说过，如果没有NAT的特殊情况，数据包在不同网络之间，穿过路由器传输时**源IP和目标IP是不会改变的**，只有数据链路层的MAC地址会不断改变。网络中的主机会配置默认网关（路由器）IP，发送数据包时它会判断目标IP是否属于当前已经连接的网络，如果**属于已连接网络**只需设置好目标MAC地址后直接向网络中发送数据包；如果**不属于**已有网络，主机会将MAC地址设置为默认网关或对应路由器的MAC，将数据包发送给路由器转发处理

> 在日常生活中我们接触到的路由器通常都是属于**边界网关设备**。真正的核心路由器都由运营商管理，保存于运营商机房中，普通人难以接触。核心路由器需要搭载更多的功能，首先必须集成路由协议，这是大部分消费级设备所不具备的（所以严格意义上叫网关，不算真正的路由器）
>
> 目前全球有许多网络设备厂商，但是拥有核心路由产品的厂家只有Cisco思科，Juniper瞻博，Huawei华为，Nokia诺基亚，Ericsson爱立信，ZTE中兴等少数几家。高端核心路由的价格都在六位数，且体积巨大，可以占据一个机柜

### 4.3.1 路由表

每台主机都拥有一个路由配置表，如下示例（省略了部分列）

示例1

```
$ netstat -nrv
Kernel IP routing table
Destination     Gateway         Genmask         Iface
0.0.0.0         81.187.150.214  0.0.0.0
10.92.213.0     10.92.213.242   255.255.255.0   eth0
81.187.150.208  81.187.150.216  255.255.255.240 eth1
127.0.0.1       127.0.0.1       255.255.255.255 lo
```

> 上表中共出现了3台路由器。访问私有网络`10.92.213.0/24`中的设备时需要通过`eth0`访问。当前配置访问`10.92.213.0/24`以外的网络时通过路由器`81.187.150.214`，而该路由器位于`eth1`连接的网络`81.187.150.208/28`内。此时如果`10.92.213.0/24`内的路由器`10.92.213.242`可以访问其他网络，我们也可以将第一行路由器地址更改为`10.92.213.242`

示例2

```
$ netstat -nrv
Kernel IP routing table
Destination     Gateway         Genmask         Iface
0.0.0.0         172.22.0.1      0.0.0.0         eth0
172.22.0.0      0.0.0.0         255.255.0.0     eth0
```

> 上表表明主机通过`eth0`连接了一个私有网络（如果可以访问上一层网络，就是NAT网络）。访问`172.22.0.0/16`局域网内的设备时无需通过网关，直接ARP后发送数据包即可

路由器中的路由表结构和上述类似，区别是可能会有其他的一些相关信息。**动态路由**通过学习获得，而**静态路由**由人工配置

通常路由器的路由表都会包含有**目的网络地址**，**网络掩码**，**Metric**（路径长度），**Next hop**（下一跳路由器地址）。路由器会自动选择Metric最短的路径

路由表还会包含其他信息，如**Interface**（上例的`eth0`），**QoS Flags**（例如`U`表示路由有效，`G`表示该路由表项指向一个网关，`S`表示是通过`route`命令配置的静态路由表项），以及安全配置（常见于防火墙）等

在现代路由器中，路由表需要转换为更高效的Forwarding table才能应用

### 4.3.2 路由协议

常见的路由协议有`RIP`，`RIPv2`，`OSPF`，`IS-IS`等，路由器之间需要使用路由协议来**交换路由信息**。公网中的路由器都依赖路由协议来寻找路径

**RIP**

`RIPv2`协议于1994年发布，作为`RIPv1`的继任者，定义于RFC2453，更新于RFC4822。`RIP`（RFC1058）是应用层协议，走`UDP`，端口`520`。`RIP`的数据交换只发生在邻近路由器之间，是一种**距离矢量**类型的协议

`RIP`使用hops（跳转）作为metrics对路径长短进行评估，并包含在路由表中。路由器**每隔一段时间**（通常30秒，可能加上随机的正负offset）就会向邻近的路由器（adjacent）广播它的路由信息，邻近的路由器根据这些信息更新自己的路由信息。更新时会对metrics进行**累加操作**，如果发现同一目标IP对应的metrics变小了**说明有更优的路径**，路由器会使用对应的metrics以及网关地址替代原有的路由表项；如果发现**同一个相邻网关**发来的metrics变大了，那么就会将这个更大的metrics替换原来的metrics；此外每一个路由表项还有一个超时计时器，超过指定时间（180秒）未收到原有网关发来的更新，就认为已经失效，失效后再经过一段超时，此项就会被删除（后两种操作是面向网络故障而提出的应对方法，metrics既可以增也可以减）

> 路由表项的删除可能由超时或路由更新导致。旧的路由表项删除倒计时120秒，同时它的`metric`会被设为`16`，flag会对应表示该项已更改。之后会触发该路由器发送一次更新数据包
>
> `RIPv2`使用了`224.0.0.9`组播地址而不是`RIPv1`的`255.255.255.255`广播。此外`RIPv2`在路由信息中**包含了网络掩码**以支持`CIDR`，其路由表基于网络地址构建（也可以包含节点地址。`RIPv1`通常对每一个节点IP或网络建立一个路由表项，一个IP地址到来时选择其中最符合的），以及附加的Authentication
>
> `RIP`系列协议为限制收敛时间，最多支持15个跳转，这意味着它不能用于距离相隔过远的网络。`RIP`的设计也导致网络故障时容易产生路由数据泛滥，收敛（稳定）速度慢，且容易产生振荡
>
> `RIP`同时也提出了`Split Horizon`以及`Triggered updates`，在网络出现故障时有助于路由信息的收敛

`RIPv2`分享路由数据的格式如下。`command`为`1`表示路由信息请求（例如新路由器上线），`2`表示回复。`version`表示`RIP`版本，为`2`。`AFI`为`2`表示IPv4，`Next Hop`为下一跳网关地址（对接收方来说是向后2个网关的地址）。一个包可以包含`1`到`25`个入口，每个长`20`字节。`metric`有效值最大只能取`15`，`16`表示infinity

```
Header

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  command (1)  |  version (1)  |       must be zero (2)        |
   +---------------+---------------+-------------------------------+
   |                                                               |
   ~                         RIP Entry (20)                        ~
   |                                                               |
   +---------------+---------------+---------------+---------------+

Entry

    0                   1                   2                   3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Address Family Identifier (2) |        Route Tag (2)          |
   +-------------------------------+-------------------------------+
   |                         IP Address (4)                        |
   +---------------------------------------------------------------+
   |                         Subnet Mask (4)                       |
   +---------------------------------------------------------------+
   |                         Next Hop (4)                          |
   +---------------------------------------------------------------+
   |                         Metric (4)                            |
   +---------------------------------------------------------------+
```

**OSPF**

`OSPF`是一种**链路状态**类型的协议，全称`Open Shortest Path First`，同时支持IPv4和IPv6，支持`CIDR`，最初于1998年为IPv4设计（RFC2328），主要基于Dijikstra算法。由于`OSPF`~~可以单独写一篇长文章~~，这里不再讲解，有兴趣可以看相关文档

## 4.4 ARP协议

参考RFC826

`ARP`协议运行于IPv4同一层级，在IPv4 Ethernet网络中可以让一台设备获取IP对应的设备MAC地址。`ARP`数据包的`EtherType`为`0x0806`

`ARP`除了可以获取MAC地址以外，还可以用于检测网络内的IP地址冲突

`ARP`中**请求方**和**发送回复的被请求方**使用相同的数据包格式。设计最初还是考虑了其他协议的，除去以太网包装后`ARP`数据包的格式如下

| 名称 | 长度（Byte） | 注解 |
| :-: | :-: | :-: |
| `HTYPE` | `2` | 数据链路层协议，`1`代表`Ethernet` |
| `PTYPE` | `2` | 网络层协议，`0x0800`代表`IPv4`，定义和`EtherType`相同 |
| `HLEN` | `1` | 链路层协议地址（物理地址）长度（单位Byte）。`Ethernet`（MAC）地址长`6` |
| `PLEN` | `1` | 网络层协议地址长度（单位Byte）。`IPv4`地址长`4` |
| `OPER` | `2` | 操作类型，`1`表示Request，`2`表示Reply |
| `SHA` | `HLEN` | 发送方的物理地址（MAC地址） |
| `SPA` | `PLEN` | 发送方的网络地址（IPv4地址） |
| `THA` | `HLEN` | 目标的物理地址 |
| `TPA` | `PLEN` | 目标的网络地址 |

> 在IPv4网络中，每一台主机的内存里都会缓存有一张`ARP`表，用于记录IP地址和以台网MAC地址的对应关系。每次主机想要将数据发往**本地网络**的一个指定节点（包括默认网关），它就会在表中查询这个IP对应的MAC。查询到以后就会直接将这个数据包发往对应的目的MAC
>
> 如果没有查询到，主机会将以太网目的地址设置为广播地址`FF:FF:FF:FF:FF:FF`，这样本地网络（通过交换机互联）的所有设备都会接收到这个`ARP`数据包。发送时`ARP`数据包类型`OPER`为`1`请求，`SHA`为主机MAC，`SPA`为主机IP，`THA`全`FF`，`TPA`为目标主机的IP
>
> 本地网络中的其他主机接收到数据包以后，会依次检查`HTYPE` `PTYPE`，以及`TPA`。如果`TPA`符合，主机会将`SHA` `SPA`存入自己的`ARP`表中。如果确定`OPER`为`1`，那么主机会进行回应，发送一个`OPER`为`2`的数据包，同时将收发地址交换，将以太网数据包的目的MAC以及`SHA`更换为本机的MAC，送往原先的请求方

> `ARP`的实现较为简单，缺点是非常不安全，容易劫持

## 4.5 NDP协议

参考RFC4861

`NDP`协议用于IPv6网络，运行于IPv6更高一层级，包含了类似`ARP`的地址解析功能，但是走`ICMPv6`。`ICMPv6`通过IPv6数据包搭载，`Next Header`值为`58`

`NDP`定义了如下几个`ICMPv6`数据包。Solicitate就是Query的意思

| 名称 | ICMPv6 Type | 作用 |
| :-: | :-: | :-: |
| `RS` Router Solicitation | `133` | 主机请求本地网络中路由器信息 |
| `RA` Router Advertisement | `134` | 路由器在收到`RS`后，或每隔一段时间广播自己，表明存在，附带一些其他参数信息例如网络MTU |
| `NS` Neighbor Solicitation | `135` | 邻居请求，用于请求指定IPv6主机的MAC地址或验证其在线 |
| `NA` Neighbor Advertisement | `136` | 邻居广播，用于回复`NS`报文等用途 |
| `Redirect` | `137` | 重定向，路由器通知主机可以连接到另一个路由器，速度更快 |

> 以上报文通常需要搭配[多播IPv6](#424-ipv6多播地址)使用，`ff02::1`网络内所有节点，`ff02::2`网络内所有路由
>
> 除了MAC地址获取以及IP冲突检测外，`NDP`还可以寻找网络内路由，获取网络MTU、hop limit参数，地址分配获取（`SLAAC`，之后会讲解），重定向，可用性检测（reachability）功能等

`NDP`协议主要使用`NS`和`NA`报文来进行MAC地址的请求，地址冲突检测和可用性检测

`NS`和`NA`数据包格式分别如下

```
Neighbor Solicitation

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |          Checksum             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Reserved                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                       Target Address                          +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Options ...
   +-+-+-+-+-+-+-+-+-+-+-+-

Neighbor Advertisement

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |          Checksum             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|S|O|                     Reserved                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                       Target Address                          +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Options ...
   +-+-+-+-+-+-+-+-+-+-+-+-

Options (MAC)

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |    Length     |    Link-Layer Address ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

> `NS`报文的IPv6头中源地址通常为本机IP地址或`0:0:0:0:0:0:0:0`（如未分配地址），目的地址为多播/组播地址（如`ff02:1`）或直接就是目的IP地址（例如在检测对方可用性时）。而`NS`报文包含的目的地址是表示请求的IP地址，不能是多播地址或无效地址。`Code`为`0`。在多播报文中必须在`Options`包含发送方（本机）的MAC地址
>
> `NA`报文的IPv6头中源地址是本机IP地址，目的地址为原先请求方的IP地址或多播/组播地址（如请求方未分配地址）。`R`表示发送方是一台路由器，`S`表示是应请求发送的回复报文，而不是自主发送的报文（此时目标IP必须非多播，在可用性检测中有用），`O`表示覆盖原有的MAC地址缓存。通常`NA`回复报文包含的目的地址和原先对应的`NS`报文相同。`Code`为`0`。`Options`为本机的MAC地址，在多播报文中同样需要包含
>
> `Options`中`Type`为`1`表示源MAC（`NS`报文常用），为`2`表示目标MAC（`NA`报文常用）

> 主机请求指定IP的MAC地址时，主机首先需要发送一个组播ICMPv6 `NS`报文，这个`NS`报文使用组播目标MAC，IPv6头的源地址为本机IP，目标地址为被请求方的**组播IP地址**`ff02::1:ffXX:XXXX`。`NS`报文body的目标地址为被请求方的**单播IP地址**。并且在`NS`报文最后附上本机的MAC，`Type`为`1`
>
> 被请求方回复MAC地址请求时，发送一个`NA`报文，这个报文的源MAC和目标MAC分别为被请求方MAC以及请求方的MAC（非组播），源IP和目标IP同理。`NA`报文body的目标地址依然是自己的**单播IP地址**。在`NA`最后附上自己的MAC地址，`Type`为`2`

## 4.6 NAT

参考RFC1918

NAT全称`Network Address Translation`，由路由器实现，它可以使得私有网络内的多台主机共用一个公网IP地址，本质上是利用传输层的端口号（长16位）来弥补IPv4地址数量不足的问题。IPv4网络下我们日常用的局域网都使用了私有IP地址。同时NAT在某种程度上为IPv4私有网络提供了天生的安全保护。但是由于端口号的限制，一个NAT网络中同时访问同一公网主机的进程数量也有所限制。虽然应用广泛，事实上NAT打破了一些原有的设计规则，它并不被一些人看好

NAT网络需要路由器理解传输层端口。家用路由都是NAT路由器

在NAT网络中，访问当前私有网络以外网络的数据包会被直接发送往NAT路由。假设当前NAT路由的WAN口直接连接了公网并拥有公网IP（假设`194.47.156.230`）。我们访问一台公网主机产生一个数据包。那么在私有网络内，该数据包：

> 源IP为主机在私有网络内的IP（假设`192.168.1.23`），目标IP为被访问公网主机的IP（假设为`17.253.144.10`）（MAC的修改省略）
>
> 源Port为主机发送数据的传输层Port，目标Port为公网主机提供服务的Port（假设访问`http`，端口`80`，源端口`10320`）

NAT路由接收到上述数据包以后，进行以下操作后发送：

> 记录两个IP和端口（`192.168.1.23:10320, 17.253.144.10:80`）。将源IP修改为WAN口IP，再随机分配一个未使用过的上行端口（例如`12004`）。发送的数据包的源IP和Port变为`194.47.156.230:12004`，最终形成`192.168.1.23:10320 -> WAN Port 12004 -> 17.253.144.10:80`的映射

公网主机收到后回复一个数据包，路由器进行以下操作：

> 发现WAN端口`12004`收到了来自`17.253.144.10:80`的数据包。经过查表将目标IP和Port改为`192.168.1.23:10320`，发送给私有网络内的主机

NAT的应用场景不限于以上示例。Outbound NAT时，数据从私有网络发送往上层网络，不同的内网`host:port`访问相同的外网`host:port`，必须分配不同的WAN端口（如果访问不同外网`host:port`，可以分配相同WAN端口，但是没必要这么做。而相同内网`host:port`访问不同外网`host:port`，也可以分配相同的WAN端口）。Inbound NAT时，NAT路由直接查询之前的表格就可以确定内网的`host:port`


## 5 传输层

传输层协议提供了主机上进程之间的数据传输支持，以端口号`Port`作地址，以`TCP`、`UDP`为主导，`ICMP`用于网络控制管理等特殊功能。其他大部分传输层协议都是基于`TCP`或`UDP`设计而来的。对于应用层来说，`TCP`传送过来的数据是有序的，而`UDP`传送过来的数据可能是乱序的

## 5.1 TCP

### 5.1.1 TCP通信原理

`TCP`是一种可靠的传输层协议，基于滑动窗口设计，主要实现了数据传输的流控制，纠错，重传等。`TCP`有多种实现，且较为复杂。这里只对共通的基本原理进行讲解

**概览**

`TCP`是基于连接的有状态协议，需要使用状态机控制。在基于`TCP`的socket程序中，对于每一个`<src addr, src port, dest addr, dest port>`，OS都需要创建一个socket与之对应，这样两台主机间的一个连接使用**一对**专用的socket进行通信

> 为方便理解，之后会使用Wireshark对`TCP`数据流进行抓包[实验](#513-tcp实验)

**连接建立和释放**

`TCP`三次握手建立连接的过程如下

![](images/221112a006.png)

> 发起连接的客户端首先向被请求方（服务器）发送一个`TCP`数据包，其中`SYN`标记置位，`Seq`通常为`0`。被请求方收到后返回一个`SYN`和`ACK`置位的数据包，`Seq`通常为`0`，而`Ack`值为上一个数据包`Seq+1`，通常为`1`。发起连接一方接收到后再返回一个`ACK`置位的数据包，`Ack`值为上一个数据包`Seq+1`。此时连接建立，可以开始传输数据
>
> 这个过程可以描述为`SYN SYN-ACK ACK`
>
> 在连接建立时的SYN包中还会在`TCP Options`携带上一些配置信息，例如最大Segment大小MSS（Option `2`），允许SACK（Option `4`），Timestamp时间戳（Option `8`），Window Scaling系数（Option `3`）等

`TCP`四次挥手释放连接的过程如下

![](images/221112a007.png)

> 连接的终止通常由请求方（客户端）发起。首先发送一个FIN数据包，被请求方接收到以后返回一个ACK包，此时请求方不可再主动发送数据。之后由被请求方发送一个FIN数据包，请求方接收到后返回一个ACK包。此时连接释放
>
> 以上过程可以描述为`FIN ACK FIN ACK`。为节省数据包发送次数，被请求方通常会将中间两个数据包合并为1个。所谓的四次挥手变为三次，形成`FIN FIN-ACK ACK`

**滑动窗口原理**

![](images/221112a005.png)

数据包可能会在途中任意方向，任何时间，任何地点丢失，也经常会出现数据包乱序，`TCP`解决了这些问题。此外，`TCP`流水式的数据传输，数据包的批量ACK方式，避免了批量传输受往返延迟的影响

为区分发送的各个`TCP`数据包，`TCP`中每个数据包都拥有一个序号`Sequence Number`。发送方和接收方各有一个窗口（每个端口都对应有一对发送和接收窗口）。发送方的窗口只有在接收到当前窗口中**开头**数据包对应的ACK包之后才会向前移动，否则保持不动。而接收方的窗口每接收到一个数据包并回复一个ACK包，窗口就可以向前移动一格。也就是说，发送方的窗口开头位于当前最早的未被ACK的数据包，而接收方的窗口开头位于当前最早的**未接收到**的数据包

> 在`TCP`通信过程中，**发送方**和**接收方**分别使用`Seq`和`Ack`作为计数器，对传输的数据进行计数，双方数据包的`ACK`都置位。`TCP`连接建立后双方`Seq`和`Ack`初始值都为`1`
>
> 由于`TCP`是流水线协议，发送方有时会一次批量发送多个数据包。在**发送方**，每**下一个**数据包的`Seq'`的值为当前数据包的`Seq`加上当前`TCP`数据包的Payload长度`Len`，即`Seq' = Seq + Len`
>
> **接收方**对于每一个接收到的数据包都**必须**发送一个对应的ACK包，使得发送方知晓数据包已成功送达。每个ACK包的`Ack`值为对应`Seq`包的`Seq + Len`。也就是说，ACK包的`Ack`值对应下一个数据包的`Seq'`
>
> 数据传输过程中，发送方和接收方需要检查发来数据包的`Ack`和`Seq`，来判断传输过程出现的错误。这些情况会在下面进行讲解

**窗口大小和Window Scaling扩展**

> 每个`TCP`数据包都会包含一个2字节的`Window`域，用于表示**发送该数据包的主机目前接收窗口的大小**
>
> 如果不启用`TCP`的Window Scaling扩展，窗口默认最大65535字节。如果启用，在`TCP`建立连接的阶段，双方发送SYN包时可以使用专用的TCP Option（`3`）设置Window Scaling左移位数，最大值为`14`，窗口最大`65535 * 2^14`。Window Scaling要到连接建立以后才会生效，三次握手时的Scaling还是`1`

**数据传输：乱序、超时和丢包**

由于`IP`协议栈的特性，尽管路由器会尽力保持路径的一致性，数据包还是可能走不同的路径（例如负载均衡）。`TCP`本身基于滑动窗口的设计提供了**缓冲**的功能，所以数据包的**乱序**通常不会引发错误

> 数据包乱序表示先前未到达的数据包最终还是到达了。接收方接收到乱序数据包后续的一个数据包后，回复的ACK中`Ack`相较上一个ACK不变，这就是Dup ACK，此时发送方将丢失数据包之后的一个数据包标记为发送成功，发送窗口不移动。乱序的数据包到达后，接收方发现空缺已经补全，回复ACK时将`Ack`置为接下来期望数据包的`Seq`。发送方接收该ACK后也知晓数据已经补全，直接发送接下来的数据包
>
> 如果乱序的两个数据包是连续到来的，也是同上，接收方回复的两个ACK中第一个`Ack`设为迟到数据包的`Seq`，另一个`Ack`设为下一个期望数据包的`Seq`
>
> 用一句话概括，接收方的ACK回复中`Ack`值**为接收方期望接收到数据包的**`Seq`**最小序号**。对于发送方来说，数据包是否已成功传输，一切以接收方的回复为准

**丢包**是导致传输错误的最常见原因，在这些情况下`TCP`需要为其提供纠错和重传机制

> **丢包**可能在任何阶段发生。可以是发送方的数据包，也可以是接收方的ACK回复

> 发送方的数据包如果丢失，接收方通过将接收到数据包的`Seq`和上次发送ACK回复的`Ack`比对，就可以监测到（此时是无法判断数据包是丢失还是乱序，要将后续成功接收到的数据包放入到接收窗口，但是窗口不移动）。接收方发送ACK回复时会一直重复上一个`Ack`值（Dup ACK），这样发送方也会知晓丢包的情况
>
> 需要注意的是，在上述丢包后接收方发送的那些Dup ACK依然ACK了丢失数据包之后的数据包。此时发送方**不能移动发送窗口**，但是可以将之后的数据包标记为已发送成功。如果丢包未成功重传的情况下接收方发现再次发生了丢包，其发送的ACK依旧使用原来的`Ack`。直到原先丢失的包重传成功后，接收方首先回复该数据包对应的ACK；之后发送的Dup ACK对应下一个丢失的数据包的`Ack`值
>
> 这种情况下，通常在一定时间以后发送方会触发**快速重传**，通常在十几个Dup ACK以后（开启了SACK的非实时应用中也可能会立即重传）

> 接收方回复的ACK包一旦出现丢失情况，发送方的发送窗口就无法向前移动。发送方将会对窗口中未ACK的数据包设定一个定时器，超过一定时间还未收到也会对数据包进行重传，通常对应下面的**Spurious重传**

> 数据传输时使用的**超时时间**`RTO`是可变的，需要基于`RTT`（Round Trip Time，通常指发送端发送数据包到接收到ACK为止这段时间）来调整，计算方法在RFC6298
>
> 计算`RTO`需要用到两个数据，一个是`SRTT`（Smoothed RTT），一个是`RTTVAR`（RTT Variation）。`RTO`初始值为`1s`，最小值也不能低于`1s`
>
> 传输时，获取到第一个`RTT`后，设`SRTT = RTT, RTTVAR = RTT/2, RTO = SRTT + max(G, 4*RTTVAR)`
>
> 获取到后续`RTT`后，设`RTTVAR = (1 - b) * RTTVAR + b * abs(SRTT - RTT), SRTT = (1 - a) * SRTT + a * RTT`，再使用同样方法计算得到`RTO`。通常取`a = 0.125, b = 0.25`

**时间戳扩展Timestamp**

现在大部分的`TCP`通信默认都开启了时间戳功能来提高可靠性，每个数据包都会包含时间戳信息，方便RTT测量以及PAWS（Protection Against Wrapped Sequences，在超大带宽的网络中32位`Seq`可能不够用，在上一个`Seq = x`还在窗口中就传输了超过4GiB数据从而导致`Seq = x`在窗口中重复出现）

Timestamp Option长度10字节，通常`TCP`通信中如果建立连接时选择了Timestamp，那么之后每个数据包都会有Timestamp，格式如下

```
    +-------+-------+---------------------+---------------------+
    |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|
    +-------+-------+---------------------+---------------------+
        1       1              4                     4
```

> `TSval`表示发送该数据包一方的`TCP`时钟，该时钟相比数据包的传送速度慢许多。`TSecr`必须在`ACK`置位时才有效（`ACK`未置位必须置`TSecr = 0`），此时`TSecr`的值等于对方最近一个数据包的`TSval`时钟

**SACK扩展**

SACK即选择性ACK。SACK是为更高效地提供丢包信息而设计，尤其是接收方的ACK回复丢失时，可以减少多余的Spurious重传，这种重传下面会讲到。在实际应用中接收方默认几乎不会使用SACK。但是发送方通常需要支持SACK

注意SACK只是一个扩展，它只是附加的提示信息，没有对`TCP`通信的ACK回复进行本质的更改

SACK信息由`TCP`数据头中的可选的`SACK Option`搭载，格式如下

```
                      +--------+--------+
                      | Kind=5 | Length |
    +--------+--------+--------+--------+
    |      Left Edge of 1st Block       |
    +--------+--------+--------+--------+
    |      Right Edge of 1st Block      |
    +--------+--------+--------+--------+
    |                                   |
    /            . . .                  /
    |                                   |
    +--------+--------+--------+--------+
    |      Left Edge of nth Block       |
    +--------+--------+--------+--------+
    |      Right Edge of nth Block      |
    +--------+--------+--------+--------+
```

> SACK选项中每一个数据项由一对`Seq`构成，每个`Seq`长4字节，它们分别表示接收方已接收到数据包区间的左界和右界（注意一个数据包本身是一个`Seq`区间，例如`35650 36843` `36843 38126`合并为`35650 38126`）
>
> `TCP`规定`1st Block`必须是最近的一个Block（也就是导致接收方发送当前ACK的Block）。`TCP`要求尽量多地包含Block，其余较近的Block可以乱序，但是不要重叠，且建议依旧遵照由近及远排列
>
> 发送方的数据包丢包时，之后数据包中的`Ack`会小于最远区块的左边界，这表示第一个丢失数据包的`Seq`区间。之后丢包的`Seq`区间在`SACK Option`中体现

**接收窗口满和零窗口**

在Wireshark中，接收窗口满后会出现`[ TCP Window Full ]`的提示。这通常是丢包迟迟未进行重传导致的，此时接收方窗口无法再向前移动，而此时发送方发送的最后一个数据包会填满接收方窗口。接收方窗口满不会显式表示在`TCP`数据包中，而是需要发送方自行根据接收方的`Win`以及发送的数据进行推断

零窗口Zero Window由接收端主动发送一个`Win = 0`的ACK触发，此时发送端知晓接收端已经来不及处理数据，立即暂停发送数据包。之后由接收端再发送一个`Win`不为`0`的ACK触发恢复数据传输（Window Update窗口更新）

> 零窗口经常会在窗口满附近出现。有些协议栈可能难以捕捉到零窗口

**Spurious重传**

Spurious重传通常由ACK回复丢失引发，最终通过发送方定时器超时触发重传。结果就是接收方发现了重复的数据包

**快速重传**

快速重传由多个Dup ACK触发，此时是接收方未接收到发送方的数据包（通过`Seq`的连续性判断）。此时发送方发现Dup ACK后就会开始计时，超时后（通常为十几个Dup ACK以后）就会进行快速重传

**普通重传**

Wireshark定义快速重传中，上一个Dup ACK必须出现在20mS以内，且之前有至少3个对应的Dup ACK。由于不同`TCP`协议栈的实现也会有所不同，有时抓取到的快速重传数据包可能不满足Wireshark对于快速重传的判定要求，这些快速重传可能会显示为普通重传

普通重传还有可能在发送窗口满时触发（这种情况很少）。此时发送方不能再发送新数据，为继续传输数据只能将原先未ACK的数据包进行重传。此外还有更罕见的情况，可能由接收端自身问题接收数据包而没有发送ACK引发等

**窗口大小更新**

接收方可以在传输过程中更改接收窗口`Win`大小，通常情况下数据传输时接收窗口大小一直会随RTT变化（无论是否使能Window Scaling）。Wireshark中如果检测到当前`Win`和先前ACK的`Win`不等，且发送方的数据包发生了丢失（出现了Dup ACK），此时说明接收端有必要扩大接收窗口，Wireshark就判定`Window Update`

**TCP Keep-Alive**

Keep-Alive数据包常见于idle连接，此时没有正在接收的数据，也没有任何需要发送或未ACK的数据，且已经经过一段这样的空闲时间。双方需要确认连接是否还有效。这种数据包通常不搭载数据，且**最大特征**是`Seq`相比下一次传输时使用的`Seq`会减`1`

收到Keep-Alive的一端可以回复一个Keep-Alive ACK表明连接的有效，这个数据包通常紧随Keep-Alive数据包，且`Seq`和`Ack`都维持前后一致不变化

> `TCP`规定Keep-Alive的实现是可选的

**连接重置**

连接重置可以由发送方或接收方发起，此时`RST`置位。如果在发送`RST`后另一端发来了数据包，就需要再发送多个`RST`确保数据传输和连接的终止

**TCP状态机**

如下

```
                            +---------+ ---------\      active OPEN
                            |  CLOSED |            \    -----------
                            +---------+<---------\   \   create TCB
                              |     ^              \   \  snd SYN
                 passive OPEN |     |   CLOSE        \   \
                 ------------ |     | ----------       \   \
                  create TCB  |     | delete TCB         \   \
                              V     |                      \   \
          rcv RST (note 1)  +---------+            CLOSE    |    \
       -------------------->|  LISTEN |          ---------- |     |
      /                     +---------+          delete TCB |     |
     /           rcv SYN      |     |     SEND              |     |
    /           -----------   |     |    -------            |     V
+--------+      snd SYN,ACK  /       \   snd SYN          +--------+
|        |<-----------------           ------------------>|        |
|  SYN   |                    rcv SYN                     |  SYN   |
|  RCVD  |<-----------------------------------------------|  SENT  |
|        |                  snd SYN,ACK                   |        |
|        |------------------           -------------------|        |
+--------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +--------+
   |         --------------   |     |   -----------
   |                x         |     |     snd ACK
   |                          V     V
   |  CLOSE                 +---------+
   | -------                |  ESTAB  |
   | snd FIN                +---------+
   |                 CLOSE    |     |    rcv FIN
   V                -------   |     |    -------
+---------+         snd FIN  /       \   snd ACK         +---------+
|  FIN    |<----------------          ------------------>|  CLOSE  |
| WAIT-1  |------------------                            |   WAIT  |
+---------+          rcv FIN  \                          +---------+
  | rcv ACK of FIN   -------   |                          CLOSE  |
  | --------------   snd ACK   |                         ------- |
  V        x                   V                         snd FIN V
+---------+               +---------+                    +---------+
|FINWAIT-2|               | CLOSING |                    | LAST-ACK|
+---------+               +---------+                    +---------+
  |              rcv ACK of FIN |                 rcv ACK of FIN |
  |  rcv FIN     -------------- |    Timeout=2MSL -------------- |
  |  -------            x       V    ------------        x       V
   \ snd ACK              +---------+delete TCB          +---------+
     -------------------->|TIME-WAIT|------------------->| CLOSED  |
                          +---------+                    +---------+
```

### 5.1.2 TCP数据包

参考RFC9293

`TCP`数据包定义如下

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Source Port          |       Destination Port        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Sequence Number                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    Acknowledgment Number                      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Data |       |C|E|U|A|P|R|S|F|                               |
    | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
    |       |       |R|E|G|K|H|T|N|N|                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Checksum            |         Urgent Pointer        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           [Options]                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               :
    :                             Data                              :
    :                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

| 名称 | 长度（Byte） | 注解 |
| :-: | :-: | :-: |
| `Source Port` | `2` | 源端口 |
| `Destination Port` | `2` | 目标端口 |
| `Sequence Number` | `4` | 简称`seq`，数据域第1字节的序号（计数单位Byte）。如果`SYN`置位，该域表示初始序号`ISN`，数据域第1字节序号为`ISN+1` |
| `Acknowledgment Number` | `4` | 简称`ack`，接收方发送数据包时`ACK`置位，该域表示（接收方认为的）发送方此时期望的下一个`seq` |
| `Data Offset` |  | `TCP`头长度（单位4Byte），没有`Options`通常为`5`。也表明数据域起始位置 |
| `CWR` |  | `Congestion Window Reduced`，阻塞窗口减小 |
| `ECE` |  | `ECN-Echo` |
| `URG` |  | `Urgent`，`Urgent Pointer`域有效，已弃用 |
| `ACK` |  | `Acknowledgment`，`Acknowledgment Number`域有效 |
| `PSH` |  | `Push` |
| `RST` |  | `Reset`，连接重置 |
| `SYN` |  | `Synchronize`，`seq`计数器同步 |
| `FIN` |  | `Finish`，表示发送端没有数据传输了 |
| `Window` | `2` | 发送方的窗口大小（单位Byte） |
| `Checksum` | `2` | 校验码（计算时`Checksum`置`0`），计算方法同`IPv4`Header的校验码 |
| `Urgent Pointer` | `2` | `Urgent`数据的位置（相对于当前`seq`，指向`Urgent`数据之后的1字节），已弃用 |
| `Options` | `4` | 选项，可以是1Byte长度`Kind`，也可以是1Byte`Kind`加上1Byte`Length`加上后续Option数据 |
| `Data` |  | 数据 |

> `TCP`中`Checksum`校验码需要涵盖Pseudo-header，Header以及`Data`三个连续的部分。计算时Header中`Checksum`本身全置`0`，而`Pseudo-header`包含了网络层的一些信息，如下，其中`PTCL`表示`Protocol`，`IPv4`下为`4`。`IPv6`的`Pseudo-header`长`40`字节

```
IPv4 Pseudo-header

    +--------+--------+--------+--------+
    |           Source Address          |
    +--------+--------+--------+--------+
    |         Destination Address       |
    +--------+--------+--------+--------+
    |  zero  |  PTCL  |    TCP Length   |
    +--------+--------+--------+--------+

IPv6 Pseudo-header

    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                         Source Address                        +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                      Destination Address                      +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                   Upper-Layer Packet Length                   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                      zero                     |  Next Header  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

常用的`Options`如下

| Kind | Length | 注解 |
| :-: | :-: | :-: |
| `0` |  | End-of-Option，表示`Options`的结束 |
| `1` |  | No-Operation，有时作占位符使用，进行对齐 |
| `2` | `4` | Segment最大大小MSS，通常只在连接初始化时使用 |
| `3` | `3` | Window Scaling系数 |
| `4` | `2` | 允许SACK（Selective ACK） |
| `8` | `10` | Timestamps |

### 5.1.3 TCP实验

使用Wireshark进行抓包，更便于理解`TCP`的通信过程

> 注意事项：Wireshark虽然可以方便抓包分析，但是经过后续一些实际研究，发现Wireshark对于`TCP`事件的判断算法有较多设计不合理的地方，许多特定条件下容易导致事件的误判。建议理解`TCP`不要过于依赖Wireshark的提示信息

测试URL：

```
$ curl URL > /dev/null

IPv4 LAN address 10.80.193.210

[ Linux host 1 ] IPv4 45.76.35.230

http://tcpdynamics.uk:4000/8M

[ Linux host 2 ] IPv4 39.155.141.16

https://mirrors.bfsu.edu.cn/slackware/slackware-13.1/kernels/hugesmp.s/bzImage

[ FreeBSD host ] IPv4 213.138.116.73

http://pkg.freebsd.org/FreeBSD:13:aarch64/release_1/packagesite.txz
```

**连接建立和释放**

`[ FreeBSD host ]`连接建立，三次握手

![](images/221112a008.png)

> `[]`括号内表示该数据包中置位的标记位。点击本机发送的第一个SYN，可以观察到一些Options

![](images/221112a010.png)

> 本机支持`MSS = 1460`，使能SACK功能以及时间戳，启用Window Scaling，系数为`7`（左移`7`位）。此时`SYN`置位`ACK`不置位，`Seq`实际值`2675542447`（`TCP`使用这个值作为初值，当作`Seq = 0`看待。注意Wireshark显示的`Seq`和`Ack`都是**相对值**）。接下来观察服务器发送的`SYN-ACK`

![](images/221112a011.png)

> Options的顺序由所不同。此时`SYN`和`ACK`都置位，初始值`Seq = 0, Ack = 1`（这里`Ack`需要相对对方发来的`Seq`加`1`），服务器端Window Scaling系数为`11`。可以发现`TSecr`等于本机先前发送SYN的`TSval`

![](images/221112a012.png)

> 本机回复一个ACK数据包，Options只剩下Timestamp。此时`SYN`复位，`ACK`置位，`Seq = 1, Ack = 1`（`Seq`等于对方发来的`Ack`，`Ack`相对对方发来的`Seq`加`1`）

`[ FreeBSD host ]`连接释放，四次挥手

![](images/221112a009.png)

> 以上是最典型的`TCP`连接释放操作
>
> 服务器发来的HTTP OK数据包`Seq = 6395817, Len = 4331`。此时本机在ACK该最后一个数据包后才发送FIN
>
> 本机发送的第一个FIN中`FIN, ACK`置位，而`Ack`相比上一个ACK数据包不会变化，`Ack = 6400148`（这两个数据包中间没有任何来自服务器的数据）。
>
> 服务器发送的ACK回复中`Ack`等于接收到数据包的`Seq + 1`，值为`125`
>
> 下一步由服务器发送FIN，相比上一个服务器发送的ACK最大的区别是`FIN`置位
>
> 最后本机回复ACK，`Ack`同样需要`1`，连接断开
>
> 连接释放过程中数据包的Options没有特殊的注意点，和正常数据传输一样都只有Timestamp

`[ Linux host 1 ]`连接建立

![](images/221112a014.png)

> 过程和`[ FreeBSD host ]`同理

`[ Linux host 1 ]`连接释放

![](images/221112a015.png)

> 这里的连接释放和`[ FreeBSD host ]`有所不同，可以看到服务器端将ACK和FIN压缩为一个数据包，此时为三次挥手，`Ack`需要加`1`为`87`（相对值），最后本机回复的`Ack`同样加`1`

**正常数据传输**

`[ FreeBSD host ]`数据传输

![](images/221112a013.png)

> 正常的`TCP`数据传输中，发送方的`Seq`以及接收方的`Ack`应当都是单调增的。如上示例，发送方（服务器）发送了`Seq = 233129`和`Seq = 236025`（相对值）两个数据包，长度分别为`2896`和`13032`，接收方（本机）回复了`Ack = 236025 = 233129 + 2896`和`Ack = 249057 = 236025 + 13032`两个数据包分别作为上述两个数据包的ACK。之后的`Seq = 249057`同理
>
> 我们可以观察到接收方（本机）的接收窗口大小`Win`一直在变化（由RTT统计数据得来）
>
> `TCP`是流水线协议，接收方会在接收到数据后尽早ACK。以上抓包结果并不一定说明服务器的前2个数据包和后1个数据包是间隔发送的。`TCP`中发送方应当控制单位时间发送的数据量，尽量保证数据以最高效率传输

`[ Linux host 1 ]`数据传输，端口4000（Window Scaling & SACK Enabled, Packet loss set to 0%）

![](images/221112a016.png)

> 数据的传输也是同理。这里的区别是发送端经常会置位`PSH`。在`TCP`中，如果数据包的`PSH`置位，就表示发送方要求接收方在接收到数据包后，立即将数据递交给上层应用。这在发送端也表示数据包需要立即从发送缓冲区发出
>
> 传输是否使用`PSH`视情况而定。实时性要求较高的场合通常需要配置`PSH`置位

**数据包乱序**

`[ Linux host 1 ]`，端口4030（Window Scaling & SACK Disabled, Packet loss set to 0%）

![](images/221112a017.png)

> 在上述警告中，发送方连续发送了`Seq = 44644737 44647633 44649081 44650529`四个数据包，其中数据包`44649081`和`44647633`出现了倒序。相应的，接收方发送了四个ACK分别为`Ack = 44647633 44647633 44650529 44653425`，其中前两个ACK为Dup ACK

**丢包与快速重传**

`[ Linux host 1 ]`，端口4030（Window Scaling & SACK disabled, Packet loss set to 0%）

![](images/221112a018.png)

> 出现以上现象（许多个同`Ack`的Dup ACK）基本就表示出现了丢包。此时接收方也知道发现了丢包。超时后会进行如下所示的**快速重传**

![](images/221112a019.png)

> 通过计算我们可以得知之前丢失了大小为`4344`字节的数据。但是在重传中使用了3个`1448`字节的数据进行回复，这三个数据包分别为`Seq = 40625089, 40626537, 40627985`。而发送方在快速重传还未完成时就进行了之后新数据包的传输（`Seq = 40626537`之后的`40690249`）
>
> 这里的着色规律可能有点难以理解，只要记住之前提过的**原则**：接收方回复的ACK**永远只表现当前其期望的最小**`Seq`**数据包**（即便是陆续丢失了好几个不连续的包），而不必过度关心Wireshark的提示信息。事实上以上三个快速重传数据包都应当标记为`Fast Retransmission`，而由于Wireshark的标记算法问题有2个数据包被误标记为`Out-Of-Order`
>
> 尽管类似上面的丢包现象很多时候重传会只使用一个数据包，这个示例的情况在实际应用中也较为常见，需要注意甄别

> 以上丢包重传过程在打开Wireshark的`Statistics -> TCP Stream Graphs -> Time Sequence (tcptrace)`可以观察到如下现象

![](images/221112a020.png)

> tcptrace有三条线，蓝线为数据包的`Seq`，黄线为`Ack`，绿线是黄线加上`Win`的结果，绿线黄线之间的距离就表示当前**接收窗口的大小**。由于当前没有启用Window Scaling，并且传输的是单个大文件，显然接收窗口`Win`一直维持在最大值`65535`。这也从一定程度上说明64kB窗口是不太足够的

> 当黄线变水平就意味着丢包的发生，此时接收方回复的`Ack`不再增长
>
> 我们将后半部分放大看

![](images/221112a021.png)

> 上图是已经做好标记的重传过程。数字对应蓝色标记处数据包的`Seq`，粉色箭头表示数据传输的顺序，上方三个蓝色标记为正常传输的数据，下方三个蓝色标记是重传的数据包。蓝色圆圈内为丢包后继续传输的后续数据包

接下来我们可以观察一下启用了Window Scaling和SACK后的效果

`[ Linux host 1 ]`，端口4001（Window Scaling & SACK Enabled, Packet loss set to 5%）

> 启用Window Scaling后首先就是突破了`65535`字节的`Win`大小限制，其次启用SACK后可以使发送方对丢包情况有更多了解。首先我们在实际测试中就已经感觉到性能的大幅提升
>
> 以下为第一次出现丢包时的数据包和tcptrace图表

![](images/221112a022.png)

![](images/221112a023.png)

> 上图中标记粉色圈的位置就是发生第一次丢包的地方，可以发现蓝线段高度在此处不连续。此时`Ack`不再增长，但是`Win`还在增长（体现为`[ TCP Window Update ]`），接收方为后续数据包的到来提供足够的空间
>
> 同时我们观察到本机回复的ACK包大小从`66`字节变成了`78`字节。变大的ACK包意味着此时SACK开始发挥作用，上图中一条红色线段就是对应一个ACK数据包的SACK区间。我们可以对比一下前后的Options变化

![](images/221112a024.png)

> 变化后的Options，增加了12字节。`NOP`为数据对齐而存在

![](images/221112a025.png)

> 此时有SACK，同时发送方发送的是Dup ACK。但是同样由于Wireshark的事件判断算法问题，这些Dup ACK（`Ack = 28961`）数据包没有高亮（疑似和`[ TCP Window Update ]`判断冲突）
>
> 由于该`TCP`传输被配置为偏实时性任务，该丢失的数据包最终还是超时后通过**快速重传**传输成功，如果立即重传将会导致后面的数据滞后。在某些情况下（例如配置为低实时性任务），为保证更高的总体效率，该丢失的数据包可能会被立即重传（具体需要看该环境下`TCP`协议栈的实现和配置），而不是等到超时后快速重传

**超时重传**

最常见的超时重传在Wireshark中通常会显示为`Spurious Retransmission`。此时接收方接收到了数据包并回复了ACK，但ACK在途中丢失。超时计时由发送方触发，并进行重传。启用SACK后Spurious重传会大大减少

`[ Linux host 1 ]`，端口4031（Window Scaling & SACK Disabled, Packet loss set to 5%）

通过`Analyze -> Expert Information`，我们可以查找一些`Spurious Retransmission`数据包的`Seq`，并在过滤条件中添加该`Seq`（例如`tcp.seq == 76182`）

![](images/221112a027.png)

> 通过以上方法（`tcp.seq == 842737`），我们可以发现如上两个`Seq`相同的数据包。正常传输时是不会出现两个相同的数据包的。第一个数据包接收方确确实实收到了（否则Wireshark就捕捉不到它了）。这说明接收方没有接到对应ACK，最后超时进行了重传

**接收窗口满**

未启用Window Scaling时非常容易导致接收窗口满，启用后几乎不会出现窗口满的情况

`[ Linux host 1 ]`，端口4031（Window Scaling & SACK Disabled, Packet loss set to 5%）

![](images/221112a028.png)

![](images/221112a029.png)

> 如上。`[ TCP Window Full ]`出现的位置蓝线和绿线触碰，在本数据包传输完毕后接收方窗口就满了。发送方需要通过接收方的`Win`以及之前发送过的数据、接收到的ACK进行自动的计算，发现接收窗口满时暂时停止发送
>
> 有些`TCP`使能了Zero Window功能。在接收方发现数据快要满时，发送ACK，将`Win`置为`0`，强制发送方停止发送 

**连接复位**

`[ Linux host 2 ]`

接收方的连接复位可以在`curl`未完成时通过`Ctrl-C`触发。得到如下结果

![](images/221112a030.png)

类似的在`[ Linux host 1 ]`得到如下结果

![](images/221112a031.png)

> 可以观察到RST时，通常第一个RST维持了上一个ACK包的`Seq`和`Ack`值。后续的RST每接收到一个发送方的数据包就会回复一个，同时只有`RST`置位，`Win`和`Len`都为`0`
>
> `TCP`复位可以由应用触发。在网络极度不稳定时，`TCP`有时也会自动复位

**Keep-Alive**

高丢包率最终会导致双方之间数据包交换阻塞时间越来越长。在一段时间没有数据交换以后，可能出现Keep-Alive数据包。捕捉较耗费时间，不再测试

### 5.1.4 TCP附加说明

**窗口大小对传输距离的限制**

在没有启用`TCP`的Window Scaling扩展的情况下，数据通信双方的收发窗口大小最大为`65535`字节，这意味着必须将通信的RTT限制在一定范围内，否则非常容易导致瓶颈

> 假设我们使用速度为1000Mbps的以太网，中间没有任何路由或交换机带来的延时，只计算电信号传播（光速）带来的延迟。设接收方在接收到数据以后立即发送ACK。通过该网络发送完65535B数据需要`65535*8 / 1000M = 524.28us (RTT)`，也就是说第一个ACK回复需要在该RTT时间限制之内到达，否则窗口会满导致阻塞。假设电信号速度`3e8m/s`，为了避免瓶颈，那么双方之间最大的距离为`524.28us * 3e8m/s / 2 = 76.842km`
>
> 实际应用中路由以及交换等操作会引入比上述大的多的延迟，所以`65535`字节的窗口是远远不够的，只能启用Window Scaling扩展来规避瓶颈

## 5.2 UDP

### 5.2.1 UDP通信原理

相比于`TCP`，`UDP`要简单的多，它是一种无状态、不可靠的传输层协议，仅仅是网络层协议的简单包装。现在的实际应用中很少直接使用`UDP`，而是将`UDP`作为基础设施，再次包装以后使用，例如目前流行的传输层协议`QUIC`。直接利用`UDP`的典型应用层协议有`DNS`，`SNMP`等

由于`UDP`的特性，对于接收方来说`UDP`数据包是突然到来的，并没有建立连接与状态机的概念，系统也就没有必要为每一个`<src addr, src port, dest addr, dest port>`都创建一个socket。此时socket只以接收端地址`<dest addr, dest port>`区分。**发往同一主机同一端口的**`UDP`**数据包实际上在接收端由同一个socket接收**，而不是像`TCP`一样由OS的协议栈针对不同发送端地址创建多个socket分别接收

### 5.2.2 UDP数据包

参考RFC768

`UDP`数据包格式如下

```
     0      7 8     15 16    23 24    31
    +--------+--------+--------+--------+
    |     Source      |   Destination   |
    |      Port       |      Port       |
    +--------+--------+--------+--------+
    |                 |                 |
    |     Length      |    Checksum     |
    +--------+--------+--------+--------+
    |
    |          data octets ...
    +---------------- ...
```

> `UDP`数据包的数据头只有源端口，目标端口，长度（包含数据头长度）和校验码。计算16位校验码时使用和`TCP`相同的算法，需要包含如下所示的`UDP`伪数据头

```
     0      7 8     15 16    23 24    31
    +--------+--------+--------+--------+
    |          source address           |
    +--------+--------+--------+--------+
    |        destination address        |
    +--------+--------+--------+--------+
    |  zero  |protocol|   UDP length    |
    +--------+--------+--------+--------+
```

## 5.3 ICMP

参考RFC792

`ICMP`通过`IPv4`数据包搭载，主要用于`IPv4`网络中的一些特殊的控制和管理用途。我们日常使用的`ping`和`tracepath`都使用到了`ICMP`

`IPv4`中`ICMP`数据包的`Protocol`类型为`1`，源地址为生成该`ICMP`数据包的路由器或主机

### 5.3.1 目标不可达

`Destination Unreachable`格式如下，`Type`为`3`

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                             unused                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Internet Header + 64 bits of Original Data Datagram      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

> 计算`Checksum`时数据从`Type`开始算，校验算法和`IP`相同。最后的`Internet Header`是触发该`ICMP`数据包的原数据包`IPv4`数据头，后接该`IPv4`数据包的开头`64`字节数据

常见的`Code`定义如下

| `Code` | 作用 | 发送方 |
| :-: | :-: | :-: |
| `0` | `net unreachable`，网络不可达 | 通常为路由 |
| `1` | `host unreachable`，主机不可达 | 通常为路由 |
| `2` | `protocol unreachable`，协议未启用 | 通常为主机 |
| `3` | `port unreachable`，端口未启用 | 通常为主机 |
| `4` | `fragmentation needed and DF set` |  |
| `5` | `source route failed`，源路由失效 | 通常为路由 |

### 5.3.2 超时

`Time Exceeded`格式和目标不可达相同，`Type`为`11`。`traceroute`就使用了`TTL Exceeded`功能来追踪路径

常见的`Code`定义如下

| `Code` | 作用 | 发送方 |
| :-: | :-: | :-: |
| `0` | `time to live exceeded in transit`，TTL超时（降为0） | 通常为路由 |
| `1` | `fragment reassembly time exceeded` |  |

### 5.3.3 参数错误

`Parameter Problem`格式如下，`Type`为`12`。常见的`Code`为`0`

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Pointer    |                   unused                      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Internet Header + 64 bits of Original Data Datagram      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

> `Pointer`表示`IPv4`数据头中出现问题的地方。如果对方（可能是主机或路由器）无法依照`IPv4`数据头中的参数处理该数据包，就会接收到这样的错误

### 5.3.4 重定向

`Redirect`格式如下，`Type`为`5`

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                 Gateway Internet Address                      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Internet Header + 64 bits of Original Data Datagram      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

> `Gateway Internet Address`指示主机**更改路由表**将数据发往该路由。这通常是因为主机和该指定路由在同一子网下，具备更短路径

常见的`Code`定义如下

| `Code` | 作用 | 发送方 |
| :-: | :-: | :-: |
| `0` | `Redirect datagrams for the Network`，发往该网络的数据包都重定向 | 路由 |
| `1` | `Redirect datagrams for the Host`，发往该主机的数据包都重定向 | 路由 |
| `2` | `Redirect datagrams for the Type of Service and Network` | 路由 |
| `3` | `Redirect datagrams for the Type of Service and Host` | 路由 |

### 5.3.5 Echo和回复

`Echo or Echo Reply`格式如下，`Type`为`0`表示`echo reply`，`8`表示`echo`，`Code`为`0`。`ping`使用了该功能

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Identifier          |        Sequence Number        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Data ...
    +-+-+-+-+-
```

> `Identifier`用于区分多个`ping`（通常从`0`开始分配，用户执行一次`ping`命令就会加`1`）。`Sequence Number`作用和`TCP`的类似，每次加`1`，用于匹配一对`Echo`和`Echo reply`（和`TCP`不同点是一对`Echo`和`Echo reply`的`Sequence Number`是相同的）。`Data`开头通常有`8`字节的时间戳，后接长度`48`字节的任意数据，但是一对`Echo`和`Echo reply`搭载的数据需要相同
>
> 可以向路由器或主机发送`Echo`并获取回复

### 5.3.6 时间戳

`Timestamp or Timestamp Reply`用于时间同步（大部分应用已经被`NTP`等取代），格式如下，`Type`为`13`表示`timestamp`，`14`表示`timestamp reply`，`Code`为`0`

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |      Code     |          Checksum             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Identifier          |        Sequence Number        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Originate Timestamp                                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Receive Timestamp                                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Transmit Timestamp                                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

> `Identifier`和`Sequence Number`作用和`Echo`类似。请求方发送数据包时将`Originate Timestamp`设置为最后一次touch数据包的时刻（自UT Midnight开始算，单位ms），其余设置为`0`。接收方回复时`Originate Timestamp`不变，`Receive Timestamp`为接收方第一次touch到数据包的时刻，`Transmit Timestamp`为接收方发送前最后一次touch数据包的时刻

## 5.4 ICMPv6

`ICMPv6`用于`IPv6`网络

### 5.4.1 目标不可达

`Destination Unreachable`格式如下，`Type`为`1`

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                             Unused                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    As much of invoking packet                 |
    +                as possible without the ICMPv6 packet          +
    |                exceeding the minimum IPv6 MTU [IPv6]          |
```

> 最后需要尽量多的包含触发该`ICMPv6`的源数据包内容

常见`Code`定义如下

| `Code` | 作用 |
| :-: | :-: |
| `0` | `No route to destination`，路由表内没有合适的网关，通常产生于未配置默认网关的路由/主机 |
| `1` | `Communication with destination administratively prohibited`，访问禁止，通常产生于防火墙等 |
| `2` | `Beyond scope of source address`，超出源地址域，例如源地址是一个IPv6 [Link-local](#423-保留地址)，而目标地址是一个广域网地址 |
| `3` | `Address unreachable`，如果其他情况都不匹配，默认的`Code`值 |
| `4` | `Port unreachable`，端口无效（例如未在监听），通常由目标地址主机回复 |
| `5` | `Source address failed ingress/egress policy`，该源地址数据包被禁止 |
| `6` | `Reject route to destination`，路由禁止访问特定地址 |

### 5.4.2 超时

`Time Exceeded`格式和目标不可达相同，`Type`为`3`

> `Code`定义和`ICMPv4`相同，为`0`表示超过`Hop limit`（`TTL`）

### 5.4.3 数据包过大

`Packet Too Big`格式如下，`Type`为`2`

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                             MTU                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    As much of invoking packet                 |
    +               as possible without the ICMPv6 packet           +
    |               exceeding the minimum IPv6 MTU [IPv6]           |
```

> `MTU`为下一跳的`MTU`。该数据包通常由路由器发送，告知来方下一跳的`MTU`不足以使得该数据包通过

### 5.4.4 参数错误

`Parameter Problem`格式如下，`Type`为`4`

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Pointer                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    As much of invoking packet                 |
    +               as possible without the ICMPv6 packet           +
    |               exceeding the minimum IPv6 MTU [IPv6]           |
```

> `Pointer`指向引发问题的字节

常见`Code`定义如下

| `Code` | 作用 |
| :-: | :-: |
| `0` | `Erroneous header field encountered`， |
| `1` | `Unrecognized Next Header type encountered`，`Next Header`类型问题 |
| `2` | `Unrecognized IPv6 option encountered`，`Option`问题 |

### 5.4.5 Echo和回复

`Echo Request`和`Echo Reply`格式如下，`Type`为`128`表示`Echo Request`，`129`表示`Echo Reply`

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Identifier          |        Sequence Number        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Data ...
    +-+-+-+-+-
```

> 在多播的情况下，每一个符合多播地址的主机都应该以自己的单播地址进行回复

### 5.4.6 NDP

`NDP`也属于`ICMPv6`一部分

见[NDP](#45-ndp协议)

## 5.5 TLS

参考RFC5246 RFC8446

其他参考文章

https://www.cnblogs.com/xiaxveliang/p/13183175.html

> RFC文档对于`TLS`的描述不适合初学，建议先参考其他资源
>
> 先看[OpenSSL](#556-附加说明openssl)对证书有一个基本的了解

`TLS`全称`Transport Layer Security`，工作建立于已有的传输层协议以上，对传输的数据进行加密，为网络数据传输提供**安全**保护和**可信**保障

`TLS`由网景开发的`SSL`演变而来，经历了`1.0 1.1 1.2`到最新的`1.3`版本的进化。其中版本`1.0`（`SSL 3.1`）和`1.1`在2021年的RFC8996中已经正式淘汰，本文不再讲述。目前大部分网站使用`1.2`（2008）或`1.3`（2018），并且在不断向`1.3`迁移。`TLS`不仅用于`HTTPS`，它同样可以用于其他加密通信，例如`tor`

旧有的加解密、哈希算法正在不断被破解并被安全性更高的新方法替代，所以`TLS`的发展相比其他基础协议是相当快的

本文基于`TLS 1.2`进行讲解

> 额外阅读：[扩展欧几里德算法](https://oi-wiki.org/math/number-theory/gcd/#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)

### 5.5.1 TLS基本概念

`TLS`基于`TCP`运行，具备两种基本功能：一个功能是验证通信时对方身份是否合法（是否是我们期望的站点，数据包是否经过中间人篡改），另一个功能是对通信数据进行加密。由于非对称加密相比对称加密耗费资源更多，所以我们使用非对称加密协商数据传输时的对称密钥，来实现安全的数据传输

`TLS`中基本的数据传输协议是`TLS record protocol`记录协议，它会接收数据并分块，可能会对数据进行压缩，签名，加密，然后发送数据；而接收端会进行相反的操作，对数据进行解密，验证，解压缩等操作，并将完整的数据递交给应用层

`TLS`记录协议分为**四大类型**，分别为`handshake`，`alert`，`change cipher spec`以及`application data`

记录协议格式如下

```
struct {
    uint8 major;
    uint8 minor;
} ProtocolVersion;

enum {
    change_cipher_spec(20), alert(21), handshake(22),
    application_data(23), (255)
} ContentType;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    opaque fragment[TLSPlaintext.length];
} TLSPlaintext;
```

> `TLS`中的MAC是`Message Authentication Code`的缩写，它用于验证数据发送方是否为我们期望的发送方，以及数据的完整性（是否被更改）

### 5.5.2 TLS handshake

`TLS`握手是我们最为感兴趣的一个步骤，它最后会建立一个会话。一个会话的**环境**通常包含以下要素

> `session identifier`，会话ID，由服务器选定，用于标记一个active或resumable的会话
>
> `peer certificate`，证书
>
> `compression method`，加密前的压缩算法
>
> `cipher spec`，包含了生成密钥的伪随机算法（PRF），数据的对称加密算法（例如`AES`等），以及MAC算法（例如`HMAC-SHA1`）等
>
> `master secret`，客户端和服务端共享的机密，通常是对称密钥等
>
> `is resumable`，表示当前会话是否可以初始化新连接

**握手步骤示意图**

RFC5246的描述如下所示，其中带`*`的是可选的信息。一个箭头代表一次数据传输，而一次传输视`TCP`分包情况可以分为多个`TCP`数据包传输

```
      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Figure 1.  Message flow for a full handshake
```

**密钥协商算法**

`TLS`有多种密钥协商算法，例如`RSA`（非对称加密），`ECDH`（`Elliptic Curve Diffie-Hellman`，椭圆曲线DH），使用不同算法时的握手步骤也是不同的。但是这些算法最终的目的都是获取一个服务器和客户端公认的**对称加密**密钥

基于`RSA`的交换算法过程如下

> 1. 客户端发送`ClientHello`，其中包含会话ID，客户端支持的`TLS`版本，加密压缩算法套件，以及一个随机数`Rc`（明文）
>
> 2. 服务器回复`ServerHello`，其中包含会话ID，服务器选择的加密压缩套件，以及另一个随机数`Rs`（明文）
>
> 3. 服务器回复其站点证书`Certificate`
>
> 4. 服务器发送`ServerHelloDone`，客户端接收到以后进行签名的验证，以确认服务器的身份，同时知晓了服务器公钥（明文）
>
> 5. 客户端随机生成一个**预备对称密钥**（`Premaster Secret`，指`Premaster Key`），并使用服务器的公钥进行加密，发送给服务器。服务器接收到以后使用自己的私钥对其进行解密
>
> 6. 此时双方根据之前交换的随机数`Rc`和`Rs`以及预备密钥，使用伪随机函数`PRF`各自计算出**主密钥**，再使用同样的方法使用主密钥计算出最终的**会话密钥**`Session Key`（结果应当相同）。该密钥用于正式的数据交换
>
> 7. 客户端发送经过`Session Key`加密的`ChangeCipherSpec`（通知服务器之后都使用当前选定的算法套件和密钥）和`Finished`信息，服务器回复`ChangeCipherSpec`和`Finished`信息
>
> 8. 加密数据流传输开始

> `RSA`基于大数设计，该大数通常只有两个很大的因数，这两个因数都为素数。通常基于这三个数字先选取公钥再计算得到私钥

基于`ECDH`的交换算法过程如下

> 1. 客户端发送`ClientHello`，其中包含会话ID，客户端支持的`TLS`版本，加密压缩算法套件，以及一个随机数`Rc`（明文）
>
> 2. 服务器端回复`ServerHello`，其中包含会话ID，服务器选择的加密压缩套件，另一个随机数`Rs`（明文）
>
> 3. 服务器回复其站点证书`Certificate`。外加`ServerKeyExchange`，其中包含一个随机生成的**临时公钥**，`ECDH`算法的各项参数（明文），以及这些参数的签名（使用之前的随机数进行对参数哈希）
>
> 4. 服务器发送`ServerHelloDone`，客户端开始验证服务器身份，同时验证`DH`参数的签名，并获取临时公钥和`DH`参数
>
> 5. 客户端发送`ClientKeyExchange`，其中同样包含了另一个**临时公钥**（明文，且没有`DH`参数。`DH`以服务器参数为准）
>
> 6. 双方根据约定的`DH`参数各自在本地计算出**预备对称密钥**（结果应当相同）
>
> 7. 同上，使用`Rc` `Rs`和预备对称密钥经过两次计算得出最终的**会话密钥**
>
> 8. 同上，双方交换`ChangeCipherSpec`并各发送`Finished`

> `ECDH`的方案相当于在`RSA`的基础上又添加了一层密钥

`ECDH`的非对称原理（RFC6090）

> `ECDH`是两种算法，是椭圆曲线和`Diffie-Hellman`交换算法的结合
>
> 椭圆曲线算法基于`y^2 = x^3 + ax + b`形式的椭圆曲线（形状类似于横放的章鱼，关于x轴对称，如下图。实际可能使用其他函数），在其上取一个公认的点`G`作切线交曲线于另一点`G1'`，`G1'`关于x轴的对称点为`G1`，我们定义运算`1*G=G1`，那么`n*G=Gn`。假设给一个`G`以及一个`Gn`，我们很难计算出到底经过了多少次运算`n`
>
> 经典示例：假设Alice和Bob公认一个曲线上的点`G`，Alice有一个私有密钥`a`，Bob有`b`。此时Alice使用自己的密钥计算`a*G`并发送给Bob，Bob同样回复一个`b*G`。之后Alice可以计算`a*b*G`，Bob可以计算`b*a*G`，最终得到的结果是相同的。这个相同的结果就可以作为对称加密密钥使用

![](images/221112a032.png)

> `Diffie-Hellman`算法的基本思想是给定Alice的密钥`a`，Bob的密钥`b`，以及一个公认的参数`F`和配套的转换算法`e`，双方交换`a' = e(a,F)` `b' = e(b,F)`。双方最终可以在本地通过计算`d(b,a',F)`和`d(a,b',F)`得到相同的结果，作为对称加密密钥。上述椭圆曲线算法正好符合这种性质，并且远比`RSA`难破解

通过以上介绍，我们可以发现两者最大的区别在于**预备密钥**的生成方法。`RSA`的预备密钥在客户端随机生成，并且需要在加密后直接通过网络传输。而`ECDH`方案的预备密钥由双方自行计算得出，无需通过网络传输，这是`ECDH`的优势之一

此外，`ECDH`相比`RSA`还具备**前向安全性**。`RSA`中预备密钥仅仅由服务器内SSL证书的公钥加密，一旦某一天服务器的私钥泄漏（暴力计算通常较为耗时，更多的是通过一些手段直接获取），客户端之前发送的所有**预备密钥**都将暴露，从而使得所有会话中传输过的数据都暴露。`ECDH`每个会话都会使用临时密钥，即便服务器的私钥泄漏，也只能暴露客户端的临时公钥，不会影响其他传输过的数据（同时直接获取私钥也几乎不可能）

> 在最新的`TLS 1.3`中已经废弃了`RSA`交换算法
>
> `TLS 1.3`为了提高效率，也可能直接复用之前使用过的对称密钥（需要通过一些算法进行变换，得到预共享密钥`PSK`，牺牲一定安全性）。这种方法称为`0-RTT`（即无需协商），此时`ClientHello`会表明这种复用情况并直接传输加密后的数据

**Wireshark抓包实验**

![](images/221112a038.png)

> `TCP`连接建立以后就立刻开始了`TLS`握手，客户端发送`Client Hello`，如下

![](images/221112a039.png)

> 服务器回复的`Server Hello`格式如下，其中约定了使用的算法等各项基本参数

![](images/221112a040.png)

> 服务器同时发送了证书`Certificate`，`Server Key Exchange`，以及`Server Hello Done`

![](images/221112a041.png)

> 客户端发送的`Client Key Exchange`，以及随后的`Change Cipher Spec`。最后的`Finished`是第一条加密信息。服务器的回复略

![](images/221112a042.png)

### 5.5.3 TLS data

握手后所有的数据都通过会话密钥加密。每个数据包都会包含`TLS`版本

**Wireshark抓包**

![](images/221112a043.png)

### 5.5.4 TLS alert

`Alert`用于交换一些错误信息，其本身也会被加密，在连接过程中出现错误时会发挥作用，分为`warning`和`fatal`，其中`fatal`会直接关闭连接。格式如下

```
enum { warning(1), fatal(2), (255) } AlertLevel;

enum {
    close_notify(0),
    unexpected_message(10),
    bad_record_mac(20),
    decryption_failed_RESERVED(21),
    record_overflow(22),
    decompression_failure(30),
    handshake_failure(40),
    no_certificate_RESERVED(41),
    bad_certificate(42),
    unsupported_certificate(43),
    certificate_revoked(44),
    certificate_expired(45),
    certificate_unknown(46),
    illegal_parameter(47),
    unknown_ca(48),
    access_denied(49),
    decode_error(50),
    decrypt_error(51),
    export_restriction_RESERVED(60),
    protocol_version(70),
    insufficient_security(71),
    internal_error(80),
    user_canceled(90),
    no_renegotiation(100),
    unsupported_extension(110),
    (255)
} AlertDescription;

struct {
    AlertLevel level;
    AlertDescription description;
} Alert;
```

**Closure Alerts**

通常`TLS`数据传输以后也需要使用`Alert`关闭连接，如下

![](images/221112a044.png)

**Error Alerts**

如下

```
unexpected_message              fatal
bad_record_mac                  fatal
decryption_failed_RESERVED      not used
record_overflow                 fatal
decompression_failure           fatal
handshake_failure               fatal
no_certificate_RESERVED         not used
bad_certificate                 
unsupported_certificate
certificate_revoked
certificate_expired
certificate_unknown
illegal_parameter               fatal
unknown_ca                      fatal
access_denied                   fatal
decode_error                    fatal
decrypt_error                   fatal
export_restriction_RESERVED     not used
protocol_version                fatal (version not supported)
insufficient_security           fatal (more secure cipher required)
internal_error                  fatal (buggy implementation)
user_canceled                   warning
no_renegotiation                warning
unsupported_extension           fatal
```

### 5.5.5 TLS change cipher spec

`Change Cipher Spec`格式如下

```
struct {
    enum { change_cipher_spec(1), (255) } type;
} ChangeCipherSpec;
```

> `Change Cipher Spec`通常出现在重新协商密钥以及加密套件之后。在协商的过程中依然使用了旧的加密套件和密钥，而通信双方交换`Change Cipher Spec`之后的信息需要使用新的加密套件和密钥

### 5.5.6 附加说明：OpenSSL

**OpenSSL的证书原理**

`pem`格式文件定义见RFC7468，证书格式见RFC5280 Section 4

我们可以总结如下（可以先看后面的实验）：

> SSL生成的密钥文件中包含了公钥和私钥。公钥需要从该文件提取
>
> SSL证书格式为`x509`，主要分为CA根证书，CA次级证书，以及普通证书。所有这些证书构成一个证书依赖树，树的根节点就是CA根证书，而叶子节点为普通证书。其余节点都为CA次级证书。通常每一个证书都有且只有一个签发方`Issuer`和一个持有方`Subject`，签发方和持有方使用DN名称作为唯一标识（`Distinguished Name`）。证书依赖链也是基于DN进行匹配连接
>
> CA根证书是最权威的证书。根证书是自签名的，它的`Issuer`和`Subject`都是持有方本身。CA根证书可以用于签署其他的CA次级证书或普通证书，而为了规避风险很少会直接签署普通证书，普通证书通常由CA次级证书签署。客户端（如浏览器）会事先安装一些可信的CA根证书，通过`https`访问一个网站时会获取这个网站的证书以及额外的次级证书。客户端如果通过解析最终无法追踪到本地已安装的根证书，就代表网站证书不合法
>
> CA次级证书不可以自签名，它的`Issuer`可以是CA根证书或其他CA次级证书持有方。CA次级证书同样可以签署其他的CA次级证书或普通证书。**客户端和服务器通常没有CA次级证书，客户端需要根据当前证书的提示到相应URI获取**
>
> 普通证书同样不可以自签名，它的`Issuer`只能是CA证书持有方。它不能用于签署其他证书。这是我们通过`https`访问网站时网站发送给我们的证书

```
            -- Certificate --
tbsCertificate
    version
    serialNumber
    signature (Identical to signatureAlgorithm below)
    issuer
    validity
        notBefore
        notAfter
    subject
    subjectPublicKeyInfo
        algorithm
        subjectPublicKey
    issuerUniqueID (optional)
    subjectUniqueID (optional)
    extensions (optional)
signatureAlgorithm
signatureValue
```

> 证书的层次结构如上。一张证书包含了证书签发方的签名算法，以及计算得到的签名，外加其他被签名的内容（RFC5280称为`TBSCertificate`，`TBS means To-Be-Signed`）**三大部分**
>
> `tbsCertificate`包含了一些**明文**信息。包括`x509`版本（`v3`对应`2`），CA给该证书分配的序列号（最多`20`字节），签名算法，签发方名称，有效期，持有方名称，以及持有方的公钥，公钥对应的非对称算法
>
> 签发方和持有方名称通常包含国家，省/州/郡，单位，DN，CN（`Common Name`）以及身份序列号，还可以加上域名

> 由此，证书链都是层层签发，反过来也是层层校验
>
> 证书签发时，CA首先生成非对称密钥，用于根证书并自签名。根证书中包含公钥，以及使用对应私钥对`tbs`哈希值进行加密得到的签名
>
> CA再重新生成非对称密钥，用于生成CA次级证书的CSR（`Certificate Signing Request`，使用`pkcs`格式而非`x509`），该CSR包含了新密钥的公钥，以及使用新密钥私钥生成的`tbs`签名。使用根证书签名时签发方首先会通过CSR给定公钥解密验证CSR签名，之后填写`Issuer`等信息，重新计算`tbs`哈希，并使用根证书私钥签名，生成次级证书（`x509`格式，注意此时`tbs`内公钥依旧是新密钥的公钥）
>
> 站点生成自己的非对称密钥并提交CSR给CA签名。同样CA首先使用CSR中站点的公钥验证CSR签名，之后进行`Issuer`等信息的填充（此时填充的是CA次级证书对应的信息，**同时需要包含获取次级证书的URI**），最后重新算哈希并使用次级证书公钥签名，生成证书返还站点

> 证书校验时，客户端预先安装了根证书。客户端首先获取了站点的证书，发现次级公钥需要从指定远程URI获取。客户端首先获取次级证书并提取公钥，对站点的证书进行解密验证。之后客户端依据次级证书的`Issuer`提示在本地找到了根证书，并提取公钥对次级证书签名进行了校验。此时校验成功，站点证明了合法身份

> 此外CA还有吊销次级证书的操作（例如私钥泄漏等原因）。这样的操作通常使用`CRL`或`OCSP`实现，CA会在次级证书中包含证书吊销列表`CRL`的请求链接以供查验

**生成RSA密钥**

随着量子计算的发展，RSA将会淘汰

首先生成RSA密钥，输出格式为`pem`，我们习惯使用`.key`后缀。不加长度默认`2048`bit（建议可以`4096`bit）

```shell
openssl genrsa -out prv.key 2048
cat prv.key
```

得到如下格式的密钥（**虽然表示为私钥，其实包含了公钥**。需要提取）

```
-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----
```

通过如下命令查看密钥的私钥以及各项参数

```
openssl rsa -text -noout -in prv.key
```

可以如下方式生成公钥

```
openssl rsa -in prv.key -pubout -out pub.key
cat pub.key
```

输出

```
-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----
```

**为密钥生成自签名根证书**

实际应用中我们通常需要将我们的CSR发给CA进行签名，而不是自签名。但是我们可以在本地安装我们自签名的根证书，使应用信任我们的站点

证书为`x509`（也是`pem`的一种）格式，习惯使用`.crt`后缀，可以指定证书有效期。之后会提示输入你的具体地址，名称和邮箱等。实际应用通常需要指定证书对应的域名，该证书只对该域名有效

```
openssl req -x509 -key prv.key -out prv.crt -days 16 -subj "/CN=domain.com"
cat prv.crt
```

如果已经有密钥和对应的CSR，那么操作如下

```
openssl x509 -req -in prv.csr -signkey prv.key -out prv.crt -days 16 -subj "/CN=domain.com"
cat prv.crt
```

输出

```
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
```

可以通过以下命令查看根证书具体的信息，之前填写的地址，名称，邮箱都可以直接解码出来，也会显示证书的公钥和签名信息

```
openssl x509 -noout -text -in prv.crt
```

输出，我们可以发现该证书为可以签署其他证书的CA证书（`x509`扩展域指出该证书为`CA:TRUE`）。同时`Issuer`和`Subject`完全相同，这证实了该证书为根证书

```
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            ...
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = XX, ST = XX, L = XX, O = XXX, OU = XX, CN = XXXXX, emailAddress = xxx@xxx.com
        Validity
            Not Before: Jan  X 01:39:36 2023 GMT
            Not After : Feb  X 01:39:36 2023 GMT
        Subject: C = XX, ST = XX, L = XX, O = XXX, OU = XX, CN = XXXXX, emailAddress = xxx@xxx.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    ...
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                ...
            X509v3 Authority Key Identifier: 
                ...
            X509v3 Basic Constraints: critical
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        ...
```

**使用其他证书为密钥签名非根证书**

生成被签名的密钥

```
openssl genrsa -out server.key 2048
```

首先为该密钥生成CSR，习惯使用`.csr`后缀，之后会提示输入该密钥对应的地址，名称和邮件（`server.csr`文件会包含`server.key`中提取的公钥，外加地址，名称，邮件等信息，都是明文。最后会有一个自签名）

```
openssl req -new -key server.key -out server.csr -subj "/CN=domain.org"
cat server.csr
```

输出

```
-----BEGIN CERTIFICATE REQUEST-----
...
-----END CERTIFICATE REQUEST-----
```

可以使用以下命令，类似`x509`一样查看`server.csr`包含的信息，可查看信息内容和`.crt`基本相同

```
openssl req -text -noout -verify -in server.csr 
```

输出

```
Certificate request self-signature verify OK
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: C = XX, ST = XX, L = XX, O = XXX, OU = XX, CN = XXXXX, emailAddress = xxx@xxx.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    ...
                Exponent: 65537 (0x10001)
        Attributes:
            challengePassword:
            Requested Extensions:
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        ...
```

最终使用原先的根证书`prv.crt`和密钥`prv.key`为`server.csr`签名，生成`x509`格式`server.crt`

```
openssl x509 -req -in server.csr -CA prv.crt -CAkey prv.key -CAcreateserial -out server.crt -days 10
```

使用之前相同的方法解码`server.crt`，可以看到之前我们为`server.csr`设定的邮件等信息，此外多出了证书方的`prv.crt`内容

```
Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number:
            ...
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = XX, ST = XX, L = XX, O = XXX, OU = XX, CN = XXXXX, emailAddress = xxx@xxx.com
        Validity
            Not Before: Jan  X 02:37:09 2023 GMT
            Not After : Feb  X 02:37:09 2023 GMT
        Subject: C = XX, ST = XX, L = XX, O = XXX, OU = XX, CN = XXXXX, emailAddress = xxx@xxx.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    ...
                Exponent: 65537 (0x10001)
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        ...
```

> 实际应用中，为防止机器的密钥被盗取导致泄露，我们通常会在生成密钥时使用加密，例如`openssl genrsa -des3 -out server.key 2048`，并且修改密钥文件权限为`400`（`r--------`）。也可以用其他更安全的加密方法如`-aes256`。这样每次使用该密钥时都需要手动输入密码

> 可以将证书`pem`转换为`der`格式导入到某些软件，例如浏览器

```
openssl x509 -in server.crt -outform der -out server.der
```

**Chromium中的证书**

Chromium中根证书在`Settings -> Privacy and security -> Security -> Manage Certificates -> Authorities`。我们随意打开一个根证书如下，可以看到一些基本信息

![](images/221112a033.png)

![](images/221112a034.png)

我们打开 github.com，点击地址栏的锁就可以查看当前网站的证书

![](images/221112a035.png)

![](images/221112a036.png)

![](images/221112a037.png)

可以发现github使用了来自DigiCert的一个二级证书，并在证书中指明了获取该二级证书的URI。点击Export保存一下二级证书，并使用`openssl`解码（`x509`）得到如下内容

```
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            07:f2:f3:5c:87:a8:77:af:7a:ef:e9:47:99:35:25:bd
        Signature Algorithm: sha384WithRSAEncryption
        Issuer: C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA
        Validity
            Not Before: Apr 14 00:00:00 2021 GMT
            Not After : Apr 13 23:59:59 2031 GMT
        Subject: C = US, O = DigiCert Inc, CN = DigiCert TLS Hybrid ECC SHA384 2020 CA1
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    04:c1:1b:c6:9a:5b:98:d9:a4:29:a0:e9:d4:04:b5:
                    db:eb:a6:b2:6c:55:c0:ff:ed:98:c6:49:2f:06:27:
                    51:cb:bf:70:c1:05:7a:c3:b1:9d:87:89:ba:ad:b4:
                    13:17:c9:a8:b4:83:c8:b8:90:d1:cc:74:35:36:3c:
                    83:72:b0:b5:d0:f7:22:69:c8:f1:80:c4:7b:40:8f:
                    cf:68:87:26:5c:39:89:f1:4d:91:4d:da:89:8b:e4:
                    03:c3:43:e5:bf:2f:73
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        X509v3 extensions:
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:0
            X509v3 Subject Key Identifier: 
                0A:BC:08:29:17:8C:A5:39:6D:7A:0E:CE:33:C7:2E:B3:ED:FB:C3:7A
            X509v3 Authority Key Identifier: 
                03:DE:50:35:56:D1:4C:BB:66:F0:A3:E2:1B:1B:C3:97:B2:3D:D1:55
            X509v3 Key Usage: critical
                Digital Signature, Certificate Sign, CRL Sign
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication, TLS Web Client Authentication
            Authority Information Access: 
                OCSP - URI:http://ocsp.digicert.com
                CA Issuers - URI:http://cacerts.digicert.com/DigiCertGlobalRootCA.crt
            X509v3 CRL Distribution Points: 
                Full Name:
                  URI:http://crl3.digicert.com/DigiCertGlobalRootCA.crl
            X509v3 Certificate Policies: 
                Policy: 2.16.840.1.114412.2.1
                Policy: 2.23.140.1.1
                Policy: 2.23.140.1.2.1
                Policy: 2.23.140.1.2.2
                Policy: 2.23.140.1.2.3
    Signature Algorithm: sha384WithRSAEncryption
    Signature Value:
        47:59:81:7f:d4:1b:1f:b0:71:f6:98:5d:18:ba:98:47:98:b0:
        7e:76:2b:ea:ff:1a:8b:ac:26:b3:42:8d:31:e6:4a:e8:19:d0:
        ef:da:14:e7:d7:14:92:a1:92:f2:a7:2e:2d:af:fb:1d:f6:fb:
        53:b0:8a:3f:fc:d8:16:0a:e9:b0:2e:b6:a5:0b:18:90:35:26:
        a2:da:f6:a8:b7:32:fc:95:23:4b:c6:45:b9:c4:cf:e4:7c:ee:
        e6:c9:f8:90:bd:72:e3:99:c3:1d:0b:05:7c:6a:97:6d:b2:ab:
        02:36:d8:c2:bc:2c:01:92:3f:04:a3:8b:75:11:c7:b9:29:bc:
        11:d0:86:ba:92:bc:26:f9:65:c8:37:cd:26:f6:86:13:0c:04:
        aa:89:e5:78:b1:c1:4e:79:bc:76:a3:0b:51:e4:c5:d0:9e:6a:
        fe:1a:2c:56:ae:06:36:27:a3:73:1c:08:7d:93:32:d0:c2:44:
        19:da:8d:f4:0e:7b:1d:28:03:2b:09:8a:76:ca:77:dc:87:7a:
        ac:7b:52:26:55:a7:72:0f:9d:d2:88:4f:fe:b1:21:c5:1a:a1:
        aa:39:f5:56:db:c2:84:c4:35:1f:70:da:bb:46:f0:86:bf:64:
        00:c4:3e:f7:9f:46:1b:9d:23:05:b9:7d:b3:4f:0f:a9:45:3a:
        e3:74:30:98
```


## 5.6 QUIC

`QUIC`（发音同quick）基于`UDP`设计，最初由Google开发，作为`TCP`的替代品，主要用于新一代`HTTP/3`。现在主流浏览器都已支持`QUIC`

## 6 应用层

## 6.1 HTTP



## 6.2 HTTPS

## 6.3 DNS

参考RFC1034 RFC1035

`DNS`全称`Domain Name System`，负责域名到地址的解析

IP地址难以记忆。且如果一个网站更换了IP，访问它的客户端就不得不更改访问配置。`DNS`应运而生，并且已经成为了最老的应用层协议之一。此外`DNS`也可以起到负载均衡的作用（在分布式系统中）

### 6.3.1 DNS域名基本概念

以域名`www.metal-archives.com`为例，这个域名中的`www` `metal-archives` `com`称为标签`label`，每个长度不超过`63`字节，总长不超过`255`字节。所有的域名最后都有一个长度`0`的`null`标签，表示根域`root`，域名在此结束

> 根域`root`下的顶级域`Top Level Domains`有`.com .org .edu .gov .mil .net .info .uk .jp .de .cn .hk .fi`等，主要包括了常用机构，以及国家名。而二级域在顶级域之下，常见的例如`.cn`下的`.com .edu`，`.jp`下的`.co .ac`。上例中`metal-archives.com`的`metal-archives`也是直接挂靠在`.com`顶级域下的一个二级域
>
> 域名的概念和域不同。`metal-archives.com`这个域名本身是一个顶级域名，而`zol.com.cn`是一个二级域名
>
> 邮件域名格式和普通站点域名有所不同，格式为`<local-part>@<mail-domain>`，需要将`@`前后进行拆分合并，例如`mastermail@outlook.com`变成`mastermail.outlook.com`再进行处理

### 6.3.2 DNS系统组成

`DNS`系统由**边缘服务器**（称为`Recursive Server`或`Caching Server`），**权威服务器**（称为`Authoritative Server`或`Iterative Server`）以及**客户端**（`Client`）三大角色构成。客户端向边缘DNS服务器发送域名查询请求，如果边缘服务器没有在缓存中查找到对应信息，就需要代客户端向权威服务器发送请求，获取到信息以后回复给客户端

权威服务器有主服务器`Master`和从服务器`Slave`之分。每台服务器都会存储一张信息表，称为`Resource Records`（`RR`），其中包含该服务器知晓的域名信息，一台服务器的`RR`的集合称为一个`Zone`。更高级别的服务器中包含的`RR`可能指向更低级别服务器地址，告知边缘服务器询问该更低级别的权威服务器（等级是相对的，实际应用中等级并没有绝对的高低之分。上述步骤称为下放`delegation`）

世界上存在最高等级的`DNS`服务器，这就是根服务器。它们必须知晓所有的顶级域信息（无论是IP地址还是指向其他`DNS`服务器），例如`.com .org`等

边缘服务器在接收到客户端的`DNS`请求后，首先会查找缓存是否有已有的记录。如果没有，再按从高级权威服务器到低级权威服务器的顺序进行询问，直到有权威服务器给出具体的IP地址

> `DNS`服务器监听`TCP`和`UDP`的`53`端口，其中通过`UDP`传输的数据包不超过`512`字节，更大的数据包需要使用`TCP`传输。通常**边缘服务器**和**客户端**之间优先使用`UDP`进行数据传输（大小不够再使用`TCP`），而**边缘服务器**和**权威服务器**之间的数据交换通常使用`TCP`传输


### 6.3.3 Resource Records

一条`RR`数据包含如下内容

|  |  |
| :-: | :-: |
| `owner` | 域名，即`Name` |
| `type` | `RR`数据类型，可以为`A`IPv4地址，`AAAA`IPv6地址，`PTR`反向解析（地址到域名），`CNAME`别名（获取到真正域名后需要再次请求并返回结果），`MX`该域名相关的邮件服务域名+优先级，`NS`下一级`DNS`服务器地址（域名形式），`SOA`列表起始，`TXT`普通字符，`HINFO`处理器和系统类型 |
| `class` | 永远为`IN`，指`Internet` |
| `TTL` | `Time to live`，该`RR`的有效期，单位秒 |
| `RDATA` | 数据，内容取决于`type` |

> `PTR`反向解析需要使用`in-addr.arpa`作为`Name`

Linux下可以使用`dig`命令向指定`DNS`服务器发送请求

```
dig @10.80.192.1 github.com A
```

部分测试结果

```
owner           TTL     class   type    RDATA

github.com.		9	    IN      A       140.82.121.3
github.com.		3600	IN      MX      1 aspmx.l.google.com.
pixiv.net.		240     IN      A       210.140.92.193
netflix.com.	51      IN      AAAA    2a05:d018:76c:b683:a2cd:4240:8669:6d4
```

### 6.3.4 DNS数据包格式

`DNS`数据包格式如下

```
    +---------------------+
    |        Header       |
    +---------------------+
    |       Question      | the question for the name server
    +---------------------+
    |        Answer       | RRs answering the question
    +---------------------+
    |      Authority      | RRs pointing toward an authority
    +---------------------+
    |      Additional     | RRs holding additional information
    +---------------------+
```

> 所有的`DNS`数据包都有数据头，而之后的`Question` `Answer` `Authority` `Additional Information`都是可选的，视具体情况而定
>
> `Question`包含了查询请求的`QTYPE` `QCLASS`和`QNAME`。而后面的三个格式相同，都由`RR`组成
>
> `Answer`包含了直接对应`Question`请求内容的回复（`RR`），可以是`MX`（指出域名邮件服务对应的域名）
>
> `Authority`通常用于搭载`NS`的`RR`（给出下一级`DNS`的域名），可能包含`SOA`
>
> `Additional information`搭载额外的有用信息，通常对应上面`MX`或`NS`的补充性信息，例如下一级`DNS`服务器域名对应的IP地址（类型`A`或`AAAA`）

其中`Header`格式如下

```
                                    1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      ID                       |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    QDCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ANCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    NSCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ARCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

定义

| 域 | 作用 |
| :-: | :-: |
| `ID` | `Transaction ID`，每次请求和对应的回复使用相同的`Transaction ID` |
| `QR` | `0`表示请求，`1`表示回复 |
| `Opcode` | 操作类型，`0`为正向解析请求，`1`为反向解析请求，`2`为状态请求（`2`不常用） |
| `AA` | 指示位`Authoritative Answer`，**权威服务器**回复的数据包（服务器有该请求域名对应的`RR`项）中该位通常会置位 |
| `TC` | 指示位`TrunCation`，表示信息长度超过`UDP`的`512`字节限制，需要重新使用`TCP`传输 |
| `RD` | 指示位`Recursion Desired`，通知**边缘服务器**进行递归式请求。在**客户端**和**边缘服务器**间的数据包中常见（请求对应的回复也要置位） |
| `RA` | 指示位`Recursion Available`，在服务器的回复中表示是否支持递归式解析 |
| `Z` | 保留 |
| `RCODE` | 回复状态码。`0`正常，`1`请求格式错误`Format error`，`2`服务器错误`Server failure`，`3`权威服务器未找到域名`Name error`，`4`不支持的请求`Not implemented`，`5`服务器拒绝请求`Refused` |
| `QDCOUNT ANCOUNT NSCOUNT ARCOUNT` | 分别表示`Question Answer Authority Addtional`的入口数量 |

### 6.3.5 Question数据格式

```
                                    1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                                               |
    /                     QNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     QTYPE                     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     QCLASS                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

> 在`DNS`域名的数据表示中，每一个`label`都有一个字符串长度前缀（占`1`字节）。`www.metal-archives.com`在`DNS`中使用`[3]www[14]metal-archives[3]com[0]`表示，长度`24`字节
>
> 长度前缀只能取`0x00`到`0x3F`，`192`及以上的前缀为特殊前缀`0xC0`开始

> `QNAME`为上述格式的域名数据。长度可以是奇数，且无需对齐
>
> `QTYPE`同`RR`的`type`，定义见下
>
> `QCLASS`同`RR`的`class`，为`IN`（`1`）

| QTYPE号 | 定义 |
| :-: | :-: |
| `1` | `A`，IPv4地址 |
| `2` | `NS`，下一级`DNS`服务器地址（域名形式） |
| `3` | 淘汰 |
| `4` | 淘汰 |
| `5` | `CNAME`，别名，获取到真正域名后需要再次请求并返回结果 |
| `6` | `SOA`，zone列表的起始 |
| `7` | 实验 |
| `8` | 实验 |
| `9` | 实验 |
| `10` | 实验 |
| `11` | `WKS`，`Well known service`描述 |
| `12` | `PTR`，反向解析地址 |
| `13` | `HINFO`，主机信息 |
| `14` | `MINFO`，邮箱信息 |
| `15` | `MX`，优先级+邮箱服务域名 |
| `16` | `TXT`，文本 |
| `28` | `AAAA`，IPv6地址 |
| `252` | `AXFR`，请求一个zone（通常是权威服务器之间） |
| `253` | 实验 |
| `254` | 淘汰 |
| `255` | `*`，请求所有`RR` |

### 6.3.6 RR数据格式

该数据格式用于`Answer` `Authority`和`Addtional`，是这些数据域的基本组成单元

```
                                    1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                                               |
    /                                               /
    /                      NAME                     /
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      TYPE                     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     CLASS                     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      TTL                      |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                   RDLENGTH                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
    /                     RDATA                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

> 定义和[之前介绍的](#633-resource-records)相同。相比添加了`RDLENGTH`表明`RDATA`数据域的长度

`A`和`AAAA`类型数据长度分别`4`字节和`16`字节

`HINFO`格式如下

``` 
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                      CPU                      /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                       OS                      /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

`MX`格式如下，开头有`2`字节的优先级。如果有多个`MX`，那么优先级数字最小的域名将会被选择

```
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                  PREFERENCE                   |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   EXCHANGE                    /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

`SOA`格式如下，`MNAME`和`RNAME`分别表示zone的发送方和邮箱，`SERIAL`用于区分新旧zone，`REFRESH`定义刷新时间

```
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                     MNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                     RNAME                     /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    SERIAL                     |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    REFRESH                    |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     RETRY                     |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    EXPIRE                     |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    MINIMUM                    |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

**域名压缩机制**

同样的域名在一个`DNS`数据包中通常只需出现一次即可。这使用到了[之前](#635-question数据格式)介绍域名表示格式时的长度前缀特殊值。这个特殊值之后的`1`字节表示域名字符串的起始位置，可以通过下面的抓包理解

```
dig @10.80.192.1 netflix.com
```

`netflix.com`第一次出现的位置

![](images/221112a045.png)

第二次出现的位置，直接使用`0xc0 0x0c`代替。`0x0c`正是字符串`netflix.com`开头的`0x07`在`DNS`数据中的地址

![](images/221112a046.png)

### 6.3.7 DNS抓包

使用`host`命令，会请求IPv4、IPv6以及邮件

```
host github.com
```

![](images/221112a048.png)

使用`dig`命令，默认只会请求IPv4

```
dig @10.80.192.1 github.com
```

![](images/221112a047.png)


## 6.4 DHCP和DHCPv6



### 6.4.1 SLAAC

## 6.5 Telnet

## 6.6 FTP和SFTP

## 6.7 SMTP

## 6.8 SNMP

## 7 附录

## 7.1 Wireshark中部分TCP分析的定义

由于Wireshark只能从本机的角度进行`TCP`数据流的分析，所以是有局限性的，许多分析结果并不准确。**实际使用时需要注意甄别Wireshark分析的准确性**

### 7.1.1 TCP ACKed unseen segment

Set when the expected next acknowledgment number is set for the reverse direction and it’s less than the current acknowledgment number.

### 7.1.2 TCP Dup ACK

Set when all of the following are true:

+ The segment size is zero.
+ The window size is non-zero and hasn’t changed.
+ The next expected sequence number and last-seen acknowledgment number are non-zero (i.e., the connection has been established).
+ SYN, FIN, and RST are not set.

### 7.1.3 TCP Fast Retransmission

Set when all of the following are true:

+ This is not a keepalive packet.
+ In the forward direction, the segment size is greater than zero or the SYN or FIN is set.
+ The next expected sequence number is greater than the current sequence number.
+ We have more than two duplicate ACKs in the reverse direction.
+ The current sequence number equals the next expected acknowledgment number.
+ We saw the last acknowledgment less than 20ms ago.
+ Supersedes “Out-Of-Order” and “Retransmission”.

### 7.1.4 TCP Keep-Alive

Set when the segment size is zero or one, the current sequence number is one byte less than the next expected sequence number, and none of SYN, FIN, or RST are set.

Supersedes “Fast Retransmission”, “Out-Of-Order”, “Spurious Retransmission”, and “Retransmission”.

### 7.1.5 TCP Keep-Alive ACK

Set when all of the following are true:

+ The segment size is zero.
+ The window size is non-zero and hasn’t changed.
+ The current sequence number is the same as the next expected sequence number.
+ The current acknowledgment number is the same as the last-seen acknowledgment number.
+ The most recently seen packet in the reverse direction was a keepalive.
+ The packet is not a SYN, FIN, or RST.

Supersedes “Dup ACK” and “ZeroWindowProbeAck”.

### 7.1.6 TCP Out-Of-Order

Set when all of the following are true:

+ This is not a keepalive packet.
+ In the forward direction, the segment length is greater than zero or the SYN or FIN is set.
+ The next expected sequence number is greater than the current sequence number.
+ The next expected sequence number and the next sequence number differ.
+ The last segment arrived within the Out-Of-Order RTT threshold. The threshold is either the value shown in the “iRTT” (tcp.analysis.initial_rtt) field under “SEQ/ACK analysis” if it is present, or the default value of 3ms if it is not.

Supersedes “Retransmission”.

### 7.1.7 TCP Port numbers reused

Set when the SYN flag is set (not SYN+ACK), we have an existing conversation using the same addresses and ports, and the sequence number is different than the existing conversation’s initial sequence number.

### 7.1.8 TCP Previous segment not captured

Set when the current sequence number is greater than the next expected sequence number.

### 7.1.9 TCP Spurious Retransmission

Checks for a retransmission based on analysis data in the reverse direction. Set when all of the following are true:

+ The SYN or FIN flag is set.
+ This is not a keepalive packet.
+ The segment length is greater than zero.
+ Data for this flow has been acknowledged. That is, the last-seen acknowledgment number has been set.
+ The next sequence number is less than or equal to the last-seen acknowledgment number.

Supersedes “Fast Retransmission”, “Out-Of-Order”, and “Retransmission”.

### 7.1.10 TCP Retransmission

Set when all of the following are true:

+ This is not a keepalive packet.
+ In the forward direction, the segment length is greater than zero or the SYN or FIN flag is set.
+ The next expected sequence number is greater than the current sequence number.

### 7.1.11 TCP Window Full

Set when the segment size is non-zero, we know the window size in the reverse direction, and our segment size exceeds the window size in the reverse direction.

### 7.1.12 TCP Window Update

Set when the all of the following are true:

+ The segment size is zero.
+ The window size is non-zero and not equal to the last-seen window size.
+ The sequence number is equal to the next expected sequence number.
+ The acknowledgment number is equal to the last-seen acknowledgment number.
+ None of SYN, FIN, or RST are set.

### 7.1.13 TCP ZeroWindow

Set when the receive window size is zero and none of SYN, FIN, or RST are set.

The window field in each TCP header advertises the amount of data a receiver can accept. If the receiver can’t accept any more data it will set the window value to zero, which tells the sender to pause its transmission. In some specific cases this is normal — for example, a printer might use a zero window to pause the transmission of a print job while it loads or reverses a sheet of paper. However, in most cases this indicates a performance or capacity problem on the receiving end. It might take a long time (sometimes several minutes) to resume a paused connection, even if the underlying condition that caused the zero window clears up quickly.

### 7.1.14 TCP ZeroWindowProbe

Set when the sequence number is equal to the next expected sequence number, the segment size is one, and last-seen window size in the reverse direction was zero.

If the single data byte from a Zero Window Probe is dropped by the receiver (not ACKed), then a subsequent segment should not be flagged as retransmission if all of the following conditions are true for that segment: * The segment size is larger than one. * The next expected sequence number is one less than the current sequence number.

This affects “Fast Retransmission”, “Out-Of-Order”, or “Retransmission”.

### 7.1.15 TCP ZeroWindowProbeAck

Set when the all of the following are true:

+ The segment size is zero.
+ The window size is zero.
+ The sequence number is equal to the next expected sequence number.
+ The acknowledgment number is equal to the last-seen acknowledgment number.
+ The last-seen packet in the reverse direction was a zero window probe.

Supersedes “TCP Dup ACK”.

### 7.1.16 TCP Ambiguous Interpretations

Some captures are quite difficult to analyze automatically, particularly when the time frame may cover both Fast Retransmission and Out-Of-Order packets. A TCP preference allows to switch the precedence of these two interpretations at the protocol level.

### 7.1.17 TCP Conversation Completeness

TCP conversations are said to be complete when they have both opening and closing handshakes, independently of any data transfer. However, we might be interested in identifying complete conversations with some data sent, and we are using the following bit values to build a filter value on the tcp.completeness field :

1 : SYN

2 : SYN-ACK

4 : ACK

8 : DATA

16 : FIN

32 : RST

For example, a conversation containing only a three-way handshake will be found with the filter 'tcp.completeness==7' (1+2+4) while a complete conversation with data transfer will be found with a longer filter as closing a connection can be associated with FIN or RST packets, or even both : 'tcp.completeness==31 or tcp.completeness==47 or tcp.completeness==63'

## 7.2 BGP

## 7.3 CDN