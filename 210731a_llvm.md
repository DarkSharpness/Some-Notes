# LLVM学习笔记

有关现代编译器框架LLVM的笔记

附录为CSAPP第7章**链接**的学习笔记

# 参考书籍

*Getting Started with LLVM Core Libraries, Bruno Cardoso Lopes, Rafael Auler, Brazil, 2014*

*LLVM Cookbook, Mayur Pandey, Suyog Sarda, India, 2016*


## 1 


## 附录

## CSAPP第7章：链接

有关计算机中可执行文件的结构，ABI，以及编译器链接过程的工作原理


## 1 链接基本概念

我们在平时编写一个简单的控制台程序时很少会遇到链接。然而事实上链接无处不在，大型工程的构建离不开链接。链接器实现了程序构建的模块化，开发者可以将不同功能的代码分开，降低代码耦合度，从而方便功能的修改以及增删，方便了工程的管理。同时，链接使得闭源代码的发布成为可能

在有操作系统支持的环境中，链接一般可以分为**编译时链接**（由编译器负责，使用静态库），**加载时链接**（由操作系统加载器负责，使用共享库）以及**运行时链接**（由应用程序负责，使用共享库）。而在一些裸机环境中如单片机一般只有编译时链接，所有的代码都需要通过静态链接以后下载至Flash才能运行


## 1.1 编译器基本工作流程

我们平时使用GCC编译一个程序（`gcc main.c -o test`），事实上要经过**预处理器**、**编译器**、**汇编器**以及**链接器**共4个工具的处理，这4种工具分别对应`cpp`，`cc`，`as`以及`ld`。我们使用的`gcc`命令事实上不是编译器本体，只是一个外壳，用来调用上述的四种工具。像`gcc`这样的命令被称为**驱动器（driver）**

> 其中，预处理器`cpp`处理源码中的宏以及文件包含，输出`.i`预处理后的源文件
>
> 之后编译器`cc`将源码文件编译成为ascii码格式的`.s`汇编文件，其中存储了之后构建二进制文件所需的汇编代码，符号，常量等
>
> 汇编器`as`会将汇编代码文件`.s`翻译成为二进制的`.o`可重定位目标文件，此时的`.o`文件是可以直接被计算机CPU识别的二进制文件。多个`.o`文件可以使用`ar`打包成为一个`.a`库文件（此外还可以选择生成动态链接库等格式）
>
> 最后如果是使用静态链接，就需要使用到链接器`ld`。`ld`会将多个`.o`可重定位目标文件链接成为一个可执行文件。通过shell执行该文件时会调用操作系统的加载器，将可执行文件加载到内存中并运行
>
> 运行时动态链接使用`.so`共享目标文件格式，由操作系统加载到内存并链接


## 1.2 目标文件

在Linux下的目标文件使用ELF（`.elf`）（Executable and Linkable Format）格式，尽管实际文件格式的定义有所不同。链接这些目标文件就是链接器的根本任务

> 3种目标文件如下：
>
> **可重定位目标文件**：只能使用**静态链接**的方式应用到程序中，一般为`.o`文件，可以使用`ar`打包成为一个`.a`库文件
>
> **可执行目标文件**：可以直接被操作系统加载器加载到内存中执行的文件
>
> **共享目标文件**：可以在程序被加载或执行时动态地加载到内存中并链接的文件，一般为`.so`后缀

不同机器、不同操作系统的目标文件格式是不同的。同样是在x86平台，Windows下的`.exe`和`.dll`放到Linux环境下当然是不能直接使用的

也是由于以上原因，在Linux下会出现`wine`用于模拟Windows的运行环境（当然wine远不止二进制兼容），FreeBSD会提供针对Linux的ABI兼容选项，而Windows下会有`mingw`和`msys2`这样的第三方类Unix环境出现


## 2 目标文件结构

ELF文件可以看作一个映像，其中主要包含了程序运行所需的数据和指令，ELF文件的格式大致如下

![](images/210731a001.png)


## 2.1 ELF头

ELF头由一个16字节的序列开始。这个16字节的序列会给出目标机器的字长以及字节序（大小端）等等信息

在这16字节之后都是一些基本信息，包括**ELF头大小**，**文件类型（可重定位、可执行、可共享）**，**机器类型（使用的ISA）**，**节头部表的偏移地址**，以及**节头部表中条目大小和数量**

节头部表一般位于ELF文件结尾，其中每一项（一个Entry）都用于描述不同节（Section）的位置和大小

FreeBSD中[ELF32头定义](https://cgit.freebsd.org/src/tree/sys/sys/elf32.h?h=stable/13)如下

```c
/*
 * ELF header.
 */

typedef struct {
	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
	Elf32_Half	e_type;		/* File type. */
	Elf32_Half	e_machine;	/* Machine architecture. */
	Elf32_Word	e_version;	/* ELF format version. */
	Elf32_Addr	e_entry;	/* Entry point. */
	Elf32_Off	e_phoff;	/* Program header file offset. */
	Elf32_Off	e_shoff;	/* Section header file offset. */
	Elf32_Word	e_flags;	/* Architecture-specific flags. */
	Elf32_Half	e_ehsize;	/* Size of ELF header in bytes. */
	Elf32_Half	e_phentsize;	/* Size of program header entry. */
	Elf32_Half	e_phnum;	/* Number of program header entries. */
	Elf32_Half	e_shentsize;	/* Size of section header entry. */
	Elf32_Half	e_shnum;	/* Number of section header entries. */
	Elf32_Half	e_shstrndx;	/* Section name strings section. */
} Elf32_Ehdr;
```


## 2.2 节（Section）

ELF文件中的节依照存储数据的类型分为很多种

> `.text`：程序的二进制机器代码，最重要的部分之一
>
> `.rodata`：只读数据，比如在`printf()`中使用到的字符串常量，以及`switch`语句中使用到的跳转表等（很多CPU都支持`switch`专用的跳转指令）
>
> `.data`：**已经初始化的全局、静态变量**，在ELF文件中占有实际空间
>
> `.bss`：**未初始化或初始化为0的全局、静态变量**。这里面的数据仅仅是各个变量的占位符，这些变量在ELF文件中不会占有实际的数据空间，直到运行时才会分配空间。区分`.data`和`.bss`是为了提高存储效率。运行时的**局部变量**存储于**栈**中所以不会出现在`.data`和`.bss`中
>
> `.symtab`：符号表，最重要的部分之一，用于存储在程序中定义、引用的**函数**以及**全局变量**的信息。**不包含局部变量**
>
> `.rel.text`：重定位信息（`rel`就是relocation的缩写），位置列表。可以理解为全局变量以及函数的地址，在重定位时需要修改这些地址。局部函数由于一般采用相对地址跳转所以不修改
>
> `.rel.data`：重定位信息，存储当前模块引用或定义的全局变量的信息
>
> `.debug`：调试符号表，存储程序中各种变量以及类型定义，包括局部变量，以及在本模块定义或引用的全局变量。另外还有原始的C源文件，用于调试时代码的定位
>
> `.line`：代码映射列表，只有使用`-g`选项时可用。存储`.debug`中C源文件代码和`.text`中机器码的映射，C代码的调试依赖于`.line`
>
> `.strtab`：字符串表，存储了`.symtab`以及`.debug`中的符号表以及节名。每一个字符串以null（0x00）结尾


## 2.3 符号与符号表

每一个可重定位模块都有符号表以及对应存储的符号

> 符号分为以下3种：
>
> **全局链接器符号**：非`static`定义的函数和全局变量，在本模块定义并可以被其他模块引用
>
> **外部符号**：`extern`声明的函数和全局变量，在其他模块定义并被本模块引用
>
> **局部符号（本地链接器符号）**：使用`static`定义的函数和全局变量，只在本模块定义与引用，其他模块无法访问